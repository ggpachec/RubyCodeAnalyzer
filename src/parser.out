Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND_OP
    DO
    NEXT
    NOT
    NOT_OP
    OR_OP
    SEMICOLON
    THEN
    YIELD

Grammar

Rule 0     S' -> start
Rule 1     start -> sentences
Rule 2     sentences -> sentence
Rule 3     sentences -> sentence sentences
Rule 4     function -> DEF ID body END
Rule 5     function -> DEF ID LPAREN args RPAREN body END
Rule 6     args -> ID
Rule 7     args -> ID COMMA args
Rule 8     body -> sentence
Rule 9     body -> sentence body
Rule 10    print -> PUTS factor
Rule 11    class_def -> CLASS ID body END
Rule 12    sentence -> assignment
Rule 13    sentence -> expression
Rule 14    sentence -> print
Rule 15    sentence -> input
Rule 16    sentence -> condition
Rule 17    sentence -> while_loop
Rule 18    sentence -> for_loop
Rule 19    sentence -> array
Rule 20    sentence -> range_incl
Rule 21    sentence -> range_excl
Rule 22    sentence -> hash
Rule 23    sentence -> function
Rule 24    sentence -> class_def
Rule 25    sentence -> return_stmt
Rule 26    sentence -> break_stmt
Rule 27    sentence -> function_call_empty
Rule 28    sentence -> function_call_args
Rule 29    return_stmt -> RETURN factor
Rule 30    break_stmt -> BREAK
Rule 31    assignment -> ID ASSIGN expression
Rule 32    assignment -> VAR_INST ASSIGN expression
Rule 33    input -> PUTS STRING
Rule 34    input -> ID ASSIGN GETS DOT ID
Rule 35    expression -> expression PLUS term
Rule 36    expression -> expression MINUS term
Rule 37    expression -> term
Rule 38    term -> term TIMES factor
Rule 39    term -> term DIVIDE factor
Rule 40    term -> term EXPONENT factor
Rule 41    term -> term MODULE factor
Rule 42    term -> factor
Rule 43    factor -> INTEGER
Rule 44    factor -> FLOAT
Rule 45    factor -> STRING
Rule 46    factor -> BOOLEAN
Rule 47    factor -> ID
Rule 48    factor -> VAR_INST
Rule 49    factor -> TRUE
Rule 50    factor -> FALSE
Rule 51    factor -> NIL
Rule 52    factor -> LPAREN expression RPAREN
Rule 53    factor -> logic_expression
Rule 54    function_call_empty -> ID LPAREN RPAREN
Rule 55    function_call_args -> ID LPAREN args RPAREN
Rule 56    array -> ID ASSIGN LCORCH elements RCORCH
Rule 57    elements -> factor
Rule 58    elements -> factor COMMA elements
Rule 59    for_loop -> FOR ID IN range_incl body END
Rule 60    hash -> ID ASSIGN LBRACE hash_pairs RBRACE
Rule 61    hash_pairs -> STRING COLON factor
Rule 62    hash_pairs -> STRING COLON factor COMMA hash_pairs
Rule 63    while_loop -> WHILE logic_expression body END
Rule 64    range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN
Rule 65    range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
Rule 66    condition -> IF logic_expression body END
Rule 67    condition -> IF logic_expression body ELSE body END
Rule 68    logic_expression -> factor logic_op factor
Rule 69    logic_expression -> factor logic_op factor logic_connector logic_expression
Rule 70    logic_op -> EQUALS
Rule 71    logic_op -> NEQUALS
Rule 72    logic_op -> GREATEREQ
Rule 73    logic_op -> LESSEQ
Rule 74    logic_op -> GREATERT
Rule 75    logic_op -> LESST
Rule 76    logic_connector -> AND
Rule 77    logic_connector -> OR

Terminals, with rules where they appear

AND                  : 76
AND_OP               : 
ASSIGN               : 31 32 34 56 60
BOOLEAN              : 46
BREAK                : 30
CLASS                : 11
COLON                : 61 62
COMMA                : 7 58 62
DEF                  : 4 5
DIVIDE               : 39
DO                   : 
DOT                  : 34
ELSE                 : 67
END                  : 4 5 11 59 63 66 67
EQUALS               : 70
EXPONENT             : 40
FALSE                : 50
FLOAT                : 44
FOR                  : 59
GETS                 : 34
GREATEREQ            : 72
GREATERT             : 74
ID                   : 4 5 6 7 11 31 34 34 47 54 55 56 59 60
IF                   : 66 67
IN                   : 59
INTEGER              : 43 64 64 65 65
LBRACE               : 60
LCORCH               : 56
LESSEQ               : 73
LESST                : 75
LPAREN               : 5 52 54 55 64 65
MINUS                : 36
MODULE               : 41
NEQUALS              : 71
NEXT                 : 
NIL                  : 51
NOT                  : 
NOT_OP               : 
OR                   : 77
OR_OP                : 
PLUS                 : 35
PUTS                 : 10 33
RANGE_EXCL           : 65
RANGE_INCL           : 64
RBRACE               : 60
RCORCH               : 56
RETURN               : 29
RPAREN               : 5 52 54 55 64 65
SEMICOLON            : 
STRING               : 33 45 61 62
THEN                 : 
TIMES                : 38
TRUE                 : 49
VAR_INST             : 32 48
WHILE                : 63
YIELD                : 
error                : 

Nonterminals, with rules where they appear

args                 : 5 7 55
array                : 19
assignment           : 12
body                 : 4 5 9 11 59 63 66 67 67
break_stmt           : 26
class_def            : 24
condition            : 16
elements             : 56 58
expression           : 13 31 32 35 36 52
factor               : 10 29 38 39 40 41 42 57 58 61 62 68 68 69 69
for_loop             : 18
function             : 23
function_call_args   : 28
function_call_empty  : 27
hash                 : 22
hash_pairs           : 60 62
input                : 15
logic_connector      : 69
logic_expression     : 53 63 66 67 69
logic_op             : 68 69
print                : 14
range_excl           : 21
range_incl           : 20 59
return_stmt          : 25
sentence             : 2 3 8 9
sentences            : 1 3
start                : 0
term                 : 35 36 37 38 39 40 41
while_loop           : 17

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . sentences
    (2) sentences -> . sentence
    (3) sentences -> . sentence sentences
    (12) sentence -> . assignment
    (13) sentence -> . expression
    (14) sentence -> . print
    (15) sentence -> . input
    (16) sentence -> . condition
    (17) sentence -> . while_loop
    (18) sentence -> . for_loop
    (19) sentence -> . array
    (20) sentence -> . range_incl
    (21) sentence -> . range_excl
    (22) sentence -> . hash
    (23) sentence -> . function
    (24) sentence -> . class_def
    (25) sentence -> . return_stmt
    (26) sentence -> . break_stmt
    (27) sentence -> . function_call_empty
    (28) sentence -> . function_call_args
    (31) assignment -> . ID ASSIGN expression
    (32) assignment -> . VAR_INST ASSIGN expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (10) print -> . PUTS factor
    (33) input -> . PUTS STRING
    (34) input -> . ID ASSIGN GETS DOT ID
    (66) condition -> . IF logic_expression body END
    (67) condition -> . IF logic_expression body ELSE body END
    (63) while_loop -> . WHILE logic_expression body END
    (59) for_loop -> . FOR ID IN range_incl body END
    (56) array -> . ID ASSIGN LCORCH elements RCORCH
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (60) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (11) class_def -> . CLASS ID body END
    (29) return_stmt -> . RETURN factor
    (30) break_stmt -> . BREAK
    (54) function_call_empty -> . ID LPAREN RPAREN
    (55) function_call_args -> . ID LPAREN args RPAREN
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    start                          shift and go to state 1
    sentences                      shift and go to state 2
    sentence                       shift and go to state 3
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 1

    (0) S' -> start .



state 2

    (1) start -> sentences .

    $end            reduce using rule 1 (start -> sentences .)


state 3

    (2) sentences -> sentence .
    (3) sentences -> sentence . sentences
    (2) sentences -> . sentence
    (3) sentences -> . sentence sentences
    (12) sentence -> . assignment
    (13) sentence -> . expression
    (14) sentence -> . print
    (15) sentence -> . input
    (16) sentence -> . condition
    (17) sentence -> . while_loop
    (18) sentence -> . for_loop
    (19) sentence -> . array
    (20) sentence -> . range_incl
    (21) sentence -> . range_excl
    (22) sentence -> . hash
    (23) sentence -> . function
    (24) sentence -> . class_def
    (25) sentence -> . return_stmt
    (26) sentence -> . break_stmt
    (27) sentence -> . function_call_empty
    (28) sentence -> . function_call_args
    (31) assignment -> . ID ASSIGN expression
    (32) assignment -> . VAR_INST ASSIGN expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (10) print -> . PUTS factor
    (33) input -> . PUTS STRING
    (34) input -> . ID ASSIGN GETS DOT ID
    (66) condition -> . IF logic_expression body END
    (67) condition -> . IF logic_expression body ELSE body END
    (63) while_loop -> . WHILE logic_expression body END
    (59) for_loop -> . FOR ID IN range_incl body END
    (56) array -> . ID ASSIGN LCORCH elements RCORCH
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (60) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (11) class_def -> . CLASS ID body END
    (29) return_stmt -> . RETURN factor
    (30) break_stmt -> . BREAK
    (54) function_call_empty -> . ID LPAREN RPAREN
    (55) function_call_args -> . ID LPAREN args RPAREN
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    $end            reduce using rule 2 (sentences -> sentence .)
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    sentence                       shift and go to state 3
    sentences                      shift and go to state 42
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 4

    (12) sentence -> assignment .

    ID              reduce using rule 12 (sentence -> assignment .)
    VAR_INST        reduce using rule 12 (sentence -> assignment .)
    PUTS            reduce using rule 12 (sentence -> assignment .)
    IF              reduce using rule 12 (sentence -> assignment .)
    WHILE           reduce using rule 12 (sentence -> assignment .)
    FOR             reduce using rule 12 (sentence -> assignment .)
    LPAREN          reduce using rule 12 (sentence -> assignment .)
    DEF             reduce using rule 12 (sentence -> assignment .)
    CLASS           reduce using rule 12 (sentence -> assignment .)
    RETURN          reduce using rule 12 (sentence -> assignment .)
    BREAK           reduce using rule 12 (sentence -> assignment .)
    INTEGER         reduce using rule 12 (sentence -> assignment .)
    FLOAT           reduce using rule 12 (sentence -> assignment .)
    STRING          reduce using rule 12 (sentence -> assignment .)
    BOOLEAN         reduce using rule 12 (sentence -> assignment .)
    TRUE            reduce using rule 12 (sentence -> assignment .)
    FALSE           reduce using rule 12 (sentence -> assignment .)
    NIL             reduce using rule 12 (sentence -> assignment .)
    $end            reduce using rule 12 (sentence -> assignment .)
    END             reduce using rule 12 (sentence -> assignment .)
    ELSE            reduce using rule 12 (sentence -> assignment .)


state 5

    (13) sentence -> expression .
    (35) expression -> expression . PLUS term
    (36) expression -> expression . MINUS term

    ID              reduce using rule 13 (sentence -> expression .)
    VAR_INST        reduce using rule 13 (sentence -> expression .)
    PUTS            reduce using rule 13 (sentence -> expression .)
    IF              reduce using rule 13 (sentence -> expression .)
    WHILE           reduce using rule 13 (sentence -> expression .)
    FOR             reduce using rule 13 (sentence -> expression .)
    LPAREN          reduce using rule 13 (sentence -> expression .)
    DEF             reduce using rule 13 (sentence -> expression .)
    CLASS           reduce using rule 13 (sentence -> expression .)
    RETURN          reduce using rule 13 (sentence -> expression .)
    BREAK           reduce using rule 13 (sentence -> expression .)
    INTEGER         reduce using rule 13 (sentence -> expression .)
    FLOAT           reduce using rule 13 (sentence -> expression .)
    STRING          reduce using rule 13 (sentence -> expression .)
    BOOLEAN         reduce using rule 13 (sentence -> expression .)
    TRUE            reduce using rule 13 (sentence -> expression .)
    FALSE           reduce using rule 13 (sentence -> expression .)
    NIL             reduce using rule 13 (sentence -> expression .)
    $end            reduce using rule 13 (sentence -> expression .)
    END             reduce using rule 13 (sentence -> expression .)
    ELSE            reduce using rule 13 (sentence -> expression .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44


state 6

    (14) sentence -> print .

    ID              reduce using rule 14 (sentence -> print .)
    VAR_INST        reduce using rule 14 (sentence -> print .)
    PUTS            reduce using rule 14 (sentence -> print .)
    IF              reduce using rule 14 (sentence -> print .)
    WHILE           reduce using rule 14 (sentence -> print .)
    FOR             reduce using rule 14 (sentence -> print .)
    LPAREN          reduce using rule 14 (sentence -> print .)
    DEF             reduce using rule 14 (sentence -> print .)
    CLASS           reduce using rule 14 (sentence -> print .)
    RETURN          reduce using rule 14 (sentence -> print .)
    BREAK           reduce using rule 14 (sentence -> print .)
    INTEGER         reduce using rule 14 (sentence -> print .)
    FLOAT           reduce using rule 14 (sentence -> print .)
    STRING          reduce using rule 14 (sentence -> print .)
    BOOLEAN         reduce using rule 14 (sentence -> print .)
    TRUE            reduce using rule 14 (sentence -> print .)
    FALSE           reduce using rule 14 (sentence -> print .)
    NIL             reduce using rule 14 (sentence -> print .)
    $end            reduce using rule 14 (sentence -> print .)
    END             reduce using rule 14 (sentence -> print .)
    ELSE            reduce using rule 14 (sentence -> print .)


state 7

    (15) sentence -> input .

    ID              reduce using rule 15 (sentence -> input .)
    VAR_INST        reduce using rule 15 (sentence -> input .)
    PUTS            reduce using rule 15 (sentence -> input .)
    IF              reduce using rule 15 (sentence -> input .)
    WHILE           reduce using rule 15 (sentence -> input .)
    FOR             reduce using rule 15 (sentence -> input .)
    LPAREN          reduce using rule 15 (sentence -> input .)
    DEF             reduce using rule 15 (sentence -> input .)
    CLASS           reduce using rule 15 (sentence -> input .)
    RETURN          reduce using rule 15 (sentence -> input .)
    BREAK           reduce using rule 15 (sentence -> input .)
    INTEGER         reduce using rule 15 (sentence -> input .)
    FLOAT           reduce using rule 15 (sentence -> input .)
    STRING          reduce using rule 15 (sentence -> input .)
    BOOLEAN         reduce using rule 15 (sentence -> input .)
    TRUE            reduce using rule 15 (sentence -> input .)
    FALSE           reduce using rule 15 (sentence -> input .)
    NIL             reduce using rule 15 (sentence -> input .)
    $end            reduce using rule 15 (sentence -> input .)
    END             reduce using rule 15 (sentence -> input .)
    ELSE            reduce using rule 15 (sentence -> input .)


state 8

    (16) sentence -> condition .

    ID              reduce using rule 16 (sentence -> condition .)
    VAR_INST        reduce using rule 16 (sentence -> condition .)
    PUTS            reduce using rule 16 (sentence -> condition .)
    IF              reduce using rule 16 (sentence -> condition .)
    WHILE           reduce using rule 16 (sentence -> condition .)
    FOR             reduce using rule 16 (sentence -> condition .)
    LPAREN          reduce using rule 16 (sentence -> condition .)
    DEF             reduce using rule 16 (sentence -> condition .)
    CLASS           reduce using rule 16 (sentence -> condition .)
    RETURN          reduce using rule 16 (sentence -> condition .)
    BREAK           reduce using rule 16 (sentence -> condition .)
    INTEGER         reduce using rule 16 (sentence -> condition .)
    FLOAT           reduce using rule 16 (sentence -> condition .)
    STRING          reduce using rule 16 (sentence -> condition .)
    BOOLEAN         reduce using rule 16 (sentence -> condition .)
    TRUE            reduce using rule 16 (sentence -> condition .)
    FALSE           reduce using rule 16 (sentence -> condition .)
    NIL             reduce using rule 16 (sentence -> condition .)
    $end            reduce using rule 16 (sentence -> condition .)
    END             reduce using rule 16 (sentence -> condition .)
    ELSE            reduce using rule 16 (sentence -> condition .)


state 9

    (17) sentence -> while_loop .

    ID              reduce using rule 17 (sentence -> while_loop .)
    VAR_INST        reduce using rule 17 (sentence -> while_loop .)
    PUTS            reduce using rule 17 (sentence -> while_loop .)
    IF              reduce using rule 17 (sentence -> while_loop .)
    WHILE           reduce using rule 17 (sentence -> while_loop .)
    FOR             reduce using rule 17 (sentence -> while_loop .)
    LPAREN          reduce using rule 17 (sentence -> while_loop .)
    DEF             reduce using rule 17 (sentence -> while_loop .)
    CLASS           reduce using rule 17 (sentence -> while_loop .)
    RETURN          reduce using rule 17 (sentence -> while_loop .)
    BREAK           reduce using rule 17 (sentence -> while_loop .)
    INTEGER         reduce using rule 17 (sentence -> while_loop .)
    FLOAT           reduce using rule 17 (sentence -> while_loop .)
    STRING          reduce using rule 17 (sentence -> while_loop .)
    BOOLEAN         reduce using rule 17 (sentence -> while_loop .)
    TRUE            reduce using rule 17 (sentence -> while_loop .)
    FALSE           reduce using rule 17 (sentence -> while_loop .)
    NIL             reduce using rule 17 (sentence -> while_loop .)
    $end            reduce using rule 17 (sentence -> while_loop .)
    END             reduce using rule 17 (sentence -> while_loop .)
    ELSE            reduce using rule 17 (sentence -> while_loop .)


state 10

    (18) sentence -> for_loop .

    ID              reduce using rule 18 (sentence -> for_loop .)
    VAR_INST        reduce using rule 18 (sentence -> for_loop .)
    PUTS            reduce using rule 18 (sentence -> for_loop .)
    IF              reduce using rule 18 (sentence -> for_loop .)
    WHILE           reduce using rule 18 (sentence -> for_loop .)
    FOR             reduce using rule 18 (sentence -> for_loop .)
    LPAREN          reduce using rule 18 (sentence -> for_loop .)
    DEF             reduce using rule 18 (sentence -> for_loop .)
    CLASS           reduce using rule 18 (sentence -> for_loop .)
    RETURN          reduce using rule 18 (sentence -> for_loop .)
    BREAK           reduce using rule 18 (sentence -> for_loop .)
    INTEGER         reduce using rule 18 (sentence -> for_loop .)
    FLOAT           reduce using rule 18 (sentence -> for_loop .)
    STRING          reduce using rule 18 (sentence -> for_loop .)
    BOOLEAN         reduce using rule 18 (sentence -> for_loop .)
    TRUE            reduce using rule 18 (sentence -> for_loop .)
    FALSE           reduce using rule 18 (sentence -> for_loop .)
    NIL             reduce using rule 18 (sentence -> for_loop .)
    $end            reduce using rule 18 (sentence -> for_loop .)
    END             reduce using rule 18 (sentence -> for_loop .)
    ELSE            reduce using rule 18 (sentence -> for_loop .)


state 11

    (19) sentence -> array .

    ID              reduce using rule 19 (sentence -> array .)
    VAR_INST        reduce using rule 19 (sentence -> array .)
    PUTS            reduce using rule 19 (sentence -> array .)
    IF              reduce using rule 19 (sentence -> array .)
    WHILE           reduce using rule 19 (sentence -> array .)
    FOR             reduce using rule 19 (sentence -> array .)
    LPAREN          reduce using rule 19 (sentence -> array .)
    DEF             reduce using rule 19 (sentence -> array .)
    CLASS           reduce using rule 19 (sentence -> array .)
    RETURN          reduce using rule 19 (sentence -> array .)
    BREAK           reduce using rule 19 (sentence -> array .)
    INTEGER         reduce using rule 19 (sentence -> array .)
    FLOAT           reduce using rule 19 (sentence -> array .)
    STRING          reduce using rule 19 (sentence -> array .)
    BOOLEAN         reduce using rule 19 (sentence -> array .)
    TRUE            reduce using rule 19 (sentence -> array .)
    FALSE           reduce using rule 19 (sentence -> array .)
    NIL             reduce using rule 19 (sentence -> array .)
    $end            reduce using rule 19 (sentence -> array .)
    END             reduce using rule 19 (sentence -> array .)
    ELSE            reduce using rule 19 (sentence -> array .)


state 12

    (20) sentence -> range_incl .

    ID              reduce using rule 20 (sentence -> range_incl .)
    VAR_INST        reduce using rule 20 (sentence -> range_incl .)
    PUTS            reduce using rule 20 (sentence -> range_incl .)
    IF              reduce using rule 20 (sentence -> range_incl .)
    WHILE           reduce using rule 20 (sentence -> range_incl .)
    FOR             reduce using rule 20 (sentence -> range_incl .)
    LPAREN          reduce using rule 20 (sentence -> range_incl .)
    DEF             reduce using rule 20 (sentence -> range_incl .)
    CLASS           reduce using rule 20 (sentence -> range_incl .)
    RETURN          reduce using rule 20 (sentence -> range_incl .)
    BREAK           reduce using rule 20 (sentence -> range_incl .)
    INTEGER         reduce using rule 20 (sentence -> range_incl .)
    FLOAT           reduce using rule 20 (sentence -> range_incl .)
    STRING          reduce using rule 20 (sentence -> range_incl .)
    BOOLEAN         reduce using rule 20 (sentence -> range_incl .)
    TRUE            reduce using rule 20 (sentence -> range_incl .)
    FALSE           reduce using rule 20 (sentence -> range_incl .)
    NIL             reduce using rule 20 (sentence -> range_incl .)
    $end            reduce using rule 20 (sentence -> range_incl .)
    END             reduce using rule 20 (sentence -> range_incl .)
    ELSE            reduce using rule 20 (sentence -> range_incl .)


state 13

    (21) sentence -> range_excl .

    ID              reduce using rule 21 (sentence -> range_excl .)
    VAR_INST        reduce using rule 21 (sentence -> range_excl .)
    PUTS            reduce using rule 21 (sentence -> range_excl .)
    IF              reduce using rule 21 (sentence -> range_excl .)
    WHILE           reduce using rule 21 (sentence -> range_excl .)
    FOR             reduce using rule 21 (sentence -> range_excl .)
    LPAREN          reduce using rule 21 (sentence -> range_excl .)
    DEF             reduce using rule 21 (sentence -> range_excl .)
    CLASS           reduce using rule 21 (sentence -> range_excl .)
    RETURN          reduce using rule 21 (sentence -> range_excl .)
    BREAK           reduce using rule 21 (sentence -> range_excl .)
    INTEGER         reduce using rule 21 (sentence -> range_excl .)
    FLOAT           reduce using rule 21 (sentence -> range_excl .)
    STRING          reduce using rule 21 (sentence -> range_excl .)
    BOOLEAN         reduce using rule 21 (sentence -> range_excl .)
    TRUE            reduce using rule 21 (sentence -> range_excl .)
    FALSE           reduce using rule 21 (sentence -> range_excl .)
    NIL             reduce using rule 21 (sentence -> range_excl .)
    $end            reduce using rule 21 (sentence -> range_excl .)
    END             reduce using rule 21 (sentence -> range_excl .)
    ELSE            reduce using rule 21 (sentence -> range_excl .)


state 14

    (22) sentence -> hash .

    ID              reduce using rule 22 (sentence -> hash .)
    VAR_INST        reduce using rule 22 (sentence -> hash .)
    PUTS            reduce using rule 22 (sentence -> hash .)
    IF              reduce using rule 22 (sentence -> hash .)
    WHILE           reduce using rule 22 (sentence -> hash .)
    FOR             reduce using rule 22 (sentence -> hash .)
    LPAREN          reduce using rule 22 (sentence -> hash .)
    DEF             reduce using rule 22 (sentence -> hash .)
    CLASS           reduce using rule 22 (sentence -> hash .)
    RETURN          reduce using rule 22 (sentence -> hash .)
    BREAK           reduce using rule 22 (sentence -> hash .)
    INTEGER         reduce using rule 22 (sentence -> hash .)
    FLOAT           reduce using rule 22 (sentence -> hash .)
    STRING          reduce using rule 22 (sentence -> hash .)
    BOOLEAN         reduce using rule 22 (sentence -> hash .)
    TRUE            reduce using rule 22 (sentence -> hash .)
    FALSE           reduce using rule 22 (sentence -> hash .)
    NIL             reduce using rule 22 (sentence -> hash .)
    $end            reduce using rule 22 (sentence -> hash .)
    END             reduce using rule 22 (sentence -> hash .)
    ELSE            reduce using rule 22 (sentence -> hash .)


state 15

    (23) sentence -> function .

    ID              reduce using rule 23 (sentence -> function .)
    VAR_INST        reduce using rule 23 (sentence -> function .)
    PUTS            reduce using rule 23 (sentence -> function .)
    IF              reduce using rule 23 (sentence -> function .)
    WHILE           reduce using rule 23 (sentence -> function .)
    FOR             reduce using rule 23 (sentence -> function .)
    LPAREN          reduce using rule 23 (sentence -> function .)
    DEF             reduce using rule 23 (sentence -> function .)
    CLASS           reduce using rule 23 (sentence -> function .)
    RETURN          reduce using rule 23 (sentence -> function .)
    BREAK           reduce using rule 23 (sentence -> function .)
    INTEGER         reduce using rule 23 (sentence -> function .)
    FLOAT           reduce using rule 23 (sentence -> function .)
    STRING          reduce using rule 23 (sentence -> function .)
    BOOLEAN         reduce using rule 23 (sentence -> function .)
    TRUE            reduce using rule 23 (sentence -> function .)
    FALSE           reduce using rule 23 (sentence -> function .)
    NIL             reduce using rule 23 (sentence -> function .)
    $end            reduce using rule 23 (sentence -> function .)
    END             reduce using rule 23 (sentence -> function .)
    ELSE            reduce using rule 23 (sentence -> function .)


state 16

    (24) sentence -> class_def .

    ID              reduce using rule 24 (sentence -> class_def .)
    VAR_INST        reduce using rule 24 (sentence -> class_def .)
    PUTS            reduce using rule 24 (sentence -> class_def .)
    IF              reduce using rule 24 (sentence -> class_def .)
    WHILE           reduce using rule 24 (sentence -> class_def .)
    FOR             reduce using rule 24 (sentence -> class_def .)
    LPAREN          reduce using rule 24 (sentence -> class_def .)
    DEF             reduce using rule 24 (sentence -> class_def .)
    CLASS           reduce using rule 24 (sentence -> class_def .)
    RETURN          reduce using rule 24 (sentence -> class_def .)
    BREAK           reduce using rule 24 (sentence -> class_def .)
    INTEGER         reduce using rule 24 (sentence -> class_def .)
    FLOAT           reduce using rule 24 (sentence -> class_def .)
    STRING          reduce using rule 24 (sentence -> class_def .)
    BOOLEAN         reduce using rule 24 (sentence -> class_def .)
    TRUE            reduce using rule 24 (sentence -> class_def .)
    FALSE           reduce using rule 24 (sentence -> class_def .)
    NIL             reduce using rule 24 (sentence -> class_def .)
    $end            reduce using rule 24 (sentence -> class_def .)
    END             reduce using rule 24 (sentence -> class_def .)
    ELSE            reduce using rule 24 (sentence -> class_def .)


state 17

    (25) sentence -> return_stmt .

    ID              reduce using rule 25 (sentence -> return_stmt .)
    VAR_INST        reduce using rule 25 (sentence -> return_stmt .)
    PUTS            reduce using rule 25 (sentence -> return_stmt .)
    IF              reduce using rule 25 (sentence -> return_stmt .)
    WHILE           reduce using rule 25 (sentence -> return_stmt .)
    FOR             reduce using rule 25 (sentence -> return_stmt .)
    LPAREN          reduce using rule 25 (sentence -> return_stmt .)
    DEF             reduce using rule 25 (sentence -> return_stmt .)
    CLASS           reduce using rule 25 (sentence -> return_stmt .)
    RETURN          reduce using rule 25 (sentence -> return_stmt .)
    BREAK           reduce using rule 25 (sentence -> return_stmt .)
    INTEGER         reduce using rule 25 (sentence -> return_stmt .)
    FLOAT           reduce using rule 25 (sentence -> return_stmt .)
    STRING          reduce using rule 25 (sentence -> return_stmt .)
    BOOLEAN         reduce using rule 25 (sentence -> return_stmt .)
    TRUE            reduce using rule 25 (sentence -> return_stmt .)
    FALSE           reduce using rule 25 (sentence -> return_stmt .)
    NIL             reduce using rule 25 (sentence -> return_stmt .)
    $end            reduce using rule 25 (sentence -> return_stmt .)
    END             reduce using rule 25 (sentence -> return_stmt .)
    ELSE            reduce using rule 25 (sentence -> return_stmt .)


state 18

    (26) sentence -> break_stmt .

    ID              reduce using rule 26 (sentence -> break_stmt .)
    VAR_INST        reduce using rule 26 (sentence -> break_stmt .)
    PUTS            reduce using rule 26 (sentence -> break_stmt .)
    IF              reduce using rule 26 (sentence -> break_stmt .)
    WHILE           reduce using rule 26 (sentence -> break_stmt .)
    FOR             reduce using rule 26 (sentence -> break_stmt .)
    LPAREN          reduce using rule 26 (sentence -> break_stmt .)
    DEF             reduce using rule 26 (sentence -> break_stmt .)
    CLASS           reduce using rule 26 (sentence -> break_stmt .)
    RETURN          reduce using rule 26 (sentence -> break_stmt .)
    BREAK           reduce using rule 26 (sentence -> break_stmt .)
    INTEGER         reduce using rule 26 (sentence -> break_stmt .)
    FLOAT           reduce using rule 26 (sentence -> break_stmt .)
    STRING          reduce using rule 26 (sentence -> break_stmt .)
    BOOLEAN         reduce using rule 26 (sentence -> break_stmt .)
    TRUE            reduce using rule 26 (sentence -> break_stmt .)
    FALSE           reduce using rule 26 (sentence -> break_stmt .)
    NIL             reduce using rule 26 (sentence -> break_stmt .)
    $end            reduce using rule 26 (sentence -> break_stmt .)
    END             reduce using rule 26 (sentence -> break_stmt .)
    ELSE            reduce using rule 26 (sentence -> break_stmt .)


state 19

    (27) sentence -> function_call_empty .

    ID              reduce using rule 27 (sentence -> function_call_empty .)
    VAR_INST        reduce using rule 27 (sentence -> function_call_empty .)
    PUTS            reduce using rule 27 (sentence -> function_call_empty .)
    IF              reduce using rule 27 (sentence -> function_call_empty .)
    WHILE           reduce using rule 27 (sentence -> function_call_empty .)
    FOR             reduce using rule 27 (sentence -> function_call_empty .)
    LPAREN          reduce using rule 27 (sentence -> function_call_empty .)
    DEF             reduce using rule 27 (sentence -> function_call_empty .)
    CLASS           reduce using rule 27 (sentence -> function_call_empty .)
    RETURN          reduce using rule 27 (sentence -> function_call_empty .)
    BREAK           reduce using rule 27 (sentence -> function_call_empty .)
    INTEGER         reduce using rule 27 (sentence -> function_call_empty .)
    FLOAT           reduce using rule 27 (sentence -> function_call_empty .)
    STRING          reduce using rule 27 (sentence -> function_call_empty .)
    BOOLEAN         reduce using rule 27 (sentence -> function_call_empty .)
    TRUE            reduce using rule 27 (sentence -> function_call_empty .)
    FALSE           reduce using rule 27 (sentence -> function_call_empty .)
    NIL             reduce using rule 27 (sentence -> function_call_empty .)
    $end            reduce using rule 27 (sentence -> function_call_empty .)
    END             reduce using rule 27 (sentence -> function_call_empty .)
    ELSE            reduce using rule 27 (sentence -> function_call_empty .)


state 20

    (28) sentence -> function_call_args .

    ID              reduce using rule 28 (sentence -> function_call_args .)
    VAR_INST        reduce using rule 28 (sentence -> function_call_args .)
    PUTS            reduce using rule 28 (sentence -> function_call_args .)
    IF              reduce using rule 28 (sentence -> function_call_args .)
    WHILE           reduce using rule 28 (sentence -> function_call_args .)
    FOR             reduce using rule 28 (sentence -> function_call_args .)
    LPAREN          reduce using rule 28 (sentence -> function_call_args .)
    DEF             reduce using rule 28 (sentence -> function_call_args .)
    CLASS           reduce using rule 28 (sentence -> function_call_args .)
    RETURN          reduce using rule 28 (sentence -> function_call_args .)
    BREAK           reduce using rule 28 (sentence -> function_call_args .)
    INTEGER         reduce using rule 28 (sentence -> function_call_args .)
    FLOAT           reduce using rule 28 (sentence -> function_call_args .)
    STRING          reduce using rule 28 (sentence -> function_call_args .)
    BOOLEAN         reduce using rule 28 (sentence -> function_call_args .)
    TRUE            reduce using rule 28 (sentence -> function_call_args .)
    FALSE           reduce using rule 28 (sentence -> function_call_args .)
    NIL             reduce using rule 28 (sentence -> function_call_args .)
    $end            reduce using rule 28 (sentence -> function_call_args .)
    END             reduce using rule 28 (sentence -> function_call_args .)
    ELSE            reduce using rule 28 (sentence -> function_call_args .)


state 21

    (31) assignment -> ID . ASSIGN expression
    (34) input -> ID . ASSIGN GETS DOT ID
    (56) array -> ID . ASSIGN LCORCH elements RCORCH
    (60) hash -> ID . ASSIGN LBRACE hash_pairs RBRACE
    (54) function_call_empty -> ID . LPAREN RPAREN
    (55) function_call_args -> ID . LPAREN args RPAREN
    (47) factor -> ID .

  ! shift/reduce conflict for LPAREN resolved as shift
    ASSIGN          shift and go to state 45
    LPAREN          shift and go to state 46
    EQUALS          reduce using rule 47 (factor -> ID .)
    NEQUALS         reduce using rule 47 (factor -> ID .)
    GREATEREQ       reduce using rule 47 (factor -> ID .)
    LESSEQ          reduce using rule 47 (factor -> ID .)
    GREATERT        reduce using rule 47 (factor -> ID .)
    LESST           reduce using rule 47 (factor -> ID .)
    TIMES           reduce using rule 47 (factor -> ID .)
    DIVIDE          reduce using rule 47 (factor -> ID .)
    EXPONENT        reduce using rule 47 (factor -> ID .)
    MODULE          reduce using rule 47 (factor -> ID .)
    PLUS            reduce using rule 47 (factor -> ID .)
    MINUS           reduce using rule 47 (factor -> ID .)
    ID              reduce using rule 47 (factor -> ID .)
    VAR_INST        reduce using rule 47 (factor -> ID .)
    PUTS            reduce using rule 47 (factor -> ID .)
    IF              reduce using rule 47 (factor -> ID .)
    WHILE           reduce using rule 47 (factor -> ID .)
    FOR             reduce using rule 47 (factor -> ID .)
    DEF             reduce using rule 47 (factor -> ID .)
    CLASS           reduce using rule 47 (factor -> ID .)
    RETURN          reduce using rule 47 (factor -> ID .)
    BREAK           reduce using rule 47 (factor -> ID .)
    INTEGER         reduce using rule 47 (factor -> ID .)
    FLOAT           reduce using rule 47 (factor -> ID .)
    STRING          reduce using rule 47 (factor -> ID .)
    BOOLEAN         reduce using rule 47 (factor -> ID .)
    TRUE            reduce using rule 47 (factor -> ID .)
    FALSE           reduce using rule 47 (factor -> ID .)
    NIL             reduce using rule 47 (factor -> ID .)
    $end            reduce using rule 47 (factor -> ID .)
    END             reduce using rule 47 (factor -> ID .)
    ELSE            reduce using rule 47 (factor -> ID .)

  ! LPAREN          [ reduce using rule 47 (factor -> ID .) ]


state 22

    (32) assignment -> VAR_INST . ASSIGN expression
    (48) factor -> VAR_INST .

    ASSIGN          shift and go to state 47
    EQUALS          reduce using rule 48 (factor -> VAR_INST .)
    NEQUALS         reduce using rule 48 (factor -> VAR_INST .)
    GREATEREQ       reduce using rule 48 (factor -> VAR_INST .)
    LESSEQ          reduce using rule 48 (factor -> VAR_INST .)
    GREATERT        reduce using rule 48 (factor -> VAR_INST .)
    LESST           reduce using rule 48 (factor -> VAR_INST .)
    TIMES           reduce using rule 48 (factor -> VAR_INST .)
    DIVIDE          reduce using rule 48 (factor -> VAR_INST .)
    EXPONENT        reduce using rule 48 (factor -> VAR_INST .)
    MODULE          reduce using rule 48 (factor -> VAR_INST .)
    PLUS            reduce using rule 48 (factor -> VAR_INST .)
    MINUS           reduce using rule 48 (factor -> VAR_INST .)
    ID              reduce using rule 48 (factor -> VAR_INST .)
    VAR_INST        reduce using rule 48 (factor -> VAR_INST .)
    PUTS            reduce using rule 48 (factor -> VAR_INST .)
    IF              reduce using rule 48 (factor -> VAR_INST .)
    WHILE           reduce using rule 48 (factor -> VAR_INST .)
    FOR             reduce using rule 48 (factor -> VAR_INST .)
    LPAREN          reduce using rule 48 (factor -> VAR_INST .)
    DEF             reduce using rule 48 (factor -> VAR_INST .)
    CLASS           reduce using rule 48 (factor -> VAR_INST .)
    RETURN          reduce using rule 48 (factor -> VAR_INST .)
    BREAK           reduce using rule 48 (factor -> VAR_INST .)
    INTEGER         reduce using rule 48 (factor -> VAR_INST .)
    FLOAT           reduce using rule 48 (factor -> VAR_INST .)
    STRING          reduce using rule 48 (factor -> VAR_INST .)
    BOOLEAN         reduce using rule 48 (factor -> VAR_INST .)
    TRUE            reduce using rule 48 (factor -> VAR_INST .)
    FALSE           reduce using rule 48 (factor -> VAR_INST .)
    NIL             reduce using rule 48 (factor -> VAR_INST .)
    $end            reduce using rule 48 (factor -> VAR_INST .)
    END             reduce using rule 48 (factor -> VAR_INST .)
    ELSE            reduce using rule 48 (factor -> VAR_INST .)


state 23

    (37) expression -> term .
    (38) term -> term . TIMES factor
    (39) term -> term . DIVIDE factor
    (40) term -> term . EXPONENT factor
    (41) term -> term . MODULE factor

    PLUS            reduce using rule 37 (expression -> term .)
    MINUS           reduce using rule 37 (expression -> term .)
    ID              reduce using rule 37 (expression -> term .)
    VAR_INST        reduce using rule 37 (expression -> term .)
    PUTS            reduce using rule 37 (expression -> term .)
    IF              reduce using rule 37 (expression -> term .)
    WHILE           reduce using rule 37 (expression -> term .)
    FOR             reduce using rule 37 (expression -> term .)
    LPAREN          reduce using rule 37 (expression -> term .)
    DEF             reduce using rule 37 (expression -> term .)
    CLASS           reduce using rule 37 (expression -> term .)
    RETURN          reduce using rule 37 (expression -> term .)
    BREAK           reduce using rule 37 (expression -> term .)
    INTEGER         reduce using rule 37 (expression -> term .)
    FLOAT           reduce using rule 37 (expression -> term .)
    STRING          reduce using rule 37 (expression -> term .)
    BOOLEAN         reduce using rule 37 (expression -> term .)
    TRUE            reduce using rule 37 (expression -> term .)
    FALSE           reduce using rule 37 (expression -> term .)
    NIL             reduce using rule 37 (expression -> term .)
    $end            reduce using rule 37 (expression -> term .)
    RPAREN          reduce using rule 37 (expression -> term .)
    END             reduce using rule 37 (expression -> term .)
    ELSE            reduce using rule 37 (expression -> term .)
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    EXPONENT        shift and go to state 50
    MODULE          shift and go to state 51


state 24

    (10) print -> PUTS . factor
    (33) input -> PUTS . STRING
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    STRING          shift and go to state 53
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    factor                         shift and go to state 52
    logic_expression               shift and go to state 28

state 25

    (42) term -> factor .
    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

    TIMES           reduce using rule 42 (term -> factor .)
    DIVIDE          reduce using rule 42 (term -> factor .)
    EXPONENT        reduce using rule 42 (term -> factor .)
    MODULE          reduce using rule 42 (term -> factor .)
    PLUS            reduce using rule 42 (term -> factor .)
    MINUS           reduce using rule 42 (term -> factor .)
    ID              reduce using rule 42 (term -> factor .)
    VAR_INST        reduce using rule 42 (term -> factor .)
    PUTS            reduce using rule 42 (term -> factor .)
    IF              reduce using rule 42 (term -> factor .)
    WHILE           reduce using rule 42 (term -> factor .)
    FOR             reduce using rule 42 (term -> factor .)
    LPAREN          reduce using rule 42 (term -> factor .)
    DEF             reduce using rule 42 (term -> factor .)
    CLASS           reduce using rule 42 (term -> factor .)
    RETURN          reduce using rule 42 (term -> factor .)
    BREAK           reduce using rule 42 (term -> factor .)
    INTEGER         reduce using rule 42 (term -> factor .)
    FLOAT           reduce using rule 42 (term -> factor .)
    STRING          reduce using rule 42 (term -> factor .)
    BOOLEAN         reduce using rule 42 (term -> factor .)
    TRUE            reduce using rule 42 (term -> factor .)
    FALSE           reduce using rule 42 (term -> factor .)
    NIL             reduce using rule 42 (term -> factor .)
    $end            reduce using rule 42 (term -> factor .)
    RPAREN          reduce using rule 42 (term -> factor .)
    END             reduce using rule 42 (term -> factor .)
    ELSE            reduce using rule 42 (term -> factor .)
    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

    logic_op                       shift and go to state 57

state 26

    (45) factor -> STRING .

    EQUALS          reduce using rule 45 (factor -> STRING .)
    NEQUALS         reduce using rule 45 (factor -> STRING .)
    GREATEREQ       reduce using rule 45 (factor -> STRING .)
    LESSEQ          reduce using rule 45 (factor -> STRING .)
    GREATERT        reduce using rule 45 (factor -> STRING .)
    LESST           reduce using rule 45 (factor -> STRING .)
    TIMES           reduce using rule 45 (factor -> STRING .)
    DIVIDE          reduce using rule 45 (factor -> STRING .)
    EXPONENT        reduce using rule 45 (factor -> STRING .)
    MODULE          reduce using rule 45 (factor -> STRING .)
    PLUS            reduce using rule 45 (factor -> STRING .)
    MINUS           reduce using rule 45 (factor -> STRING .)
    ID              reduce using rule 45 (factor -> STRING .)
    VAR_INST        reduce using rule 45 (factor -> STRING .)
    PUTS            reduce using rule 45 (factor -> STRING .)
    IF              reduce using rule 45 (factor -> STRING .)
    WHILE           reduce using rule 45 (factor -> STRING .)
    FOR             reduce using rule 45 (factor -> STRING .)
    LPAREN          reduce using rule 45 (factor -> STRING .)
    DEF             reduce using rule 45 (factor -> STRING .)
    CLASS           reduce using rule 45 (factor -> STRING .)
    RETURN          reduce using rule 45 (factor -> STRING .)
    BREAK           reduce using rule 45 (factor -> STRING .)
    INTEGER         reduce using rule 45 (factor -> STRING .)
    FLOAT           reduce using rule 45 (factor -> STRING .)
    STRING          reduce using rule 45 (factor -> STRING .)
    BOOLEAN         reduce using rule 45 (factor -> STRING .)
    TRUE            reduce using rule 45 (factor -> STRING .)
    FALSE           reduce using rule 45 (factor -> STRING .)
    NIL             reduce using rule 45 (factor -> STRING .)
    $end            reduce using rule 45 (factor -> STRING .)
    RPAREN          reduce using rule 45 (factor -> STRING .)
    END             reduce using rule 45 (factor -> STRING .)
    ELSE            reduce using rule 45 (factor -> STRING .)
    AND             reduce using rule 45 (factor -> STRING .)
    OR              reduce using rule 45 (factor -> STRING .)
    COMMA           reduce using rule 45 (factor -> STRING .)
    RCORCH          reduce using rule 45 (factor -> STRING .)
    RBRACE          reduce using rule 45 (factor -> STRING .)


state 27

    (66) condition -> IF . logic_expression body END
    (67) condition -> IF . logic_expression body ELSE body END
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    logic_expression               shift and go to state 64
    factor                         shift and go to state 65

state 28

    (53) factor -> logic_expression .

    EQUALS          reduce using rule 53 (factor -> logic_expression .)
    NEQUALS         reduce using rule 53 (factor -> logic_expression .)
    GREATEREQ       reduce using rule 53 (factor -> logic_expression .)
    LESSEQ          reduce using rule 53 (factor -> logic_expression .)
    GREATERT        reduce using rule 53 (factor -> logic_expression .)
    LESST           reduce using rule 53 (factor -> logic_expression .)
    TIMES           reduce using rule 53 (factor -> logic_expression .)
    DIVIDE          reduce using rule 53 (factor -> logic_expression .)
    EXPONENT        reduce using rule 53 (factor -> logic_expression .)
    MODULE          reduce using rule 53 (factor -> logic_expression .)
    PLUS            reduce using rule 53 (factor -> logic_expression .)
    MINUS           reduce using rule 53 (factor -> logic_expression .)
    ID              reduce using rule 53 (factor -> logic_expression .)
    VAR_INST        reduce using rule 53 (factor -> logic_expression .)
    PUTS            reduce using rule 53 (factor -> logic_expression .)
    IF              reduce using rule 53 (factor -> logic_expression .)
    WHILE           reduce using rule 53 (factor -> logic_expression .)
    FOR             reduce using rule 53 (factor -> logic_expression .)
    LPAREN          reduce using rule 53 (factor -> logic_expression .)
    DEF             reduce using rule 53 (factor -> logic_expression .)
    CLASS           reduce using rule 53 (factor -> logic_expression .)
    RETURN          reduce using rule 53 (factor -> logic_expression .)
    BREAK           reduce using rule 53 (factor -> logic_expression .)
    INTEGER         reduce using rule 53 (factor -> logic_expression .)
    FLOAT           reduce using rule 53 (factor -> logic_expression .)
    STRING          reduce using rule 53 (factor -> logic_expression .)
    BOOLEAN         reduce using rule 53 (factor -> logic_expression .)
    TRUE            reduce using rule 53 (factor -> logic_expression .)
    FALSE           reduce using rule 53 (factor -> logic_expression .)
    NIL             reduce using rule 53 (factor -> logic_expression .)
    $end            reduce using rule 53 (factor -> logic_expression .)
    END             reduce using rule 53 (factor -> logic_expression .)
    ELSE            reduce using rule 53 (factor -> logic_expression .)
    RPAREN          reduce using rule 53 (factor -> logic_expression .)
    AND             reduce using rule 53 (factor -> logic_expression .)
    OR              reduce using rule 53 (factor -> logic_expression .)
    COMMA           reduce using rule 53 (factor -> logic_expression .)
    RCORCH          reduce using rule 53 (factor -> logic_expression .)
    RBRACE          reduce using rule 53 (factor -> logic_expression .)


state 29

    (63) while_loop -> WHILE . logic_expression body END
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    logic_expression               shift and go to state 66
    factor                         shift and go to state 65

state 30

    (59) for_loop -> FOR . ID IN range_incl body END

    ID              shift and go to state 67


state 31

    (64) range_incl -> LPAREN . INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> LPAREN . INTEGER RANGE_EXCL INTEGER RPAREN
    (52) factor -> LPAREN . expression RPAREN
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 68
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    expression                     shift and go to state 69
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 32

    (43) factor -> INTEGER .

    EQUALS          reduce using rule 43 (factor -> INTEGER .)
    NEQUALS         reduce using rule 43 (factor -> INTEGER .)
    GREATEREQ       reduce using rule 43 (factor -> INTEGER .)
    LESSEQ          reduce using rule 43 (factor -> INTEGER .)
    GREATERT        reduce using rule 43 (factor -> INTEGER .)
    LESST           reduce using rule 43 (factor -> INTEGER .)
    TIMES           reduce using rule 43 (factor -> INTEGER .)
    DIVIDE          reduce using rule 43 (factor -> INTEGER .)
    EXPONENT        reduce using rule 43 (factor -> INTEGER .)
    MODULE          reduce using rule 43 (factor -> INTEGER .)
    PLUS            reduce using rule 43 (factor -> INTEGER .)
    MINUS           reduce using rule 43 (factor -> INTEGER .)
    ID              reduce using rule 43 (factor -> INTEGER .)
    VAR_INST        reduce using rule 43 (factor -> INTEGER .)
    PUTS            reduce using rule 43 (factor -> INTEGER .)
    IF              reduce using rule 43 (factor -> INTEGER .)
    WHILE           reduce using rule 43 (factor -> INTEGER .)
    FOR             reduce using rule 43 (factor -> INTEGER .)
    LPAREN          reduce using rule 43 (factor -> INTEGER .)
    DEF             reduce using rule 43 (factor -> INTEGER .)
    CLASS           reduce using rule 43 (factor -> INTEGER .)
    RETURN          reduce using rule 43 (factor -> INTEGER .)
    BREAK           reduce using rule 43 (factor -> INTEGER .)
    INTEGER         reduce using rule 43 (factor -> INTEGER .)
    FLOAT           reduce using rule 43 (factor -> INTEGER .)
    STRING          reduce using rule 43 (factor -> INTEGER .)
    BOOLEAN         reduce using rule 43 (factor -> INTEGER .)
    TRUE            reduce using rule 43 (factor -> INTEGER .)
    FALSE           reduce using rule 43 (factor -> INTEGER .)
    NIL             reduce using rule 43 (factor -> INTEGER .)
    $end            reduce using rule 43 (factor -> INTEGER .)
    END             reduce using rule 43 (factor -> INTEGER .)
    ELSE            reduce using rule 43 (factor -> INTEGER .)
    RPAREN          reduce using rule 43 (factor -> INTEGER .)
    AND             reduce using rule 43 (factor -> INTEGER .)
    OR              reduce using rule 43 (factor -> INTEGER .)
    COMMA           reduce using rule 43 (factor -> INTEGER .)
    RCORCH          reduce using rule 43 (factor -> INTEGER .)
    RBRACE          reduce using rule 43 (factor -> INTEGER .)


state 33

    (4) function -> DEF . ID body END
    (5) function -> DEF . ID LPAREN args RPAREN body END

    ID              shift and go to state 70


state 34

    (11) class_def -> CLASS . ID body END

    ID              shift and go to state 71


state 35

    (29) return_stmt -> RETURN . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    factor                         shift and go to state 72
    logic_expression               shift and go to state 28

state 36

    (30) break_stmt -> BREAK .

    ID              reduce using rule 30 (break_stmt -> BREAK .)
    VAR_INST        reduce using rule 30 (break_stmt -> BREAK .)
    PUTS            reduce using rule 30 (break_stmt -> BREAK .)
    IF              reduce using rule 30 (break_stmt -> BREAK .)
    WHILE           reduce using rule 30 (break_stmt -> BREAK .)
    FOR             reduce using rule 30 (break_stmt -> BREAK .)
    LPAREN          reduce using rule 30 (break_stmt -> BREAK .)
    DEF             reduce using rule 30 (break_stmt -> BREAK .)
    CLASS           reduce using rule 30 (break_stmt -> BREAK .)
    RETURN          reduce using rule 30 (break_stmt -> BREAK .)
    BREAK           reduce using rule 30 (break_stmt -> BREAK .)
    INTEGER         reduce using rule 30 (break_stmt -> BREAK .)
    FLOAT           reduce using rule 30 (break_stmt -> BREAK .)
    STRING          reduce using rule 30 (break_stmt -> BREAK .)
    BOOLEAN         reduce using rule 30 (break_stmt -> BREAK .)
    TRUE            reduce using rule 30 (break_stmt -> BREAK .)
    FALSE           reduce using rule 30 (break_stmt -> BREAK .)
    NIL             reduce using rule 30 (break_stmt -> BREAK .)
    $end            reduce using rule 30 (break_stmt -> BREAK .)
    END             reduce using rule 30 (break_stmt -> BREAK .)
    ELSE            reduce using rule 30 (break_stmt -> BREAK .)


state 37

    (44) factor -> FLOAT .

    EQUALS          reduce using rule 44 (factor -> FLOAT .)
    NEQUALS         reduce using rule 44 (factor -> FLOAT .)
    GREATEREQ       reduce using rule 44 (factor -> FLOAT .)
    LESSEQ          reduce using rule 44 (factor -> FLOAT .)
    GREATERT        reduce using rule 44 (factor -> FLOAT .)
    LESST           reduce using rule 44 (factor -> FLOAT .)
    TIMES           reduce using rule 44 (factor -> FLOAT .)
    DIVIDE          reduce using rule 44 (factor -> FLOAT .)
    EXPONENT        reduce using rule 44 (factor -> FLOAT .)
    MODULE          reduce using rule 44 (factor -> FLOAT .)
    PLUS            reduce using rule 44 (factor -> FLOAT .)
    MINUS           reduce using rule 44 (factor -> FLOAT .)
    ID              reduce using rule 44 (factor -> FLOAT .)
    VAR_INST        reduce using rule 44 (factor -> FLOAT .)
    PUTS            reduce using rule 44 (factor -> FLOAT .)
    IF              reduce using rule 44 (factor -> FLOAT .)
    WHILE           reduce using rule 44 (factor -> FLOAT .)
    FOR             reduce using rule 44 (factor -> FLOAT .)
    LPAREN          reduce using rule 44 (factor -> FLOAT .)
    DEF             reduce using rule 44 (factor -> FLOAT .)
    CLASS           reduce using rule 44 (factor -> FLOAT .)
    RETURN          reduce using rule 44 (factor -> FLOAT .)
    BREAK           reduce using rule 44 (factor -> FLOAT .)
    INTEGER         reduce using rule 44 (factor -> FLOAT .)
    FLOAT           reduce using rule 44 (factor -> FLOAT .)
    STRING          reduce using rule 44 (factor -> FLOAT .)
    BOOLEAN         reduce using rule 44 (factor -> FLOAT .)
    TRUE            reduce using rule 44 (factor -> FLOAT .)
    FALSE           reduce using rule 44 (factor -> FLOAT .)
    NIL             reduce using rule 44 (factor -> FLOAT .)
    $end            reduce using rule 44 (factor -> FLOAT .)
    END             reduce using rule 44 (factor -> FLOAT .)
    ELSE            reduce using rule 44 (factor -> FLOAT .)
    RPAREN          reduce using rule 44 (factor -> FLOAT .)
    AND             reduce using rule 44 (factor -> FLOAT .)
    OR              reduce using rule 44 (factor -> FLOAT .)
    COMMA           reduce using rule 44 (factor -> FLOAT .)
    RCORCH          reduce using rule 44 (factor -> FLOAT .)
    RBRACE          reduce using rule 44 (factor -> FLOAT .)


state 38

    (46) factor -> BOOLEAN .

    EQUALS          reduce using rule 46 (factor -> BOOLEAN .)
    NEQUALS         reduce using rule 46 (factor -> BOOLEAN .)
    GREATEREQ       reduce using rule 46 (factor -> BOOLEAN .)
    LESSEQ          reduce using rule 46 (factor -> BOOLEAN .)
    GREATERT        reduce using rule 46 (factor -> BOOLEAN .)
    LESST           reduce using rule 46 (factor -> BOOLEAN .)
    TIMES           reduce using rule 46 (factor -> BOOLEAN .)
    DIVIDE          reduce using rule 46 (factor -> BOOLEAN .)
    EXPONENT        reduce using rule 46 (factor -> BOOLEAN .)
    MODULE          reduce using rule 46 (factor -> BOOLEAN .)
    PLUS            reduce using rule 46 (factor -> BOOLEAN .)
    MINUS           reduce using rule 46 (factor -> BOOLEAN .)
    ID              reduce using rule 46 (factor -> BOOLEAN .)
    VAR_INST        reduce using rule 46 (factor -> BOOLEAN .)
    PUTS            reduce using rule 46 (factor -> BOOLEAN .)
    IF              reduce using rule 46 (factor -> BOOLEAN .)
    WHILE           reduce using rule 46 (factor -> BOOLEAN .)
    FOR             reduce using rule 46 (factor -> BOOLEAN .)
    LPAREN          reduce using rule 46 (factor -> BOOLEAN .)
    DEF             reduce using rule 46 (factor -> BOOLEAN .)
    CLASS           reduce using rule 46 (factor -> BOOLEAN .)
    RETURN          reduce using rule 46 (factor -> BOOLEAN .)
    BREAK           reduce using rule 46 (factor -> BOOLEAN .)
    INTEGER         reduce using rule 46 (factor -> BOOLEAN .)
    FLOAT           reduce using rule 46 (factor -> BOOLEAN .)
    STRING          reduce using rule 46 (factor -> BOOLEAN .)
    BOOLEAN         reduce using rule 46 (factor -> BOOLEAN .)
    TRUE            reduce using rule 46 (factor -> BOOLEAN .)
    FALSE           reduce using rule 46 (factor -> BOOLEAN .)
    NIL             reduce using rule 46 (factor -> BOOLEAN .)
    $end            reduce using rule 46 (factor -> BOOLEAN .)
    END             reduce using rule 46 (factor -> BOOLEAN .)
    ELSE            reduce using rule 46 (factor -> BOOLEAN .)
    RPAREN          reduce using rule 46 (factor -> BOOLEAN .)
    AND             reduce using rule 46 (factor -> BOOLEAN .)
    OR              reduce using rule 46 (factor -> BOOLEAN .)
    COMMA           reduce using rule 46 (factor -> BOOLEAN .)
    RCORCH          reduce using rule 46 (factor -> BOOLEAN .)
    RBRACE          reduce using rule 46 (factor -> BOOLEAN .)


state 39

    (49) factor -> TRUE .

    EQUALS          reduce using rule 49 (factor -> TRUE .)
    NEQUALS         reduce using rule 49 (factor -> TRUE .)
    GREATEREQ       reduce using rule 49 (factor -> TRUE .)
    LESSEQ          reduce using rule 49 (factor -> TRUE .)
    GREATERT        reduce using rule 49 (factor -> TRUE .)
    LESST           reduce using rule 49 (factor -> TRUE .)
    TIMES           reduce using rule 49 (factor -> TRUE .)
    DIVIDE          reduce using rule 49 (factor -> TRUE .)
    EXPONENT        reduce using rule 49 (factor -> TRUE .)
    MODULE          reduce using rule 49 (factor -> TRUE .)
    PLUS            reduce using rule 49 (factor -> TRUE .)
    MINUS           reduce using rule 49 (factor -> TRUE .)
    ID              reduce using rule 49 (factor -> TRUE .)
    VAR_INST        reduce using rule 49 (factor -> TRUE .)
    PUTS            reduce using rule 49 (factor -> TRUE .)
    IF              reduce using rule 49 (factor -> TRUE .)
    WHILE           reduce using rule 49 (factor -> TRUE .)
    FOR             reduce using rule 49 (factor -> TRUE .)
    LPAREN          reduce using rule 49 (factor -> TRUE .)
    DEF             reduce using rule 49 (factor -> TRUE .)
    CLASS           reduce using rule 49 (factor -> TRUE .)
    RETURN          reduce using rule 49 (factor -> TRUE .)
    BREAK           reduce using rule 49 (factor -> TRUE .)
    INTEGER         reduce using rule 49 (factor -> TRUE .)
    FLOAT           reduce using rule 49 (factor -> TRUE .)
    STRING          reduce using rule 49 (factor -> TRUE .)
    BOOLEAN         reduce using rule 49 (factor -> TRUE .)
    TRUE            reduce using rule 49 (factor -> TRUE .)
    FALSE           reduce using rule 49 (factor -> TRUE .)
    NIL             reduce using rule 49 (factor -> TRUE .)
    $end            reduce using rule 49 (factor -> TRUE .)
    END             reduce using rule 49 (factor -> TRUE .)
    ELSE            reduce using rule 49 (factor -> TRUE .)
    RPAREN          reduce using rule 49 (factor -> TRUE .)
    AND             reduce using rule 49 (factor -> TRUE .)
    OR              reduce using rule 49 (factor -> TRUE .)
    COMMA           reduce using rule 49 (factor -> TRUE .)
    RCORCH          reduce using rule 49 (factor -> TRUE .)
    RBRACE          reduce using rule 49 (factor -> TRUE .)


state 40

    (50) factor -> FALSE .

    EQUALS          reduce using rule 50 (factor -> FALSE .)
    NEQUALS         reduce using rule 50 (factor -> FALSE .)
    GREATEREQ       reduce using rule 50 (factor -> FALSE .)
    LESSEQ          reduce using rule 50 (factor -> FALSE .)
    GREATERT        reduce using rule 50 (factor -> FALSE .)
    LESST           reduce using rule 50 (factor -> FALSE .)
    TIMES           reduce using rule 50 (factor -> FALSE .)
    DIVIDE          reduce using rule 50 (factor -> FALSE .)
    EXPONENT        reduce using rule 50 (factor -> FALSE .)
    MODULE          reduce using rule 50 (factor -> FALSE .)
    PLUS            reduce using rule 50 (factor -> FALSE .)
    MINUS           reduce using rule 50 (factor -> FALSE .)
    ID              reduce using rule 50 (factor -> FALSE .)
    VAR_INST        reduce using rule 50 (factor -> FALSE .)
    PUTS            reduce using rule 50 (factor -> FALSE .)
    IF              reduce using rule 50 (factor -> FALSE .)
    WHILE           reduce using rule 50 (factor -> FALSE .)
    FOR             reduce using rule 50 (factor -> FALSE .)
    LPAREN          reduce using rule 50 (factor -> FALSE .)
    DEF             reduce using rule 50 (factor -> FALSE .)
    CLASS           reduce using rule 50 (factor -> FALSE .)
    RETURN          reduce using rule 50 (factor -> FALSE .)
    BREAK           reduce using rule 50 (factor -> FALSE .)
    INTEGER         reduce using rule 50 (factor -> FALSE .)
    FLOAT           reduce using rule 50 (factor -> FALSE .)
    STRING          reduce using rule 50 (factor -> FALSE .)
    BOOLEAN         reduce using rule 50 (factor -> FALSE .)
    TRUE            reduce using rule 50 (factor -> FALSE .)
    FALSE           reduce using rule 50 (factor -> FALSE .)
    NIL             reduce using rule 50 (factor -> FALSE .)
    $end            reduce using rule 50 (factor -> FALSE .)
    END             reduce using rule 50 (factor -> FALSE .)
    ELSE            reduce using rule 50 (factor -> FALSE .)
    RPAREN          reduce using rule 50 (factor -> FALSE .)
    AND             reduce using rule 50 (factor -> FALSE .)
    OR              reduce using rule 50 (factor -> FALSE .)
    COMMA           reduce using rule 50 (factor -> FALSE .)
    RCORCH          reduce using rule 50 (factor -> FALSE .)
    RBRACE          reduce using rule 50 (factor -> FALSE .)


state 41

    (51) factor -> NIL .

    EQUALS          reduce using rule 51 (factor -> NIL .)
    NEQUALS         reduce using rule 51 (factor -> NIL .)
    GREATEREQ       reduce using rule 51 (factor -> NIL .)
    LESSEQ          reduce using rule 51 (factor -> NIL .)
    GREATERT        reduce using rule 51 (factor -> NIL .)
    LESST           reduce using rule 51 (factor -> NIL .)
    TIMES           reduce using rule 51 (factor -> NIL .)
    DIVIDE          reduce using rule 51 (factor -> NIL .)
    EXPONENT        reduce using rule 51 (factor -> NIL .)
    MODULE          reduce using rule 51 (factor -> NIL .)
    PLUS            reduce using rule 51 (factor -> NIL .)
    MINUS           reduce using rule 51 (factor -> NIL .)
    ID              reduce using rule 51 (factor -> NIL .)
    VAR_INST        reduce using rule 51 (factor -> NIL .)
    PUTS            reduce using rule 51 (factor -> NIL .)
    IF              reduce using rule 51 (factor -> NIL .)
    WHILE           reduce using rule 51 (factor -> NIL .)
    FOR             reduce using rule 51 (factor -> NIL .)
    LPAREN          reduce using rule 51 (factor -> NIL .)
    DEF             reduce using rule 51 (factor -> NIL .)
    CLASS           reduce using rule 51 (factor -> NIL .)
    RETURN          reduce using rule 51 (factor -> NIL .)
    BREAK           reduce using rule 51 (factor -> NIL .)
    INTEGER         reduce using rule 51 (factor -> NIL .)
    FLOAT           reduce using rule 51 (factor -> NIL .)
    STRING          reduce using rule 51 (factor -> NIL .)
    BOOLEAN         reduce using rule 51 (factor -> NIL .)
    TRUE            reduce using rule 51 (factor -> NIL .)
    FALSE           reduce using rule 51 (factor -> NIL .)
    NIL             reduce using rule 51 (factor -> NIL .)
    $end            reduce using rule 51 (factor -> NIL .)
    END             reduce using rule 51 (factor -> NIL .)
    ELSE            reduce using rule 51 (factor -> NIL .)
    RPAREN          reduce using rule 51 (factor -> NIL .)
    AND             reduce using rule 51 (factor -> NIL .)
    OR              reduce using rule 51 (factor -> NIL .)
    COMMA           reduce using rule 51 (factor -> NIL .)
    RCORCH          reduce using rule 51 (factor -> NIL .)
    RBRACE          reduce using rule 51 (factor -> NIL .)


state 42

    (3) sentences -> sentence sentences .

    $end            reduce using rule 3 (sentences -> sentence sentences .)


state 43

    (35) expression -> expression PLUS . term
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    term                           shift and go to state 73
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 44

    (36) expression -> expression MINUS . term
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    term                           shift and go to state 74
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 45

    (31) assignment -> ID ASSIGN . expression
    (34) input -> ID ASSIGN . GETS DOT ID
    (56) array -> ID ASSIGN . LCORCH elements RCORCH
    (60) hash -> ID ASSIGN . LBRACE hash_pairs RBRACE
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    GETS            shift and go to state 76
    LCORCH          shift and go to state 77
    LBRACE          shift and go to state 78
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    expression                     shift and go to state 75
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 46

    (54) function_call_empty -> ID LPAREN . RPAREN
    (55) function_call_args -> ID LPAREN . args RPAREN
    (6) args -> . ID
    (7) args -> . ID COMMA args

    RPAREN          shift and go to state 80
    ID              shift and go to state 79

    args                           shift and go to state 81

state 47

    (32) assignment -> VAR_INST ASSIGN . expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    expression                     shift and go to state 82
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 48

    (38) term -> term TIMES . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    factor                         shift and go to state 83
    logic_expression               shift and go to state 28

state 49

    (39) term -> term DIVIDE . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    factor                         shift and go to state 84
    logic_expression               shift and go to state 28

state 50

    (40) term -> term EXPONENT . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    factor                         shift and go to state 85
    logic_expression               shift and go to state 28

state 51

    (41) term -> term MODULE . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    factor                         shift and go to state 86
    logic_expression               shift and go to state 28

state 52

    (10) print -> PUTS factor .
    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

    ID              reduce using rule 10 (print -> PUTS factor .)
    VAR_INST        reduce using rule 10 (print -> PUTS factor .)
    PUTS            reduce using rule 10 (print -> PUTS factor .)
    IF              reduce using rule 10 (print -> PUTS factor .)
    WHILE           reduce using rule 10 (print -> PUTS factor .)
    FOR             reduce using rule 10 (print -> PUTS factor .)
    LPAREN          reduce using rule 10 (print -> PUTS factor .)
    DEF             reduce using rule 10 (print -> PUTS factor .)
    CLASS           reduce using rule 10 (print -> PUTS factor .)
    RETURN          reduce using rule 10 (print -> PUTS factor .)
    BREAK           reduce using rule 10 (print -> PUTS factor .)
    INTEGER         reduce using rule 10 (print -> PUTS factor .)
    FLOAT           reduce using rule 10 (print -> PUTS factor .)
    STRING          reduce using rule 10 (print -> PUTS factor .)
    BOOLEAN         reduce using rule 10 (print -> PUTS factor .)
    TRUE            reduce using rule 10 (print -> PUTS factor .)
    FALSE           reduce using rule 10 (print -> PUTS factor .)
    NIL             reduce using rule 10 (print -> PUTS factor .)
    $end            reduce using rule 10 (print -> PUTS factor .)
    END             reduce using rule 10 (print -> PUTS factor .)
    ELSE            reduce using rule 10 (print -> PUTS factor .)
    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

    logic_op                       shift and go to state 57

state 53

    (33) input -> PUTS STRING .
    (45) factor -> STRING .

  ! reduce/reduce conflict for ID resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for VAR_INST resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for PUTS resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for IF resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for WHILE resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for FOR resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for LPAREN resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for DEF resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for CLASS resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for RETURN resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for BREAK resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for INTEGER resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for FLOAT resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for STRING resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for TRUE resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for FALSE resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for NIL resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for $end resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for END resolved using rule 33 (input -> PUTS STRING .)
  ! reduce/reduce conflict for ELSE resolved using rule 33 (input -> PUTS STRING .)
    ID              reduce using rule 33 (input -> PUTS STRING .)
    VAR_INST        reduce using rule 33 (input -> PUTS STRING .)
    PUTS            reduce using rule 33 (input -> PUTS STRING .)
    IF              reduce using rule 33 (input -> PUTS STRING .)
    WHILE           reduce using rule 33 (input -> PUTS STRING .)
    FOR             reduce using rule 33 (input -> PUTS STRING .)
    LPAREN          reduce using rule 33 (input -> PUTS STRING .)
    DEF             reduce using rule 33 (input -> PUTS STRING .)
    CLASS           reduce using rule 33 (input -> PUTS STRING .)
    RETURN          reduce using rule 33 (input -> PUTS STRING .)
    BREAK           reduce using rule 33 (input -> PUTS STRING .)
    INTEGER         reduce using rule 33 (input -> PUTS STRING .)
    FLOAT           reduce using rule 33 (input -> PUTS STRING .)
    STRING          reduce using rule 33 (input -> PUTS STRING .)
    BOOLEAN         reduce using rule 33 (input -> PUTS STRING .)
    TRUE            reduce using rule 33 (input -> PUTS STRING .)
    FALSE           reduce using rule 33 (input -> PUTS STRING .)
    NIL             reduce using rule 33 (input -> PUTS STRING .)
    $end            reduce using rule 33 (input -> PUTS STRING .)
    END             reduce using rule 33 (input -> PUTS STRING .)
    ELSE            reduce using rule 33 (input -> PUTS STRING .)
    EQUALS          reduce using rule 45 (factor -> STRING .)
    NEQUALS         reduce using rule 45 (factor -> STRING .)
    GREATEREQ       reduce using rule 45 (factor -> STRING .)
    LESSEQ          reduce using rule 45 (factor -> STRING .)
    GREATERT        reduce using rule 45 (factor -> STRING .)
    LESST           reduce using rule 45 (factor -> STRING .)

  ! ID              [ reduce using rule 45 (factor -> STRING .) ]
  ! VAR_INST        [ reduce using rule 45 (factor -> STRING .) ]
  ! PUTS            [ reduce using rule 45 (factor -> STRING .) ]
  ! IF              [ reduce using rule 45 (factor -> STRING .) ]
  ! WHILE           [ reduce using rule 45 (factor -> STRING .) ]
  ! FOR             [ reduce using rule 45 (factor -> STRING .) ]
  ! LPAREN          [ reduce using rule 45 (factor -> STRING .) ]
  ! DEF             [ reduce using rule 45 (factor -> STRING .) ]
  ! CLASS           [ reduce using rule 45 (factor -> STRING .) ]
  ! RETURN          [ reduce using rule 45 (factor -> STRING .) ]
  ! BREAK           [ reduce using rule 45 (factor -> STRING .) ]
  ! INTEGER         [ reduce using rule 45 (factor -> STRING .) ]
  ! FLOAT           [ reduce using rule 45 (factor -> STRING .) ]
  ! STRING          [ reduce using rule 45 (factor -> STRING .) ]
  ! BOOLEAN         [ reduce using rule 45 (factor -> STRING .) ]
  ! TRUE            [ reduce using rule 45 (factor -> STRING .) ]
  ! FALSE           [ reduce using rule 45 (factor -> STRING .) ]
  ! NIL             [ reduce using rule 45 (factor -> STRING .) ]
  ! $end            [ reduce using rule 45 (factor -> STRING .) ]
  ! END             [ reduce using rule 45 (factor -> STRING .) ]
  ! ELSE            [ reduce using rule 45 (factor -> STRING .) ]


state 54

    (47) factor -> ID .

    EQUALS          reduce using rule 47 (factor -> ID .)
    NEQUALS         reduce using rule 47 (factor -> ID .)
    GREATEREQ       reduce using rule 47 (factor -> ID .)
    LESSEQ          reduce using rule 47 (factor -> ID .)
    GREATERT        reduce using rule 47 (factor -> ID .)
    LESST           reduce using rule 47 (factor -> ID .)
    ID              reduce using rule 47 (factor -> ID .)
    VAR_INST        reduce using rule 47 (factor -> ID .)
    PUTS            reduce using rule 47 (factor -> ID .)
    IF              reduce using rule 47 (factor -> ID .)
    WHILE           reduce using rule 47 (factor -> ID .)
    FOR             reduce using rule 47 (factor -> ID .)
    LPAREN          reduce using rule 47 (factor -> ID .)
    DEF             reduce using rule 47 (factor -> ID .)
    CLASS           reduce using rule 47 (factor -> ID .)
    RETURN          reduce using rule 47 (factor -> ID .)
    BREAK           reduce using rule 47 (factor -> ID .)
    INTEGER         reduce using rule 47 (factor -> ID .)
    FLOAT           reduce using rule 47 (factor -> ID .)
    STRING          reduce using rule 47 (factor -> ID .)
    BOOLEAN         reduce using rule 47 (factor -> ID .)
    TRUE            reduce using rule 47 (factor -> ID .)
    FALSE           reduce using rule 47 (factor -> ID .)
    NIL             reduce using rule 47 (factor -> ID .)
    $end            reduce using rule 47 (factor -> ID .)
    END             reduce using rule 47 (factor -> ID .)
    ELSE            reduce using rule 47 (factor -> ID .)
    TIMES           reduce using rule 47 (factor -> ID .)
    DIVIDE          reduce using rule 47 (factor -> ID .)
    EXPONENT        reduce using rule 47 (factor -> ID .)
    MODULE          reduce using rule 47 (factor -> ID .)
    RPAREN          reduce using rule 47 (factor -> ID .)
    PLUS            reduce using rule 47 (factor -> ID .)
    MINUS           reduce using rule 47 (factor -> ID .)
    AND             reduce using rule 47 (factor -> ID .)
    OR              reduce using rule 47 (factor -> ID .)
    COMMA           reduce using rule 47 (factor -> ID .)
    RCORCH          reduce using rule 47 (factor -> ID .)
    RBRACE          reduce using rule 47 (factor -> ID .)


state 55

    (48) factor -> VAR_INST .

    EQUALS          reduce using rule 48 (factor -> VAR_INST .)
    NEQUALS         reduce using rule 48 (factor -> VAR_INST .)
    GREATEREQ       reduce using rule 48 (factor -> VAR_INST .)
    LESSEQ          reduce using rule 48 (factor -> VAR_INST .)
    GREATERT        reduce using rule 48 (factor -> VAR_INST .)
    LESST           reduce using rule 48 (factor -> VAR_INST .)
    ID              reduce using rule 48 (factor -> VAR_INST .)
    VAR_INST        reduce using rule 48 (factor -> VAR_INST .)
    PUTS            reduce using rule 48 (factor -> VAR_INST .)
    IF              reduce using rule 48 (factor -> VAR_INST .)
    WHILE           reduce using rule 48 (factor -> VAR_INST .)
    FOR             reduce using rule 48 (factor -> VAR_INST .)
    LPAREN          reduce using rule 48 (factor -> VAR_INST .)
    DEF             reduce using rule 48 (factor -> VAR_INST .)
    CLASS           reduce using rule 48 (factor -> VAR_INST .)
    RETURN          reduce using rule 48 (factor -> VAR_INST .)
    BREAK           reduce using rule 48 (factor -> VAR_INST .)
    INTEGER         reduce using rule 48 (factor -> VAR_INST .)
    FLOAT           reduce using rule 48 (factor -> VAR_INST .)
    STRING          reduce using rule 48 (factor -> VAR_INST .)
    BOOLEAN         reduce using rule 48 (factor -> VAR_INST .)
    TRUE            reduce using rule 48 (factor -> VAR_INST .)
    FALSE           reduce using rule 48 (factor -> VAR_INST .)
    NIL             reduce using rule 48 (factor -> VAR_INST .)
    $end            reduce using rule 48 (factor -> VAR_INST .)
    END             reduce using rule 48 (factor -> VAR_INST .)
    ELSE            reduce using rule 48 (factor -> VAR_INST .)
    TIMES           reduce using rule 48 (factor -> VAR_INST .)
    DIVIDE          reduce using rule 48 (factor -> VAR_INST .)
    EXPONENT        reduce using rule 48 (factor -> VAR_INST .)
    MODULE          reduce using rule 48 (factor -> VAR_INST .)
    RPAREN          reduce using rule 48 (factor -> VAR_INST .)
    PLUS            reduce using rule 48 (factor -> VAR_INST .)
    MINUS           reduce using rule 48 (factor -> VAR_INST .)
    AND             reduce using rule 48 (factor -> VAR_INST .)
    OR              reduce using rule 48 (factor -> VAR_INST .)
    COMMA           reduce using rule 48 (factor -> VAR_INST .)
    RCORCH          reduce using rule 48 (factor -> VAR_INST .)
    RBRACE          reduce using rule 48 (factor -> VAR_INST .)


state 56

    (52) factor -> LPAREN . expression RPAREN
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    expression                     shift and go to state 69
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 57

    (68) logic_expression -> factor logic_op . factor
    (69) logic_expression -> factor logic_op . factor logic_connector logic_expression
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    factor                         shift and go to state 87
    logic_expression               shift and go to state 28

state 58

    (70) logic_op -> EQUALS .

    INTEGER         reduce using rule 70 (logic_op -> EQUALS .)
    FLOAT           reduce using rule 70 (logic_op -> EQUALS .)
    STRING          reduce using rule 70 (logic_op -> EQUALS .)
    BOOLEAN         reduce using rule 70 (logic_op -> EQUALS .)
    ID              reduce using rule 70 (logic_op -> EQUALS .)
    VAR_INST        reduce using rule 70 (logic_op -> EQUALS .)
    TRUE            reduce using rule 70 (logic_op -> EQUALS .)
    FALSE           reduce using rule 70 (logic_op -> EQUALS .)
    NIL             reduce using rule 70 (logic_op -> EQUALS .)
    LPAREN          reduce using rule 70 (logic_op -> EQUALS .)


state 59

    (71) logic_op -> NEQUALS .

    INTEGER         reduce using rule 71 (logic_op -> NEQUALS .)
    FLOAT           reduce using rule 71 (logic_op -> NEQUALS .)
    STRING          reduce using rule 71 (logic_op -> NEQUALS .)
    BOOLEAN         reduce using rule 71 (logic_op -> NEQUALS .)
    ID              reduce using rule 71 (logic_op -> NEQUALS .)
    VAR_INST        reduce using rule 71 (logic_op -> NEQUALS .)
    TRUE            reduce using rule 71 (logic_op -> NEQUALS .)
    FALSE           reduce using rule 71 (logic_op -> NEQUALS .)
    NIL             reduce using rule 71 (logic_op -> NEQUALS .)
    LPAREN          reduce using rule 71 (logic_op -> NEQUALS .)


state 60

    (72) logic_op -> GREATEREQ .

    INTEGER         reduce using rule 72 (logic_op -> GREATEREQ .)
    FLOAT           reduce using rule 72 (logic_op -> GREATEREQ .)
    STRING          reduce using rule 72 (logic_op -> GREATEREQ .)
    BOOLEAN         reduce using rule 72 (logic_op -> GREATEREQ .)
    ID              reduce using rule 72 (logic_op -> GREATEREQ .)
    VAR_INST        reduce using rule 72 (logic_op -> GREATEREQ .)
    TRUE            reduce using rule 72 (logic_op -> GREATEREQ .)
    FALSE           reduce using rule 72 (logic_op -> GREATEREQ .)
    NIL             reduce using rule 72 (logic_op -> GREATEREQ .)
    LPAREN          reduce using rule 72 (logic_op -> GREATEREQ .)


state 61

    (73) logic_op -> LESSEQ .

    INTEGER         reduce using rule 73 (logic_op -> LESSEQ .)
    FLOAT           reduce using rule 73 (logic_op -> LESSEQ .)
    STRING          reduce using rule 73 (logic_op -> LESSEQ .)
    BOOLEAN         reduce using rule 73 (logic_op -> LESSEQ .)
    ID              reduce using rule 73 (logic_op -> LESSEQ .)
    VAR_INST        reduce using rule 73 (logic_op -> LESSEQ .)
    TRUE            reduce using rule 73 (logic_op -> LESSEQ .)
    FALSE           reduce using rule 73 (logic_op -> LESSEQ .)
    NIL             reduce using rule 73 (logic_op -> LESSEQ .)
    LPAREN          reduce using rule 73 (logic_op -> LESSEQ .)


state 62

    (74) logic_op -> GREATERT .

    INTEGER         reduce using rule 74 (logic_op -> GREATERT .)
    FLOAT           reduce using rule 74 (logic_op -> GREATERT .)
    STRING          reduce using rule 74 (logic_op -> GREATERT .)
    BOOLEAN         reduce using rule 74 (logic_op -> GREATERT .)
    ID              reduce using rule 74 (logic_op -> GREATERT .)
    VAR_INST        reduce using rule 74 (logic_op -> GREATERT .)
    TRUE            reduce using rule 74 (logic_op -> GREATERT .)
    FALSE           reduce using rule 74 (logic_op -> GREATERT .)
    NIL             reduce using rule 74 (logic_op -> GREATERT .)
    LPAREN          reduce using rule 74 (logic_op -> GREATERT .)


state 63

    (75) logic_op -> LESST .

    INTEGER         reduce using rule 75 (logic_op -> LESST .)
    FLOAT           reduce using rule 75 (logic_op -> LESST .)
    STRING          reduce using rule 75 (logic_op -> LESST .)
    BOOLEAN         reduce using rule 75 (logic_op -> LESST .)
    ID              reduce using rule 75 (logic_op -> LESST .)
    VAR_INST        reduce using rule 75 (logic_op -> LESST .)
    TRUE            reduce using rule 75 (logic_op -> LESST .)
    FALSE           reduce using rule 75 (logic_op -> LESST .)
    NIL             reduce using rule 75 (logic_op -> LESST .)
    LPAREN          reduce using rule 75 (logic_op -> LESST .)


state 64

    (66) condition -> IF logic_expression . body END
    (67) condition -> IF logic_expression . body ELSE body END
    (53) factor -> logic_expression .
    (8) body -> . sentence
    (9) body -> . sentence body
    (12) sentence -> . assignment
    (13) sentence -> . expression
    (14) sentence -> . print
    (15) sentence -> . input
    (16) sentence -> . condition
    (17) sentence -> . while_loop
    (18) sentence -> . for_loop
    (19) sentence -> . array
    (20) sentence -> . range_incl
    (21) sentence -> . range_excl
    (22) sentence -> . hash
    (23) sentence -> . function
    (24) sentence -> . class_def
    (25) sentence -> . return_stmt
    (26) sentence -> . break_stmt
    (27) sentence -> . function_call_empty
    (28) sentence -> . function_call_args
    (31) assignment -> . ID ASSIGN expression
    (32) assignment -> . VAR_INST ASSIGN expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (10) print -> . PUTS factor
    (33) input -> . PUTS STRING
    (34) input -> . ID ASSIGN GETS DOT ID
    (66) condition -> . IF logic_expression body END
    (67) condition -> . IF logic_expression body ELSE body END
    (63) while_loop -> . WHILE logic_expression body END
    (59) for_loop -> . FOR ID IN range_incl body END
    (56) array -> . ID ASSIGN LCORCH elements RCORCH
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (60) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (11) class_def -> . CLASS ID body END
    (29) return_stmt -> . RETURN factor
    (30) break_stmt -> . BREAK
    (54) function_call_empty -> . ID LPAREN RPAREN
    (55) function_call_args -> . ID LPAREN args RPAREN
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    EQUALS          reduce using rule 53 (factor -> logic_expression .)
    NEQUALS         reduce using rule 53 (factor -> logic_expression .)
    GREATEREQ       reduce using rule 53 (factor -> logic_expression .)
    LESSEQ          reduce using rule 53 (factor -> logic_expression .)
    GREATERT        reduce using rule 53 (factor -> logic_expression .)
    LESST           reduce using rule 53 (factor -> logic_expression .)
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    logic_expression               shift and go to state 28
    body                           shift and go to state 88
    sentence                       shift and go to state 89
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25

state 65

    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

    logic_op                       shift and go to state 57

state 66

    (63) while_loop -> WHILE logic_expression . body END
    (53) factor -> logic_expression .
    (8) body -> . sentence
    (9) body -> . sentence body
    (12) sentence -> . assignment
    (13) sentence -> . expression
    (14) sentence -> . print
    (15) sentence -> . input
    (16) sentence -> . condition
    (17) sentence -> . while_loop
    (18) sentence -> . for_loop
    (19) sentence -> . array
    (20) sentence -> . range_incl
    (21) sentence -> . range_excl
    (22) sentence -> . hash
    (23) sentence -> . function
    (24) sentence -> . class_def
    (25) sentence -> . return_stmt
    (26) sentence -> . break_stmt
    (27) sentence -> . function_call_empty
    (28) sentence -> . function_call_args
    (31) assignment -> . ID ASSIGN expression
    (32) assignment -> . VAR_INST ASSIGN expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (10) print -> . PUTS factor
    (33) input -> . PUTS STRING
    (34) input -> . ID ASSIGN GETS DOT ID
    (66) condition -> . IF logic_expression body END
    (67) condition -> . IF logic_expression body ELSE body END
    (63) while_loop -> . WHILE logic_expression body END
    (59) for_loop -> . FOR ID IN range_incl body END
    (56) array -> . ID ASSIGN LCORCH elements RCORCH
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (60) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (11) class_def -> . CLASS ID body END
    (29) return_stmt -> . RETURN factor
    (30) break_stmt -> . BREAK
    (54) function_call_empty -> . ID LPAREN RPAREN
    (55) function_call_args -> . ID LPAREN args RPAREN
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    EQUALS          reduce using rule 53 (factor -> logic_expression .)
    NEQUALS         reduce using rule 53 (factor -> logic_expression .)
    GREATEREQ       reduce using rule 53 (factor -> logic_expression .)
    LESSEQ          reduce using rule 53 (factor -> logic_expression .)
    GREATERT        reduce using rule 53 (factor -> logic_expression .)
    LESST           reduce using rule 53 (factor -> logic_expression .)
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    logic_expression               shift and go to state 28
    body                           shift and go to state 90
    sentence                       shift and go to state 89
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25

state 67

    (59) for_loop -> FOR ID . IN range_incl body END

    IN              shift and go to state 91


state 68

    (64) range_incl -> LPAREN INTEGER . RANGE_INCL INTEGER RPAREN
    (65) range_excl -> LPAREN INTEGER . RANGE_EXCL INTEGER RPAREN
    (43) factor -> INTEGER .

    RANGE_INCL      shift and go to state 92
    RANGE_EXCL      shift and go to state 93
    EQUALS          reduce using rule 43 (factor -> INTEGER .)
    NEQUALS         reduce using rule 43 (factor -> INTEGER .)
    GREATEREQ       reduce using rule 43 (factor -> INTEGER .)
    LESSEQ          reduce using rule 43 (factor -> INTEGER .)
    GREATERT        reduce using rule 43 (factor -> INTEGER .)
    LESST           reduce using rule 43 (factor -> INTEGER .)
    TIMES           reduce using rule 43 (factor -> INTEGER .)
    DIVIDE          reduce using rule 43 (factor -> INTEGER .)
    EXPONENT        reduce using rule 43 (factor -> INTEGER .)
    MODULE          reduce using rule 43 (factor -> INTEGER .)
    RPAREN          reduce using rule 43 (factor -> INTEGER .)
    PLUS            reduce using rule 43 (factor -> INTEGER .)
    MINUS           reduce using rule 43 (factor -> INTEGER .)


state 69

    (52) factor -> LPAREN expression . RPAREN
    (35) expression -> expression . PLUS term
    (36) expression -> expression . MINUS term

    RPAREN          shift and go to state 94
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44


state 70

    (4) function -> DEF ID . body END
    (5) function -> DEF ID . LPAREN args RPAREN body END
    (8) body -> . sentence
    (9) body -> . sentence body
    (12) sentence -> . assignment
    (13) sentence -> . expression
    (14) sentence -> . print
    (15) sentence -> . input
    (16) sentence -> . condition
    (17) sentence -> . while_loop
    (18) sentence -> . for_loop
    (19) sentence -> . array
    (20) sentence -> . range_incl
    (21) sentence -> . range_excl
    (22) sentence -> . hash
    (23) sentence -> . function
    (24) sentence -> . class_def
    (25) sentence -> . return_stmt
    (26) sentence -> . break_stmt
    (27) sentence -> . function_call_empty
    (28) sentence -> . function_call_args
    (31) assignment -> . ID ASSIGN expression
    (32) assignment -> . VAR_INST ASSIGN expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (10) print -> . PUTS factor
    (33) input -> . PUTS STRING
    (34) input -> . ID ASSIGN GETS DOT ID
    (66) condition -> . IF logic_expression body END
    (67) condition -> . IF logic_expression body ELSE body END
    (63) while_loop -> . WHILE logic_expression body END
    (59) for_loop -> . FOR ID IN range_incl body END
    (56) array -> . ID ASSIGN LCORCH elements RCORCH
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (60) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (11) class_def -> . CLASS ID body END
    (29) return_stmt -> . RETURN factor
    (30) break_stmt -> . BREAK
    (54) function_call_empty -> . ID LPAREN RPAREN
    (55) function_call_args -> . ID LPAREN args RPAREN
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    LPAREN          shift and go to state 96
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    body                           shift and go to state 95
    sentence                       shift and go to state 89
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 71

    (11) class_def -> CLASS ID . body END
    (8) body -> . sentence
    (9) body -> . sentence body
    (12) sentence -> . assignment
    (13) sentence -> . expression
    (14) sentence -> . print
    (15) sentence -> . input
    (16) sentence -> . condition
    (17) sentence -> . while_loop
    (18) sentence -> . for_loop
    (19) sentence -> . array
    (20) sentence -> . range_incl
    (21) sentence -> . range_excl
    (22) sentence -> . hash
    (23) sentence -> . function
    (24) sentence -> . class_def
    (25) sentence -> . return_stmt
    (26) sentence -> . break_stmt
    (27) sentence -> . function_call_empty
    (28) sentence -> . function_call_args
    (31) assignment -> . ID ASSIGN expression
    (32) assignment -> . VAR_INST ASSIGN expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (10) print -> . PUTS factor
    (33) input -> . PUTS STRING
    (34) input -> . ID ASSIGN GETS DOT ID
    (66) condition -> . IF logic_expression body END
    (67) condition -> . IF logic_expression body ELSE body END
    (63) while_loop -> . WHILE logic_expression body END
    (59) for_loop -> . FOR ID IN range_incl body END
    (56) array -> . ID ASSIGN LCORCH elements RCORCH
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (60) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (11) class_def -> . CLASS ID body END
    (29) return_stmt -> . RETURN factor
    (30) break_stmt -> . BREAK
    (54) function_call_empty -> . ID LPAREN RPAREN
    (55) function_call_args -> . ID LPAREN args RPAREN
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    body                           shift and go to state 97
    sentence                       shift and go to state 89
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 72

    (29) return_stmt -> RETURN factor .
    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

    ID              reduce using rule 29 (return_stmt -> RETURN factor .)
    VAR_INST        reduce using rule 29 (return_stmt -> RETURN factor .)
    PUTS            reduce using rule 29 (return_stmt -> RETURN factor .)
    IF              reduce using rule 29 (return_stmt -> RETURN factor .)
    WHILE           reduce using rule 29 (return_stmt -> RETURN factor .)
    FOR             reduce using rule 29 (return_stmt -> RETURN factor .)
    LPAREN          reduce using rule 29 (return_stmt -> RETURN factor .)
    DEF             reduce using rule 29 (return_stmt -> RETURN factor .)
    CLASS           reduce using rule 29 (return_stmt -> RETURN factor .)
    RETURN          reduce using rule 29 (return_stmt -> RETURN factor .)
    BREAK           reduce using rule 29 (return_stmt -> RETURN factor .)
    INTEGER         reduce using rule 29 (return_stmt -> RETURN factor .)
    FLOAT           reduce using rule 29 (return_stmt -> RETURN factor .)
    STRING          reduce using rule 29 (return_stmt -> RETURN factor .)
    BOOLEAN         reduce using rule 29 (return_stmt -> RETURN factor .)
    TRUE            reduce using rule 29 (return_stmt -> RETURN factor .)
    FALSE           reduce using rule 29 (return_stmt -> RETURN factor .)
    NIL             reduce using rule 29 (return_stmt -> RETURN factor .)
    $end            reduce using rule 29 (return_stmt -> RETURN factor .)
    END             reduce using rule 29 (return_stmt -> RETURN factor .)
    ELSE            reduce using rule 29 (return_stmt -> RETURN factor .)
    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

    logic_op                       shift and go to state 57

state 73

    (35) expression -> expression PLUS term .
    (38) term -> term . TIMES factor
    (39) term -> term . DIVIDE factor
    (40) term -> term . EXPONENT factor
    (41) term -> term . MODULE factor

    PLUS            reduce using rule 35 (expression -> expression PLUS term .)
    MINUS           reduce using rule 35 (expression -> expression PLUS term .)
    ID              reduce using rule 35 (expression -> expression PLUS term .)
    VAR_INST        reduce using rule 35 (expression -> expression PLUS term .)
    PUTS            reduce using rule 35 (expression -> expression PLUS term .)
    IF              reduce using rule 35 (expression -> expression PLUS term .)
    WHILE           reduce using rule 35 (expression -> expression PLUS term .)
    FOR             reduce using rule 35 (expression -> expression PLUS term .)
    LPAREN          reduce using rule 35 (expression -> expression PLUS term .)
    DEF             reduce using rule 35 (expression -> expression PLUS term .)
    CLASS           reduce using rule 35 (expression -> expression PLUS term .)
    RETURN          reduce using rule 35 (expression -> expression PLUS term .)
    BREAK           reduce using rule 35 (expression -> expression PLUS term .)
    INTEGER         reduce using rule 35 (expression -> expression PLUS term .)
    FLOAT           reduce using rule 35 (expression -> expression PLUS term .)
    STRING          reduce using rule 35 (expression -> expression PLUS term .)
    BOOLEAN         reduce using rule 35 (expression -> expression PLUS term .)
    TRUE            reduce using rule 35 (expression -> expression PLUS term .)
    FALSE           reduce using rule 35 (expression -> expression PLUS term .)
    NIL             reduce using rule 35 (expression -> expression PLUS term .)
    $end            reduce using rule 35 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 35 (expression -> expression PLUS term .)
    END             reduce using rule 35 (expression -> expression PLUS term .)
    ELSE            reduce using rule 35 (expression -> expression PLUS term .)
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    EXPONENT        shift and go to state 50
    MODULE          shift and go to state 51


state 74

    (36) expression -> expression MINUS term .
    (38) term -> term . TIMES factor
    (39) term -> term . DIVIDE factor
    (40) term -> term . EXPONENT factor
    (41) term -> term . MODULE factor

    PLUS            reduce using rule 36 (expression -> expression MINUS term .)
    MINUS           reduce using rule 36 (expression -> expression MINUS term .)
    ID              reduce using rule 36 (expression -> expression MINUS term .)
    VAR_INST        reduce using rule 36 (expression -> expression MINUS term .)
    PUTS            reduce using rule 36 (expression -> expression MINUS term .)
    IF              reduce using rule 36 (expression -> expression MINUS term .)
    WHILE           reduce using rule 36 (expression -> expression MINUS term .)
    FOR             reduce using rule 36 (expression -> expression MINUS term .)
    LPAREN          reduce using rule 36 (expression -> expression MINUS term .)
    DEF             reduce using rule 36 (expression -> expression MINUS term .)
    CLASS           reduce using rule 36 (expression -> expression MINUS term .)
    RETURN          reduce using rule 36 (expression -> expression MINUS term .)
    BREAK           reduce using rule 36 (expression -> expression MINUS term .)
    INTEGER         reduce using rule 36 (expression -> expression MINUS term .)
    FLOAT           reduce using rule 36 (expression -> expression MINUS term .)
    STRING          reduce using rule 36 (expression -> expression MINUS term .)
    BOOLEAN         reduce using rule 36 (expression -> expression MINUS term .)
    TRUE            reduce using rule 36 (expression -> expression MINUS term .)
    FALSE           reduce using rule 36 (expression -> expression MINUS term .)
    NIL             reduce using rule 36 (expression -> expression MINUS term .)
    $end            reduce using rule 36 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 36 (expression -> expression MINUS term .)
    END             reduce using rule 36 (expression -> expression MINUS term .)
    ELSE            reduce using rule 36 (expression -> expression MINUS term .)
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    EXPONENT        shift and go to state 50
    MODULE          shift and go to state 51


state 75

    (31) assignment -> ID ASSIGN expression .
    (35) expression -> expression . PLUS term
    (36) expression -> expression . MINUS term

    ID              reduce using rule 31 (assignment -> ID ASSIGN expression .)
    VAR_INST        reduce using rule 31 (assignment -> ID ASSIGN expression .)
    PUTS            reduce using rule 31 (assignment -> ID ASSIGN expression .)
    IF              reduce using rule 31 (assignment -> ID ASSIGN expression .)
    WHILE           reduce using rule 31 (assignment -> ID ASSIGN expression .)
    FOR             reduce using rule 31 (assignment -> ID ASSIGN expression .)
    LPAREN          reduce using rule 31 (assignment -> ID ASSIGN expression .)
    DEF             reduce using rule 31 (assignment -> ID ASSIGN expression .)
    CLASS           reduce using rule 31 (assignment -> ID ASSIGN expression .)
    RETURN          reduce using rule 31 (assignment -> ID ASSIGN expression .)
    BREAK           reduce using rule 31 (assignment -> ID ASSIGN expression .)
    INTEGER         reduce using rule 31 (assignment -> ID ASSIGN expression .)
    FLOAT           reduce using rule 31 (assignment -> ID ASSIGN expression .)
    STRING          reduce using rule 31 (assignment -> ID ASSIGN expression .)
    BOOLEAN         reduce using rule 31 (assignment -> ID ASSIGN expression .)
    TRUE            reduce using rule 31 (assignment -> ID ASSIGN expression .)
    FALSE           reduce using rule 31 (assignment -> ID ASSIGN expression .)
    NIL             reduce using rule 31 (assignment -> ID ASSIGN expression .)
    $end            reduce using rule 31 (assignment -> ID ASSIGN expression .)
    END             reduce using rule 31 (assignment -> ID ASSIGN expression .)
    ELSE            reduce using rule 31 (assignment -> ID ASSIGN expression .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44


state 76

    (34) input -> ID ASSIGN GETS . DOT ID

    DOT             shift and go to state 98


state 77

    (56) array -> ID ASSIGN LCORCH . elements RCORCH
    (57) elements -> . factor
    (58) elements -> . factor COMMA elements
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    elements                       shift and go to state 99
    factor                         shift and go to state 100
    logic_expression               shift and go to state 28

state 78

    (60) hash -> ID ASSIGN LBRACE . hash_pairs RBRACE
    (61) hash_pairs -> . STRING COLON factor
    (62) hash_pairs -> . STRING COLON factor COMMA hash_pairs

    STRING          shift and go to state 102

    hash_pairs                     shift and go to state 101

state 79

    (6) args -> ID .
    (7) args -> ID . COMMA args

    RPAREN          reduce using rule 6 (args -> ID .)
    COMMA           shift and go to state 103


state 80

    (54) function_call_empty -> ID LPAREN RPAREN .

    ID              reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    VAR_INST        reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    PUTS            reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    IF              reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    FOR             reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    LPAREN          reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    DEF             reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    CLASS           reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    BREAK           reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    INTEGER         reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    FLOAT           reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    STRING          reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    BOOLEAN         reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    TRUE            reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    FALSE           reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    NIL             reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    $end            reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    END             reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 54 (function_call_empty -> ID LPAREN RPAREN .)


state 81

    (55) function_call_args -> ID LPAREN args . RPAREN

    RPAREN          shift and go to state 104


state 82

    (32) assignment -> VAR_INST ASSIGN expression .
    (35) expression -> expression . PLUS term
    (36) expression -> expression . MINUS term

    ID              reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    VAR_INST        reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    PUTS            reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    IF              reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    WHILE           reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    FOR             reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    LPAREN          reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    DEF             reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    CLASS           reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    RETURN          reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    BREAK           reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    INTEGER         reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    FLOAT           reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    STRING          reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    BOOLEAN         reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    TRUE            reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    FALSE           reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    NIL             reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    $end            reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    END             reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    ELSE            reduce using rule 32 (assignment -> VAR_INST ASSIGN expression .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44


state 83

    (38) term -> term TIMES factor .
    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

    TIMES           reduce using rule 38 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 38 (term -> term TIMES factor .)
    EXPONENT        reduce using rule 38 (term -> term TIMES factor .)
    MODULE          reduce using rule 38 (term -> term TIMES factor .)
    PLUS            reduce using rule 38 (term -> term TIMES factor .)
    MINUS           reduce using rule 38 (term -> term TIMES factor .)
    ID              reduce using rule 38 (term -> term TIMES factor .)
    VAR_INST        reduce using rule 38 (term -> term TIMES factor .)
    PUTS            reduce using rule 38 (term -> term TIMES factor .)
    IF              reduce using rule 38 (term -> term TIMES factor .)
    WHILE           reduce using rule 38 (term -> term TIMES factor .)
    FOR             reduce using rule 38 (term -> term TIMES factor .)
    LPAREN          reduce using rule 38 (term -> term TIMES factor .)
    DEF             reduce using rule 38 (term -> term TIMES factor .)
    CLASS           reduce using rule 38 (term -> term TIMES factor .)
    RETURN          reduce using rule 38 (term -> term TIMES factor .)
    BREAK           reduce using rule 38 (term -> term TIMES factor .)
    INTEGER         reduce using rule 38 (term -> term TIMES factor .)
    FLOAT           reduce using rule 38 (term -> term TIMES factor .)
    STRING          reduce using rule 38 (term -> term TIMES factor .)
    BOOLEAN         reduce using rule 38 (term -> term TIMES factor .)
    TRUE            reduce using rule 38 (term -> term TIMES factor .)
    FALSE           reduce using rule 38 (term -> term TIMES factor .)
    NIL             reduce using rule 38 (term -> term TIMES factor .)
    $end            reduce using rule 38 (term -> term TIMES factor .)
    RPAREN          reduce using rule 38 (term -> term TIMES factor .)
    END             reduce using rule 38 (term -> term TIMES factor .)
    ELSE            reduce using rule 38 (term -> term TIMES factor .)
    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

    logic_op                       shift and go to state 57

state 84

    (39) term -> term DIVIDE factor .
    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

    TIMES           reduce using rule 39 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 39 (term -> term DIVIDE factor .)
    EXPONENT        reduce using rule 39 (term -> term DIVIDE factor .)
    MODULE          reduce using rule 39 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 39 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 39 (term -> term DIVIDE factor .)
    ID              reduce using rule 39 (term -> term DIVIDE factor .)
    VAR_INST        reduce using rule 39 (term -> term DIVIDE factor .)
    PUTS            reduce using rule 39 (term -> term DIVIDE factor .)
    IF              reduce using rule 39 (term -> term DIVIDE factor .)
    WHILE           reduce using rule 39 (term -> term DIVIDE factor .)
    FOR             reduce using rule 39 (term -> term DIVIDE factor .)
    LPAREN          reduce using rule 39 (term -> term DIVIDE factor .)
    DEF             reduce using rule 39 (term -> term DIVIDE factor .)
    CLASS           reduce using rule 39 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 39 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 39 (term -> term DIVIDE factor .)
    INTEGER         reduce using rule 39 (term -> term DIVIDE factor .)
    FLOAT           reduce using rule 39 (term -> term DIVIDE factor .)
    STRING          reduce using rule 39 (term -> term DIVIDE factor .)
    BOOLEAN         reduce using rule 39 (term -> term DIVIDE factor .)
    TRUE            reduce using rule 39 (term -> term DIVIDE factor .)
    FALSE           reduce using rule 39 (term -> term DIVIDE factor .)
    NIL             reduce using rule 39 (term -> term DIVIDE factor .)
    $end            reduce using rule 39 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 39 (term -> term DIVIDE factor .)
    END             reduce using rule 39 (term -> term DIVIDE factor .)
    ELSE            reduce using rule 39 (term -> term DIVIDE factor .)
    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

    logic_op                       shift and go to state 57

state 85

    (40) term -> term EXPONENT factor .
    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

    TIMES           reduce using rule 40 (term -> term EXPONENT factor .)
    DIVIDE          reduce using rule 40 (term -> term EXPONENT factor .)
    EXPONENT        reduce using rule 40 (term -> term EXPONENT factor .)
    MODULE          reduce using rule 40 (term -> term EXPONENT factor .)
    PLUS            reduce using rule 40 (term -> term EXPONENT factor .)
    MINUS           reduce using rule 40 (term -> term EXPONENT factor .)
    ID              reduce using rule 40 (term -> term EXPONENT factor .)
    VAR_INST        reduce using rule 40 (term -> term EXPONENT factor .)
    PUTS            reduce using rule 40 (term -> term EXPONENT factor .)
    IF              reduce using rule 40 (term -> term EXPONENT factor .)
    WHILE           reduce using rule 40 (term -> term EXPONENT factor .)
    FOR             reduce using rule 40 (term -> term EXPONENT factor .)
    LPAREN          reduce using rule 40 (term -> term EXPONENT factor .)
    DEF             reduce using rule 40 (term -> term EXPONENT factor .)
    CLASS           reduce using rule 40 (term -> term EXPONENT factor .)
    RETURN          reduce using rule 40 (term -> term EXPONENT factor .)
    BREAK           reduce using rule 40 (term -> term EXPONENT factor .)
    INTEGER         reduce using rule 40 (term -> term EXPONENT factor .)
    FLOAT           reduce using rule 40 (term -> term EXPONENT factor .)
    STRING          reduce using rule 40 (term -> term EXPONENT factor .)
    BOOLEAN         reduce using rule 40 (term -> term EXPONENT factor .)
    TRUE            reduce using rule 40 (term -> term EXPONENT factor .)
    FALSE           reduce using rule 40 (term -> term EXPONENT factor .)
    NIL             reduce using rule 40 (term -> term EXPONENT factor .)
    $end            reduce using rule 40 (term -> term EXPONENT factor .)
    RPAREN          reduce using rule 40 (term -> term EXPONENT factor .)
    END             reduce using rule 40 (term -> term EXPONENT factor .)
    ELSE            reduce using rule 40 (term -> term EXPONENT factor .)
    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

    logic_op                       shift and go to state 57

state 86

    (41) term -> term MODULE factor .
    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

    TIMES           reduce using rule 41 (term -> term MODULE factor .)
    DIVIDE          reduce using rule 41 (term -> term MODULE factor .)
    EXPONENT        reduce using rule 41 (term -> term MODULE factor .)
    MODULE          reduce using rule 41 (term -> term MODULE factor .)
    PLUS            reduce using rule 41 (term -> term MODULE factor .)
    MINUS           reduce using rule 41 (term -> term MODULE factor .)
    ID              reduce using rule 41 (term -> term MODULE factor .)
    VAR_INST        reduce using rule 41 (term -> term MODULE factor .)
    PUTS            reduce using rule 41 (term -> term MODULE factor .)
    IF              reduce using rule 41 (term -> term MODULE factor .)
    WHILE           reduce using rule 41 (term -> term MODULE factor .)
    FOR             reduce using rule 41 (term -> term MODULE factor .)
    LPAREN          reduce using rule 41 (term -> term MODULE factor .)
    DEF             reduce using rule 41 (term -> term MODULE factor .)
    CLASS           reduce using rule 41 (term -> term MODULE factor .)
    RETURN          reduce using rule 41 (term -> term MODULE factor .)
    BREAK           reduce using rule 41 (term -> term MODULE factor .)
    INTEGER         reduce using rule 41 (term -> term MODULE factor .)
    FLOAT           reduce using rule 41 (term -> term MODULE factor .)
    STRING          reduce using rule 41 (term -> term MODULE factor .)
    BOOLEAN         reduce using rule 41 (term -> term MODULE factor .)
    TRUE            reduce using rule 41 (term -> term MODULE factor .)
    FALSE           reduce using rule 41 (term -> term MODULE factor .)
    NIL             reduce using rule 41 (term -> term MODULE factor .)
    $end            reduce using rule 41 (term -> term MODULE factor .)
    RPAREN          reduce using rule 41 (term -> term MODULE factor .)
    END             reduce using rule 41 (term -> term MODULE factor .)
    ELSE            reduce using rule 41 (term -> term MODULE factor .)
    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

    logic_op                       shift and go to state 57

state 87

    (68) logic_expression -> factor logic_op factor .
    (69) logic_expression -> factor logic_op factor . logic_connector logic_expression
    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (76) logic_connector -> . AND
    (77) logic_connector -> . OR
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    TIMES           reduce using rule 68 (logic_expression -> factor logic_op factor .)
    DIVIDE          reduce using rule 68 (logic_expression -> factor logic_op factor .)
    EXPONENT        reduce using rule 68 (logic_expression -> factor logic_op factor .)
    MODULE          reduce using rule 68 (logic_expression -> factor logic_op factor .)
    PLUS            reduce using rule 68 (logic_expression -> factor logic_op factor .)
    MINUS           reduce using rule 68 (logic_expression -> factor logic_op factor .)
    ID              reduce using rule 68 (logic_expression -> factor logic_op factor .)
    VAR_INST        reduce using rule 68 (logic_expression -> factor logic_op factor .)
    PUTS            reduce using rule 68 (logic_expression -> factor logic_op factor .)
    IF              reduce using rule 68 (logic_expression -> factor logic_op factor .)
    WHILE           reduce using rule 68 (logic_expression -> factor logic_op factor .)
    FOR             reduce using rule 68 (logic_expression -> factor logic_op factor .)
    LPAREN          reduce using rule 68 (logic_expression -> factor logic_op factor .)
    DEF             reduce using rule 68 (logic_expression -> factor logic_op factor .)
    CLASS           reduce using rule 68 (logic_expression -> factor logic_op factor .)
    RETURN          reduce using rule 68 (logic_expression -> factor logic_op factor .)
    BREAK           reduce using rule 68 (logic_expression -> factor logic_op factor .)
    INTEGER         reduce using rule 68 (logic_expression -> factor logic_op factor .)
    FLOAT           reduce using rule 68 (logic_expression -> factor logic_op factor .)
    STRING          reduce using rule 68 (logic_expression -> factor logic_op factor .)
    BOOLEAN         reduce using rule 68 (logic_expression -> factor logic_op factor .)
    TRUE            reduce using rule 68 (logic_expression -> factor logic_op factor .)
    FALSE           reduce using rule 68 (logic_expression -> factor logic_op factor .)
    NIL             reduce using rule 68 (logic_expression -> factor logic_op factor .)
    $end            reduce using rule 68 (logic_expression -> factor logic_op factor .)
    END             reduce using rule 68 (logic_expression -> factor logic_op factor .)
    ELSE            reduce using rule 68 (logic_expression -> factor logic_op factor .)
    RPAREN          reduce using rule 68 (logic_expression -> factor logic_op factor .)
    COMMA           reduce using rule 68 (logic_expression -> factor logic_op factor .)
    RCORCH          reduce using rule 68 (logic_expression -> factor logic_op factor .)
    RBRACE          reduce using rule 68 (logic_expression -> factor logic_op factor .)
    AND             shift and go to state 106
    OR              shift and go to state 107
    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

  ! EQUALS          [ reduce using rule 68 (logic_expression -> factor logic_op factor .) ]
  ! NEQUALS         [ reduce using rule 68 (logic_expression -> factor logic_op factor .) ]
  ! GREATEREQ       [ reduce using rule 68 (logic_expression -> factor logic_op factor .) ]
  ! LESSEQ          [ reduce using rule 68 (logic_expression -> factor logic_op factor .) ]
  ! GREATERT        [ reduce using rule 68 (logic_expression -> factor logic_op factor .) ]
  ! LESST           [ reduce using rule 68 (logic_expression -> factor logic_op factor .) ]
  ! AND             [ reduce using rule 68 (logic_expression -> factor logic_op factor .) ]
  ! OR              [ reduce using rule 68 (logic_expression -> factor logic_op factor .) ]

    logic_op                       shift and go to state 57
    logic_connector                shift and go to state 105

state 88

    (66) condition -> IF logic_expression body . END
    (67) condition -> IF logic_expression body . ELSE body END

    END             shift and go to state 108
    ELSE            shift and go to state 109


state 89

    (8) body -> sentence .
    (9) body -> sentence . body
    (8) body -> . sentence
    (9) body -> . sentence body
    (12) sentence -> . assignment
    (13) sentence -> . expression
    (14) sentence -> . print
    (15) sentence -> . input
    (16) sentence -> . condition
    (17) sentence -> . while_loop
    (18) sentence -> . for_loop
    (19) sentence -> . array
    (20) sentence -> . range_incl
    (21) sentence -> . range_excl
    (22) sentence -> . hash
    (23) sentence -> . function
    (24) sentence -> . class_def
    (25) sentence -> . return_stmt
    (26) sentence -> . break_stmt
    (27) sentence -> . function_call_empty
    (28) sentence -> . function_call_args
    (31) assignment -> . ID ASSIGN expression
    (32) assignment -> . VAR_INST ASSIGN expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (10) print -> . PUTS factor
    (33) input -> . PUTS STRING
    (34) input -> . ID ASSIGN GETS DOT ID
    (66) condition -> . IF logic_expression body END
    (67) condition -> . IF logic_expression body ELSE body END
    (63) while_loop -> . WHILE logic_expression body END
    (59) for_loop -> . FOR ID IN range_incl body END
    (56) array -> . ID ASSIGN LCORCH elements RCORCH
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (60) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (11) class_def -> . CLASS ID body END
    (29) return_stmt -> . RETURN factor
    (30) break_stmt -> . BREAK
    (54) function_call_empty -> . ID LPAREN RPAREN
    (55) function_call_args -> . ID LPAREN args RPAREN
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    END             reduce using rule 8 (body -> sentence .)
    ELSE            reduce using rule 8 (body -> sentence .)
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    sentence                       shift and go to state 89
    body                           shift and go to state 110
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 90

    (63) while_loop -> WHILE logic_expression body . END

    END             shift and go to state 111


state 91

    (59) for_loop -> FOR ID IN . range_incl body END
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN

    LPAREN          shift and go to state 113

    range_incl                     shift and go to state 112

state 92

    (64) range_incl -> LPAREN INTEGER RANGE_INCL . INTEGER RPAREN

    INTEGER         shift and go to state 114


state 93

    (65) range_excl -> LPAREN INTEGER RANGE_EXCL . INTEGER RPAREN

    INTEGER         shift and go to state 115


state 94

    (52) factor -> LPAREN expression RPAREN .

    EQUALS          reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    NEQUALS         reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    GREATEREQ       reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    LESSEQ          reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    GREATERT        reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    LESST           reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    MODULE          reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    ID              reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    VAR_INST        reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    DEF             reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    CLASS           reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    STRING          reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    BOOLEAN         reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    NIL             reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    RCORCH          reduce using rule 52 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 52 (factor -> LPAREN expression RPAREN .)


state 95

    (4) function -> DEF ID body . END

    END             shift and go to state 116


state 96

    (5) function -> DEF ID LPAREN . args RPAREN body END
    (64) range_incl -> LPAREN . INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> LPAREN . INTEGER RANGE_EXCL INTEGER RPAREN
    (52) factor -> LPAREN . expression RPAREN
    (6) args -> . ID
    (7) args -> . ID COMMA args
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 68
    ID              shift and go to state 117
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    args                           shift and go to state 118
    expression                     shift and go to state 69
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 97

    (11) class_def -> CLASS ID body . END

    END             shift and go to state 119


state 98

    (34) input -> ID ASSIGN GETS DOT . ID

    ID              shift and go to state 120


state 99

    (56) array -> ID ASSIGN LCORCH elements . RCORCH

    RCORCH          shift and go to state 121


state 100

    (57) elements -> factor .
    (58) elements -> factor . COMMA elements
    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

    RCORCH          reduce using rule 57 (elements -> factor .)
    COMMA           shift and go to state 122
    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

    logic_op                       shift and go to state 57

state 101

    (60) hash -> ID ASSIGN LBRACE hash_pairs . RBRACE

    RBRACE          shift and go to state 123


state 102

    (61) hash_pairs -> STRING . COLON factor
    (62) hash_pairs -> STRING . COLON factor COMMA hash_pairs

    COLON           shift and go to state 124


state 103

    (7) args -> ID COMMA . args
    (6) args -> . ID
    (7) args -> . ID COMMA args

    ID              shift and go to state 79

    args                           shift and go to state 125

state 104

    (55) function_call_args -> ID LPAREN args RPAREN .

    ID              reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    VAR_INST        reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    PUTS            reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    IF              reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    WHILE           reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    FOR             reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    LPAREN          reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    DEF             reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    CLASS           reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    RETURN          reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    BREAK           reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    INTEGER         reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    FLOAT           reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    STRING          reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    BOOLEAN         reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    TRUE            reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    FALSE           reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    NIL             reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    $end            reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    END             reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)
    ELSE            reduce using rule 55 (function_call_args -> ID LPAREN args RPAREN .)


state 105

    (69) logic_expression -> factor logic_op factor logic_connector . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    factor                         shift and go to state 65
    logic_expression               shift and go to state 126

state 106

    (76) logic_connector -> AND .

    INTEGER         reduce using rule 76 (logic_connector -> AND .)
    FLOAT           reduce using rule 76 (logic_connector -> AND .)
    STRING          reduce using rule 76 (logic_connector -> AND .)
    BOOLEAN         reduce using rule 76 (logic_connector -> AND .)
    ID              reduce using rule 76 (logic_connector -> AND .)
    VAR_INST        reduce using rule 76 (logic_connector -> AND .)
    TRUE            reduce using rule 76 (logic_connector -> AND .)
    FALSE           reduce using rule 76 (logic_connector -> AND .)
    NIL             reduce using rule 76 (logic_connector -> AND .)
    LPAREN          reduce using rule 76 (logic_connector -> AND .)


state 107

    (77) logic_connector -> OR .

    INTEGER         reduce using rule 77 (logic_connector -> OR .)
    FLOAT           reduce using rule 77 (logic_connector -> OR .)
    STRING          reduce using rule 77 (logic_connector -> OR .)
    BOOLEAN         reduce using rule 77 (logic_connector -> OR .)
    ID              reduce using rule 77 (logic_connector -> OR .)
    VAR_INST        reduce using rule 77 (logic_connector -> OR .)
    TRUE            reduce using rule 77 (logic_connector -> OR .)
    FALSE           reduce using rule 77 (logic_connector -> OR .)
    NIL             reduce using rule 77 (logic_connector -> OR .)
    LPAREN          reduce using rule 77 (logic_connector -> OR .)


state 108

    (66) condition -> IF logic_expression body END .

    ID              reduce using rule 66 (condition -> IF logic_expression body END .)
    VAR_INST        reduce using rule 66 (condition -> IF logic_expression body END .)
    PUTS            reduce using rule 66 (condition -> IF logic_expression body END .)
    IF              reduce using rule 66 (condition -> IF logic_expression body END .)
    WHILE           reduce using rule 66 (condition -> IF logic_expression body END .)
    FOR             reduce using rule 66 (condition -> IF logic_expression body END .)
    LPAREN          reduce using rule 66 (condition -> IF logic_expression body END .)
    DEF             reduce using rule 66 (condition -> IF logic_expression body END .)
    CLASS           reduce using rule 66 (condition -> IF logic_expression body END .)
    RETURN          reduce using rule 66 (condition -> IF logic_expression body END .)
    BREAK           reduce using rule 66 (condition -> IF logic_expression body END .)
    INTEGER         reduce using rule 66 (condition -> IF logic_expression body END .)
    FLOAT           reduce using rule 66 (condition -> IF logic_expression body END .)
    STRING          reduce using rule 66 (condition -> IF logic_expression body END .)
    BOOLEAN         reduce using rule 66 (condition -> IF logic_expression body END .)
    TRUE            reduce using rule 66 (condition -> IF logic_expression body END .)
    FALSE           reduce using rule 66 (condition -> IF logic_expression body END .)
    NIL             reduce using rule 66 (condition -> IF logic_expression body END .)
    $end            reduce using rule 66 (condition -> IF logic_expression body END .)
    END             reduce using rule 66 (condition -> IF logic_expression body END .)
    ELSE            reduce using rule 66 (condition -> IF logic_expression body END .)


state 109

    (67) condition -> IF logic_expression body ELSE . body END
    (8) body -> . sentence
    (9) body -> . sentence body
    (12) sentence -> . assignment
    (13) sentence -> . expression
    (14) sentence -> . print
    (15) sentence -> . input
    (16) sentence -> . condition
    (17) sentence -> . while_loop
    (18) sentence -> . for_loop
    (19) sentence -> . array
    (20) sentence -> . range_incl
    (21) sentence -> . range_excl
    (22) sentence -> . hash
    (23) sentence -> . function
    (24) sentence -> . class_def
    (25) sentence -> . return_stmt
    (26) sentence -> . break_stmt
    (27) sentence -> . function_call_empty
    (28) sentence -> . function_call_args
    (31) assignment -> . ID ASSIGN expression
    (32) assignment -> . VAR_INST ASSIGN expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (10) print -> . PUTS factor
    (33) input -> . PUTS STRING
    (34) input -> . ID ASSIGN GETS DOT ID
    (66) condition -> . IF logic_expression body END
    (67) condition -> . IF logic_expression body ELSE body END
    (63) while_loop -> . WHILE logic_expression body END
    (59) for_loop -> . FOR ID IN range_incl body END
    (56) array -> . ID ASSIGN LCORCH elements RCORCH
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (60) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (11) class_def -> . CLASS ID body END
    (29) return_stmt -> . RETURN factor
    (30) break_stmt -> . BREAK
    (54) function_call_empty -> . ID LPAREN RPAREN
    (55) function_call_args -> . ID LPAREN args RPAREN
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    logic_expression               shift and go to state 28
    body                           shift and go to state 127
    sentence                       shift and go to state 89
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25

state 110

    (9) body -> sentence body .

    END             reduce using rule 9 (body -> sentence body .)
    ELSE            reduce using rule 9 (body -> sentence body .)


state 111

    (63) while_loop -> WHILE logic_expression body END .

    ID              reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    VAR_INST        reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    PUTS            reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    IF              reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    WHILE           reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    FOR             reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    LPAREN          reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    DEF             reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    CLASS           reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    RETURN          reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    BREAK           reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    INTEGER         reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    FLOAT           reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    STRING          reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    BOOLEAN         reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    TRUE            reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    FALSE           reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    NIL             reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    $end            reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    END             reduce using rule 63 (while_loop -> WHILE logic_expression body END .)
    ELSE            reduce using rule 63 (while_loop -> WHILE logic_expression body END .)


state 112

    (59) for_loop -> FOR ID IN range_incl . body END
    (8) body -> . sentence
    (9) body -> . sentence body
    (12) sentence -> . assignment
    (13) sentence -> . expression
    (14) sentence -> . print
    (15) sentence -> . input
    (16) sentence -> . condition
    (17) sentence -> . while_loop
    (18) sentence -> . for_loop
    (19) sentence -> . array
    (20) sentence -> . range_incl
    (21) sentence -> . range_excl
    (22) sentence -> . hash
    (23) sentence -> . function
    (24) sentence -> . class_def
    (25) sentence -> . return_stmt
    (26) sentence -> . break_stmt
    (27) sentence -> . function_call_empty
    (28) sentence -> . function_call_args
    (31) assignment -> . ID ASSIGN expression
    (32) assignment -> . VAR_INST ASSIGN expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (10) print -> . PUTS factor
    (33) input -> . PUTS STRING
    (34) input -> . ID ASSIGN GETS DOT ID
    (66) condition -> . IF logic_expression body END
    (67) condition -> . IF logic_expression body ELSE body END
    (63) while_loop -> . WHILE logic_expression body END
    (59) for_loop -> . FOR ID IN range_incl body END
    (56) array -> . ID ASSIGN LCORCH elements RCORCH
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (60) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (11) class_def -> . CLASS ID body END
    (29) return_stmt -> . RETURN factor
    (30) break_stmt -> . BREAK
    (54) function_call_empty -> . ID LPAREN RPAREN
    (55) function_call_args -> . ID LPAREN args RPAREN
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    range_incl                     shift and go to state 12
    body                           shift and go to state 128
    sentence                       shift and go to state 89
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 113

    (64) range_incl -> LPAREN . INTEGER RANGE_INCL INTEGER RPAREN

    INTEGER         shift and go to state 129


state 114

    (64) range_incl -> LPAREN INTEGER RANGE_INCL INTEGER . RPAREN

    RPAREN          shift and go to state 130


state 115

    (65) range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER . RPAREN

    RPAREN          shift and go to state 131


state 116

    (4) function -> DEF ID body END .

    ID              reduce using rule 4 (function -> DEF ID body END .)
    VAR_INST        reduce using rule 4 (function -> DEF ID body END .)
    PUTS            reduce using rule 4 (function -> DEF ID body END .)
    IF              reduce using rule 4 (function -> DEF ID body END .)
    WHILE           reduce using rule 4 (function -> DEF ID body END .)
    FOR             reduce using rule 4 (function -> DEF ID body END .)
    LPAREN          reduce using rule 4 (function -> DEF ID body END .)
    DEF             reduce using rule 4 (function -> DEF ID body END .)
    CLASS           reduce using rule 4 (function -> DEF ID body END .)
    RETURN          reduce using rule 4 (function -> DEF ID body END .)
    BREAK           reduce using rule 4 (function -> DEF ID body END .)
    INTEGER         reduce using rule 4 (function -> DEF ID body END .)
    FLOAT           reduce using rule 4 (function -> DEF ID body END .)
    STRING          reduce using rule 4 (function -> DEF ID body END .)
    BOOLEAN         reduce using rule 4 (function -> DEF ID body END .)
    TRUE            reduce using rule 4 (function -> DEF ID body END .)
    FALSE           reduce using rule 4 (function -> DEF ID body END .)
    NIL             reduce using rule 4 (function -> DEF ID body END .)
    $end            reduce using rule 4 (function -> DEF ID body END .)
    END             reduce using rule 4 (function -> DEF ID body END .)
    ELSE            reduce using rule 4 (function -> DEF ID body END .)


state 117

    (6) args -> ID .
    (7) args -> ID . COMMA args
    (47) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 6 (args -> ID .)
    RPAREN          reduce using rule 6 (args -> ID .)
    COMMA           shift and go to state 103
    EQUALS          reduce using rule 47 (factor -> ID .)
    NEQUALS         reduce using rule 47 (factor -> ID .)
    GREATEREQ       reduce using rule 47 (factor -> ID .)
    LESSEQ          reduce using rule 47 (factor -> ID .)
    GREATERT        reduce using rule 47 (factor -> ID .)
    LESST           reduce using rule 47 (factor -> ID .)
    TIMES           reduce using rule 47 (factor -> ID .)
    DIVIDE          reduce using rule 47 (factor -> ID .)
    EXPONENT        reduce using rule 47 (factor -> ID .)
    MODULE          reduce using rule 47 (factor -> ID .)
    PLUS            reduce using rule 47 (factor -> ID .)
    MINUS           reduce using rule 47 (factor -> ID .)

  ! RPAREN          [ reduce using rule 47 (factor -> ID .) ]


state 118

    (5) function -> DEF ID LPAREN args . RPAREN body END

    RPAREN          shift and go to state 132


state 119

    (11) class_def -> CLASS ID body END .

    ID              reduce using rule 11 (class_def -> CLASS ID body END .)
    VAR_INST        reduce using rule 11 (class_def -> CLASS ID body END .)
    PUTS            reduce using rule 11 (class_def -> CLASS ID body END .)
    IF              reduce using rule 11 (class_def -> CLASS ID body END .)
    WHILE           reduce using rule 11 (class_def -> CLASS ID body END .)
    FOR             reduce using rule 11 (class_def -> CLASS ID body END .)
    LPAREN          reduce using rule 11 (class_def -> CLASS ID body END .)
    DEF             reduce using rule 11 (class_def -> CLASS ID body END .)
    CLASS           reduce using rule 11 (class_def -> CLASS ID body END .)
    RETURN          reduce using rule 11 (class_def -> CLASS ID body END .)
    BREAK           reduce using rule 11 (class_def -> CLASS ID body END .)
    INTEGER         reduce using rule 11 (class_def -> CLASS ID body END .)
    FLOAT           reduce using rule 11 (class_def -> CLASS ID body END .)
    STRING          reduce using rule 11 (class_def -> CLASS ID body END .)
    BOOLEAN         reduce using rule 11 (class_def -> CLASS ID body END .)
    TRUE            reduce using rule 11 (class_def -> CLASS ID body END .)
    FALSE           reduce using rule 11 (class_def -> CLASS ID body END .)
    NIL             reduce using rule 11 (class_def -> CLASS ID body END .)
    $end            reduce using rule 11 (class_def -> CLASS ID body END .)
    END             reduce using rule 11 (class_def -> CLASS ID body END .)
    ELSE            reduce using rule 11 (class_def -> CLASS ID body END .)


state 120

    (34) input -> ID ASSIGN GETS DOT ID .

    ID              reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    VAR_INST        reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    PUTS            reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    IF              reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    WHILE           reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    FOR             reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    LPAREN          reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    DEF             reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    CLASS           reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    RETURN          reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    BREAK           reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    INTEGER         reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    FLOAT           reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    STRING          reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    BOOLEAN         reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    TRUE            reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    FALSE           reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    NIL             reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    $end            reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    END             reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)
    ELSE            reduce using rule 34 (input -> ID ASSIGN GETS DOT ID .)


state 121

    (56) array -> ID ASSIGN LCORCH elements RCORCH .

    ID              reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    VAR_INST        reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    PUTS            reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    IF              reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    WHILE           reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    FOR             reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    LPAREN          reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    DEF             reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    CLASS           reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    RETURN          reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    BREAK           reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    INTEGER         reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    FLOAT           reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    STRING          reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    BOOLEAN         reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    TRUE            reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    FALSE           reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    NIL             reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    $end            reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    END             reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)
    ELSE            reduce using rule 56 (array -> ID ASSIGN LCORCH elements RCORCH .)


state 122

    (58) elements -> factor COMMA . elements
    (57) elements -> . factor
    (58) elements -> . factor COMMA elements
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    factor                         shift and go to state 100
    elements                       shift and go to state 133
    logic_expression               shift and go to state 28

state 123

    (60) hash -> ID ASSIGN LBRACE hash_pairs RBRACE .

    ID              reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    VAR_INST        reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    PUTS            reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    IF              reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    WHILE           reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    FOR             reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    LPAREN          reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    DEF             reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    CLASS           reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    RETURN          reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    BREAK           reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    INTEGER         reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    FLOAT           reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    STRING          reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    BOOLEAN         reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    TRUE            reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    FALSE           reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    NIL             reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    $end            reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    END             reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    ELSE            reduce using rule 60 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)


state 124

    (61) hash_pairs -> STRING COLON . factor
    (62) hash_pairs -> STRING COLON . factor COMMA hash_pairs
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 54
    VAR_INST        shift and go to state 55
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 56

    factor                         shift and go to state 134
    logic_expression               shift and go to state 28

state 125

    (7) args -> ID COMMA args .

    RPAREN          reduce using rule 7 (args -> ID COMMA args .)


state 126

    (69) logic_expression -> factor logic_op factor logic_connector logic_expression .
    (53) factor -> logic_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 53 (factor -> logic_expression .)
  ! reduce/reduce conflict for NEQUALS resolved using rule 53 (factor -> logic_expression .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 53 (factor -> logic_expression .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 53 (factor -> logic_expression .)
  ! reduce/reduce conflict for GREATERT resolved using rule 53 (factor -> logic_expression .)
  ! reduce/reduce conflict for LESST resolved using rule 53 (factor -> logic_expression .)
    TIMES           reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    DIVIDE          reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    EXPONENT        reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    MODULE          reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    PLUS            reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    MINUS           reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    ID              reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    VAR_INST        reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    PUTS            reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    IF              reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    WHILE           reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    FOR             reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    LPAREN          reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    DEF             reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    CLASS           reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    RETURN          reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    BREAK           reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    INTEGER         reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    FLOAT           reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    STRING          reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    BOOLEAN         reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    TRUE            reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    FALSE           reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    NIL             reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    $end            reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    END             reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    ELSE            reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    RPAREN          reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    AND             reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    OR              reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    COMMA           reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    RCORCH          reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    RBRACE          reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    EQUALS          reduce using rule 53 (factor -> logic_expression .)
    NEQUALS         reduce using rule 53 (factor -> logic_expression .)
    GREATEREQ       reduce using rule 53 (factor -> logic_expression .)
    LESSEQ          reduce using rule 53 (factor -> logic_expression .)
    GREATERT        reduce using rule 53 (factor -> logic_expression .)
    LESST           reduce using rule 53 (factor -> logic_expression .)

  ! EQUALS          [ reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! NEQUALS         [ reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! GREATEREQ       [ reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! LESSEQ          [ reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! GREATERT        [ reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! LESST           [ reduce using rule 69 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]


state 127

    (67) condition -> IF logic_expression body ELSE body . END

    END             shift and go to state 135


state 128

    (59) for_loop -> FOR ID IN range_incl body . END

    END             shift and go to state 136


state 129

    (64) range_incl -> LPAREN INTEGER . RANGE_INCL INTEGER RPAREN

    RANGE_INCL      shift and go to state 92


state 130

    (64) range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .

    ID              reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    VAR_INST        reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    PUTS            reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    IF              reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    WHILE           reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    FOR             reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    LPAREN          reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    DEF             reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    CLASS           reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    RETURN          reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    BREAK           reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    INTEGER         reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    FLOAT           reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    STRING          reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    BOOLEAN         reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    TRUE            reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    FALSE           reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    NIL             reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    $end            reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    END             reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    ELSE            reduce using rule 64 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)


state 131

    (65) range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .

    ID              reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    VAR_INST        reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    PUTS            reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    IF              reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    WHILE           reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    FOR             reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    LPAREN          reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    DEF             reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    CLASS           reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    RETURN          reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    BREAK           reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    INTEGER         reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    FLOAT           reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    STRING          reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    BOOLEAN         reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    TRUE            reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    FALSE           reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    NIL             reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    $end            reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    END             reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    ELSE            reduce using rule 65 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)


state 132

    (5) function -> DEF ID LPAREN args RPAREN . body END
    (8) body -> . sentence
    (9) body -> . sentence body
    (12) sentence -> . assignment
    (13) sentence -> . expression
    (14) sentence -> . print
    (15) sentence -> . input
    (16) sentence -> . condition
    (17) sentence -> . while_loop
    (18) sentence -> . for_loop
    (19) sentence -> . array
    (20) sentence -> . range_incl
    (21) sentence -> . range_excl
    (22) sentence -> . hash
    (23) sentence -> . function
    (24) sentence -> . class_def
    (25) sentence -> . return_stmt
    (26) sentence -> . break_stmt
    (27) sentence -> . function_call_empty
    (28) sentence -> . function_call_args
    (31) assignment -> . ID ASSIGN expression
    (32) assignment -> . VAR_INST ASSIGN expression
    (35) expression -> . expression PLUS term
    (36) expression -> . expression MINUS term
    (37) expression -> . term
    (10) print -> . PUTS factor
    (33) input -> . PUTS STRING
    (34) input -> . ID ASSIGN GETS DOT ID
    (66) condition -> . IF logic_expression body END
    (67) condition -> . IF logic_expression body ELSE body END
    (63) while_loop -> . WHILE logic_expression body END
    (59) for_loop -> . FOR ID IN range_incl body END
    (56) array -> . ID ASSIGN LCORCH elements RCORCH
    (64) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (65) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (60) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (11) class_def -> . CLASS ID body END
    (29) return_stmt -> . RETURN factor
    (30) break_stmt -> . BREAK
    (54) function_call_empty -> . ID LPAREN RPAREN
    (55) function_call_args -> . ID LPAREN args RPAREN
    (38) term -> . term TIMES factor
    (39) term -> . term DIVIDE factor
    (40) term -> . term EXPONENT factor
    (41) term -> . term MODULE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . FLOAT
    (45) factor -> . STRING
    (46) factor -> . BOOLEAN
    (47) factor -> . ID
    (48) factor -> . VAR_INST
    (49) factor -> . TRUE
    (50) factor -> . FALSE
    (51) factor -> . NIL
    (52) factor -> . LPAREN expression RPAREN
    (53) factor -> . logic_expression
    (68) logic_expression -> . factor logic_op factor
    (69) logic_expression -> . factor logic_op factor logic_connector logic_expression

    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    INTEGER         shift and go to state 32
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    body                           shift and go to state 137
    sentence                       shift and go to state 89
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 133

    (58) elements -> factor COMMA elements .

    RCORCH          reduce using rule 58 (elements -> factor COMMA elements .)


state 134

    (61) hash_pairs -> STRING COLON factor .
    (62) hash_pairs -> STRING COLON factor . COMMA hash_pairs
    (68) logic_expression -> factor . logic_op factor
    (69) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (70) logic_op -> . EQUALS
    (71) logic_op -> . NEQUALS
    (72) logic_op -> . GREATEREQ
    (73) logic_op -> . LESSEQ
    (74) logic_op -> . GREATERT
    (75) logic_op -> . LESST

    RBRACE          reduce using rule 61 (hash_pairs -> STRING COLON factor .)
    COMMA           shift and go to state 138
    EQUALS          shift and go to state 58
    NEQUALS         shift and go to state 59
    GREATEREQ       shift and go to state 60
    LESSEQ          shift and go to state 61
    GREATERT        shift and go to state 62
    LESST           shift and go to state 63

    logic_op                       shift and go to state 57

state 135

    (67) condition -> IF logic_expression body ELSE body END .

    ID              reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    VAR_INST        reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    PUTS            reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    IF              reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    WHILE           reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    FOR             reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    LPAREN          reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    DEF             reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    CLASS           reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    RETURN          reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    BREAK           reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    INTEGER         reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    FLOAT           reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    STRING          reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    BOOLEAN         reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    TRUE            reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    FALSE           reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    NIL             reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    $end            reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    END             reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)
    ELSE            reduce using rule 67 (condition -> IF logic_expression body ELSE body END .)


state 136

    (59) for_loop -> FOR ID IN range_incl body END .

    ID              reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    VAR_INST        reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    PUTS            reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    IF              reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    WHILE           reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    FOR             reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    LPAREN          reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    DEF             reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    CLASS           reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    RETURN          reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    BREAK           reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    INTEGER         reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    FLOAT           reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    STRING          reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    BOOLEAN         reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    TRUE            reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    FALSE           reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    NIL             reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    $end            reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    END             reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)
    ELSE            reduce using rule 59 (for_loop -> FOR ID IN range_incl body END .)


state 137

    (5) function -> DEF ID LPAREN args RPAREN body . END

    END             shift and go to state 139


state 138

    (62) hash_pairs -> STRING COLON factor COMMA . hash_pairs
    (61) hash_pairs -> . STRING COLON factor
    (62) hash_pairs -> . STRING COLON factor COMMA hash_pairs

    STRING          shift and go to state 102

    hash_pairs                     shift and go to state 140

state 139

    (5) function -> DEF ID LPAREN args RPAREN body END .

    ID              reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    VAR_INST        reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    PUTS            reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    IF              reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    WHILE           reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    FOR             reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    LPAREN          reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    DEF             reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    CLASS           reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    RETURN          reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    BREAK           reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    INTEGER         reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    FLOAT           reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    STRING          reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    BOOLEAN         reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    TRUE            reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    FALSE           reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    NIL             reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    $end            reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    END             reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    ELSE            reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)


state 140

    (62) hash_pairs -> STRING COLON factor COMMA hash_pairs .

    RBRACE          reduce using rule 62 (hash_pairs -> STRING COLON factor COMMA hash_pairs .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 21 resolved as shift
WARNING: shift/reduce conflict for AND in state 87 resolved as shift
WARNING: shift/reduce conflict for OR in state 87 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 87 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 87 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 87 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 87 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 87 resolved as shift
WARNING: shift/reduce conflict for LESST in state 87 resolved as shift
WARNING: reduce/reduce conflict in state 53 resolved using rule (input -> PUTS STRING)
WARNING: rejected rule (factor -> STRING) in state 53
WARNING: reduce/reduce conflict in state 117 resolved using rule (args -> ID)
WARNING: rejected rule (factor -> ID) in state 117
WARNING: reduce/reduce conflict in state 126 resolved using rule (factor -> logic_expression)
WARNING: rejected rule (logic_expression -> factor logic_op factor logic_connector logic_expression) in state 126
