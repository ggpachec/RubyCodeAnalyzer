Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND_OP
    DO
    NEXT
    NOT
    NOT_OP
    OR_OP
    SEMICOLON
    THEN
    YIELD

Grammar

Rule 0     S' -> start
Rule 1     start -> sentences
Rule 2     sentences -> sentence
Rule 3     sentences -> sentence sentences
Rule 4     function -> DEF ID body END
Rule 5     function -> DEF ID LPAREN args RPAREN body END
Rule 6     args -> ID
Rule 7     args -> ID COMMA args
Rule 8     body -> body sentence
Rule 9     body -> sentence
Rule 10    print -> PUTS factor
Rule 11    print -> PUTS STRING
Rule 12    class_def -> CLASS ID body END
Rule 13    sentence -> assignment
Rule 14    sentence -> expression
Rule 15    sentence -> print
Rule 16    sentence -> input
Rule 17    sentence -> condition
Rule 18    sentence -> while_loop
Rule 19    sentence -> for_loop
Rule 20    sentence -> array
Rule 21    sentence -> range_incl
Rule 22    sentence -> range_excl
Rule 23    sentence -> hash
Rule 24    sentence -> function
Rule 25    sentence -> class_def
Rule 26    sentence -> return_stmt
Rule 27    sentence -> break_stmt
Rule 28    sentence -> function_call_empty
Rule 29    sentence -> function_call_args
Rule 30    return_stmt -> RETURN factor
Rule 31    break_stmt -> BREAK
Rule 32    assignment -> ID ASSIGN expression
Rule 33    assignment -> VAR_INST ASSIGN expression
Rule 34    input -> PUTS STRING
Rule 35    input -> ID ASSIGN GETS method_chain
Rule 36    method_chain -> DOT ID
Rule 37    method_chain -> method_chain DOT ID
Rule 38    expression -> expression PLUS term
Rule 39    expression -> expression MINUS term
Rule 40    expression -> term
Rule 41    term -> term TIMES factor
Rule 42    term -> term DIVIDE factor
Rule 43    term -> term EXPONENT factor
Rule 44    term -> term MODULE factor
Rule 45    term -> factor
Rule 46    factor -> INTEGER
Rule 47    factor -> FLOAT
Rule 48    factor -> STRING
Rule 49    factor -> BOOLEAN
Rule 50    factor -> ID
Rule 51    factor -> VAR_INST
Rule 52    factor -> TRUE
Rule 53    factor -> FALSE
Rule 54    factor -> NIL
Rule 55    factor -> LPAREN expression RPAREN
Rule 56    factor -> logic_expression
Rule 57    factor -> range_incl
Rule 58    factor -> range_excl
Rule 59    function_call_empty -> ID LPAREN RPAREN
Rule 60    function_call_args -> ID LPAREN args RPAREN
Rule 61    array -> ID ASSIGN LCORCH elements RCORCH
Rule 62    elements -> factor
Rule 63    elements -> factor COMMA elements
Rule 64    for_loop -> FOR ID IN range_incl body END
Rule 65    hash -> ID ASSIGN LBRACE hash_pairs RBRACE
Rule 66    hash_pairs -> STRING COLON factor
Rule 67    hash_pairs -> STRING COLON factor COMMA hash_pairs
Rule 68    while_loop -> WHILE logic_expression body END
Rule 69    range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN
Rule 70    range_incl -> INTEGER RANGE_INCL INTEGER
Rule 71    range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
Rule 72    range_excl -> INTEGER RANGE_EXCL INTEGER
Rule 73    condition -> IF logic_expression body END
Rule 74    condition -> IF logic_expression body ELSE body END
Rule 75    logic_expression -> factor logic_op factor
Rule 76    logic_expression -> factor logic_op factor logic_connector logic_expression
Rule 77    logic_expression -> expression logic_op expression
Rule 78    logic_op -> EQUALS
Rule 79    logic_op -> NEQUALS
Rule 80    logic_op -> GREATEREQ
Rule 81    logic_op -> LESSEQ
Rule 82    logic_op -> GREATERT
Rule 83    logic_op -> LESST
Rule 84    logic_connector -> AND
Rule 85    logic_connector -> OR

Terminals, with rules where they appear

AND                  : 84
AND_OP               : 
ASSIGN               : 32 33 35 61 65
BOOLEAN              : 49
BREAK                : 31
CLASS                : 12
COLON                : 66 67
COMMA                : 7 63 67
DEF                  : 4 5
DIVIDE               : 42
DO                   : 
DOT                  : 36 37
ELSE                 : 74
END                  : 4 5 12 64 68 73 74
EQUALS               : 78
EXPONENT             : 43
FALSE                : 53
FLOAT                : 47
FOR                  : 64
GETS                 : 35
GREATEREQ            : 80
GREATERT             : 82
ID                   : 4 5 6 7 12 32 35 36 37 50 59 60 61 64 65
IF                   : 73 74
IN                   : 64
INTEGER              : 46 69 69 70 70 71 71 72 72
LBRACE               : 65
LCORCH               : 61
LESSEQ               : 81
LESST                : 83
LPAREN               : 5 55 59 60 69 71
MINUS                : 39
MODULE               : 44
NEQUALS              : 79
NEXT                 : 
NIL                  : 54
NOT                  : 
NOT_OP               : 
OR                   : 85
OR_OP                : 
PLUS                 : 38
PUTS                 : 10 11 34
RANGE_EXCL           : 71 72
RANGE_INCL           : 69 70
RBRACE               : 65
RCORCH               : 61
RETURN               : 30
RPAREN               : 5 55 59 60 69 71
SEMICOLON            : 
STRING               : 11 34 48 66 67
THEN                 : 
TIMES                : 41
TRUE                 : 52
VAR_INST             : 33 51
WHILE                : 68
YIELD                : 
error                : 

Nonterminals, with rules where they appear

args                 : 5 7 60
array                : 20
assignment           : 13
body                 : 4 5 8 12 64 68 73 74 74
break_stmt           : 27
class_def            : 25
condition            : 17
elements             : 61 63
expression           : 14 32 33 38 39 55 77 77
factor               : 10 30 41 42 43 44 45 62 63 66 67 75 75 76 76
for_loop             : 19
function             : 24
function_call_args   : 29
function_call_empty  : 28
hash                 : 23
hash_pairs           : 65 67
input                : 16
logic_connector      : 76
logic_expression     : 56 68 73 74 76
logic_op             : 75 76 77
method_chain         : 35 37
print                : 15
range_excl           : 22 58
range_incl           : 21 57 64
return_stmt          : 26
sentence             : 2 3 8 9
sentences            : 1 3
start                : 0
term                 : 38 39 40 41 42 43 44
while_loop           : 18

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . sentences
    (2) sentences -> . sentence
    (3) sentences -> . sentence sentences
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    start                          shift and go to state 1
    sentences                      shift and go to state 2
    sentence                       shift and go to state 3
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 1

    (0) S' -> start .



state 2

    (1) start -> sentences .

    $end            reduce using rule 1 (start -> sentences .)


state 3

    (2) sentences -> sentence .
    (3) sentences -> sentence . sentences
    (2) sentences -> . sentence
    (3) sentences -> . sentence sentences
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    $end            reduce using rule 2 (sentences -> sentence .)
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    sentence                       shift and go to state 3
    sentences                      shift and go to state 42
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 4

    (13) sentence -> assignment .

    ID              reduce using rule 13 (sentence -> assignment .)
    VAR_INST        reduce using rule 13 (sentence -> assignment .)
    PUTS            reduce using rule 13 (sentence -> assignment .)
    IF              reduce using rule 13 (sentence -> assignment .)
    WHILE           reduce using rule 13 (sentence -> assignment .)
    FOR             reduce using rule 13 (sentence -> assignment .)
    LPAREN          reduce using rule 13 (sentence -> assignment .)
    INTEGER         reduce using rule 13 (sentence -> assignment .)
    DEF             reduce using rule 13 (sentence -> assignment .)
    CLASS           reduce using rule 13 (sentence -> assignment .)
    RETURN          reduce using rule 13 (sentence -> assignment .)
    BREAK           reduce using rule 13 (sentence -> assignment .)
    FLOAT           reduce using rule 13 (sentence -> assignment .)
    STRING          reduce using rule 13 (sentence -> assignment .)
    BOOLEAN         reduce using rule 13 (sentence -> assignment .)
    TRUE            reduce using rule 13 (sentence -> assignment .)
    FALSE           reduce using rule 13 (sentence -> assignment .)
    NIL             reduce using rule 13 (sentence -> assignment .)
    $end            reduce using rule 13 (sentence -> assignment .)
    END             reduce using rule 13 (sentence -> assignment .)
    ELSE            reduce using rule 13 (sentence -> assignment .)


state 5

    (14) sentence -> expression .
    (38) expression -> expression . PLUS term
    (39) expression -> expression . MINUS term
    (77) logic_expression -> expression . logic_op expression
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

    ID              reduce using rule 14 (sentence -> expression .)
    VAR_INST        reduce using rule 14 (sentence -> expression .)
    PUTS            reduce using rule 14 (sentence -> expression .)
    IF              reduce using rule 14 (sentence -> expression .)
    WHILE           reduce using rule 14 (sentence -> expression .)
    FOR             reduce using rule 14 (sentence -> expression .)
    LPAREN          reduce using rule 14 (sentence -> expression .)
    INTEGER         reduce using rule 14 (sentence -> expression .)
    DEF             reduce using rule 14 (sentence -> expression .)
    CLASS           reduce using rule 14 (sentence -> expression .)
    RETURN          reduce using rule 14 (sentence -> expression .)
    BREAK           reduce using rule 14 (sentence -> expression .)
    FLOAT           reduce using rule 14 (sentence -> expression .)
    STRING          reduce using rule 14 (sentence -> expression .)
    BOOLEAN         reduce using rule 14 (sentence -> expression .)
    TRUE            reduce using rule 14 (sentence -> expression .)
    FALSE           reduce using rule 14 (sentence -> expression .)
    NIL             reduce using rule 14 (sentence -> expression .)
    $end            reduce using rule 14 (sentence -> expression .)
    END             reduce using rule 14 (sentence -> expression .)
    ELSE            reduce using rule 14 (sentence -> expression .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

    logic_op                       shift and go to state 45

state 6

    (15) sentence -> print .

    ID              reduce using rule 15 (sentence -> print .)
    VAR_INST        reduce using rule 15 (sentence -> print .)
    PUTS            reduce using rule 15 (sentence -> print .)
    IF              reduce using rule 15 (sentence -> print .)
    WHILE           reduce using rule 15 (sentence -> print .)
    FOR             reduce using rule 15 (sentence -> print .)
    LPAREN          reduce using rule 15 (sentence -> print .)
    INTEGER         reduce using rule 15 (sentence -> print .)
    DEF             reduce using rule 15 (sentence -> print .)
    CLASS           reduce using rule 15 (sentence -> print .)
    RETURN          reduce using rule 15 (sentence -> print .)
    BREAK           reduce using rule 15 (sentence -> print .)
    FLOAT           reduce using rule 15 (sentence -> print .)
    STRING          reduce using rule 15 (sentence -> print .)
    BOOLEAN         reduce using rule 15 (sentence -> print .)
    TRUE            reduce using rule 15 (sentence -> print .)
    FALSE           reduce using rule 15 (sentence -> print .)
    NIL             reduce using rule 15 (sentence -> print .)
    $end            reduce using rule 15 (sentence -> print .)
    END             reduce using rule 15 (sentence -> print .)
    ELSE            reduce using rule 15 (sentence -> print .)


state 7

    (16) sentence -> input .

    ID              reduce using rule 16 (sentence -> input .)
    VAR_INST        reduce using rule 16 (sentence -> input .)
    PUTS            reduce using rule 16 (sentence -> input .)
    IF              reduce using rule 16 (sentence -> input .)
    WHILE           reduce using rule 16 (sentence -> input .)
    FOR             reduce using rule 16 (sentence -> input .)
    LPAREN          reduce using rule 16 (sentence -> input .)
    INTEGER         reduce using rule 16 (sentence -> input .)
    DEF             reduce using rule 16 (sentence -> input .)
    CLASS           reduce using rule 16 (sentence -> input .)
    RETURN          reduce using rule 16 (sentence -> input .)
    BREAK           reduce using rule 16 (sentence -> input .)
    FLOAT           reduce using rule 16 (sentence -> input .)
    STRING          reduce using rule 16 (sentence -> input .)
    BOOLEAN         reduce using rule 16 (sentence -> input .)
    TRUE            reduce using rule 16 (sentence -> input .)
    FALSE           reduce using rule 16 (sentence -> input .)
    NIL             reduce using rule 16 (sentence -> input .)
    $end            reduce using rule 16 (sentence -> input .)
    END             reduce using rule 16 (sentence -> input .)
    ELSE            reduce using rule 16 (sentence -> input .)


state 8

    (17) sentence -> condition .

    ID              reduce using rule 17 (sentence -> condition .)
    VAR_INST        reduce using rule 17 (sentence -> condition .)
    PUTS            reduce using rule 17 (sentence -> condition .)
    IF              reduce using rule 17 (sentence -> condition .)
    WHILE           reduce using rule 17 (sentence -> condition .)
    FOR             reduce using rule 17 (sentence -> condition .)
    LPAREN          reduce using rule 17 (sentence -> condition .)
    INTEGER         reduce using rule 17 (sentence -> condition .)
    DEF             reduce using rule 17 (sentence -> condition .)
    CLASS           reduce using rule 17 (sentence -> condition .)
    RETURN          reduce using rule 17 (sentence -> condition .)
    BREAK           reduce using rule 17 (sentence -> condition .)
    FLOAT           reduce using rule 17 (sentence -> condition .)
    STRING          reduce using rule 17 (sentence -> condition .)
    BOOLEAN         reduce using rule 17 (sentence -> condition .)
    TRUE            reduce using rule 17 (sentence -> condition .)
    FALSE           reduce using rule 17 (sentence -> condition .)
    NIL             reduce using rule 17 (sentence -> condition .)
    $end            reduce using rule 17 (sentence -> condition .)
    END             reduce using rule 17 (sentence -> condition .)
    ELSE            reduce using rule 17 (sentence -> condition .)


state 9

    (18) sentence -> while_loop .

    ID              reduce using rule 18 (sentence -> while_loop .)
    VAR_INST        reduce using rule 18 (sentence -> while_loop .)
    PUTS            reduce using rule 18 (sentence -> while_loop .)
    IF              reduce using rule 18 (sentence -> while_loop .)
    WHILE           reduce using rule 18 (sentence -> while_loop .)
    FOR             reduce using rule 18 (sentence -> while_loop .)
    LPAREN          reduce using rule 18 (sentence -> while_loop .)
    INTEGER         reduce using rule 18 (sentence -> while_loop .)
    DEF             reduce using rule 18 (sentence -> while_loop .)
    CLASS           reduce using rule 18 (sentence -> while_loop .)
    RETURN          reduce using rule 18 (sentence -> while_loop .)
    BREAK           reduce using rule 18 (sentence -> while_loop .)
    FLOAT           reduce using rule 18 (sentence -> while_loop .)
    STRING          reduce using rule 18 (sentence -> while_loop .)
    BOOLEAN         reduce using rule 18 (sentence -> while_loop .)
    TRUE            reduce using rule 18 (sentence -> while_loop .)
    FALSE           reduce using rule 18 (sentence -> while_loop .)
    NIL             reduce using rule 18 (sentence -> while_loop .)
    $end            reduce using rule 18 (sentence -> while_loop .)
    END             reduce using rule 18 (sentence -> while_loop .)
    ELSE            reduce using rule 18 (sentence -> while_loop .)


state 10

    (19) sentence -> for_loop .

    ID              reduce using rule 19 (sentence -> for_loop .)
    VAR_INST        reduce using rule 19 (sentence -> for_loop .)
    PUTS            reduce using rule 19 (sentence -> for_loop .)
    IF              reduce using rule 19 (sentence -> for_loop .)
    WHILE           reduce using rule 19 (sentence -> for_loop .)
    FOR             reduce using rule 19 (sentence -> for_loop .)
    LPAREN          reduce using rule 19 (sentence -> for_loop .)
    INTEGER         reduce using rule 19 (sentence -> for_loop .)
    DEF             reduce using rule 19 (sentence -> for_loop .)
    CLASS           reduce using rule 19 (sentence -> for_loop .)
    RETURN          reduce using rule 19 (sentence -> for_loop .)
    BREAK           reduce using rule 19 (sentence -> for_loop .)
    FLOAT           reduce using rule 19 (sentence -> for_loop .)
    STRING          reduce using rule 19 (sentence -> for_loop .)
    BOOLEAN         reduce using rule 19 (sentence -> for_loop .)
    TRUE            reduce using rule 19 (sentence -> for_loop .)
    FALSE           reduce using rule 19 (sentence -> for_loop .)
    NIL             reduce using rule 19 (sentence -> for_loop .)
    $end            reduce using rule 19 (sentence -> for_loop .)
    END             reduce using rule 19 (sentence -> for_loop .)
    ELSE            reduce using rule 19 (sentence -> for_loop .)


state 11

    (20) sentence -> array .

    ID              reduce using rule 20 (sentence -> array .)
    VAR_INST        reduce using rule 20 (sentence -> array .)
    PUTS            reduce using rule 20 (sentence -> array .)
    IF              reduce using rule 20 (sentence -> array .)
    WHILE           reduce using rule 20 (sentence -> array .)
    FOR             reduce using rule 20 (sentence -> array .)
    LPAREN          reduce using rule 20 (sentence -> array .)
    INTEGER         reduce using rule 20 (sentence -> array .)
    DEF             reduce using rule 20 (sentence -> array .)
    CLASS           reduce using rule 20 (sentence -> array .)
    RETURN          reduce using rule 20 (sentence -> array .)
    BREAK           reduce using rule 20 (sentence -> array .)
    FLOAT           reduce using rule 20 (sentence -> array .)
    STRING          reduce using rule 20 (sentence -> array .)
    BOOLEAN         reduce using rule 20 (sentence -> array .)
    TRUE            reduce using rule 20 (sentence -> array .)
    FALSE           reduce using rule 20 (sentence -> array .)
    NIL             reduce using rule 20 (sentence -> array .)
    $end            reduce using rule 20 (sentence -> array .)
    END             reduce using rule 20 (sentence -> array .)
    ELSE            reduce using rule 20 (sentence -> array .)


state 12

    (21) sentence -> range_incl .
    (57) factor -> range_incl .

  ! reduce/reduce conflict for ID resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for VAR_INST resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for PUTS resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for IF resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for WHILE resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for FOR resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for LPAREN resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for INTEGER resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for DEF resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for CLASS resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for RETURN resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for BREAK resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for FLOAT resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for STRING resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for TRUE resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for FALSE resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for NIL resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for $end resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for END resolved using rule 21 (sentence -> range_incl .)
  ! reduce/reduce conflict for ELSE resolved using rule 21 (sentence -> range_incl .)
    ID              reduce using rule 21 (sentence -> range_incl .)
    VAR_INST        reduce using rule 21 (sentence -> range_incl .)
    PUTS            reduce using rule 21 (sentence -> range_incl .)
    IF              reduce using rule 21 (sentence -> range_incl .)
    WHILE           reduce using rule 21 (sentence -> range_incl .)
    FOR             reduce using rule 21 (sentence -> range_incl .)
    LPAREN          reduce using rule 21 (sentence -> range_incl .)
    INTEGER         reduce using rule 21 (sentence -> range_incl .)
    DEF             reduce using rule 21 (sentence -> range_incl .)
    CLASS           reduce using rule 21 (sentence -> range_incl .)
    RETURN          reduce using rule 21 (sentence -> range_incl .)
    BREAK           reduce using rule 21 (sentence -> range_incl .)
    FLOAT           reduce using rule 21 (sentence -> range_incl .)
    STRING          reduce using rule 21 (sentence -> range_incl .)
    BOOLEAN         reduce using rule 21 (sentence -> range_incl .)
    TRUE            reduce using rule 21 (sentence -> range_incl .)
    FALSE           reduce using rule 21 (sentence -> range_incl .)
    NIL             reduce using rule 21 (sentence -> range_incl .)
    $end            reduce using rule 21 (sentence -> range_incl .)
    END             reduce using rule 21 (sentence -> range_incl .)
    ELSE            reduce using rule 21 (sentence -> range_incl .)
    EQUALS          reduce using rule 57 (factor -> range_incl .)
    NEQUALS         reduce using rule 57 (factor -> range_incl .)
    GREATEREQ       reduce using rule 57 (factor -> range_incl .)
    LESSEQ          reduce using rule 57 (factor -> range_incl .)
    GREATERT        reduce using rule 57 (factor -> range_incl .)
    LESST           reduce using rule 57 (factor -> range_incl .)
    TIMES           reduce using rule 57 (factor -> range_incl .)
    DIVIDE          reduce using rule 57 (factor -> range_incl .)
    EXPONENT        reduce using rule 57 (factor -> range_incl .)
    MODULE          reduce using rule 57 (factor -> range_incl .)
    PLUS            reduce using rule 57 (factor -> range_incl .)
    MINUS           reduce using rule 57 (factor -> range_incl .)

  ! ID              [ reduce using rule 57 (factor -> range_incl .) ]
  ! VAR_INST        [ reduce using rule 57 (factor -> range_incl .) ]
  ! PUTS            [ reduce using rule 57 (factor -> range_incl .) ]
  ! IF              [ reduce using rule 57 (factor -> range_incl .) ]
  ! WHILE           [ reduce using rule 57 (factor -> range_incl .) ]
  ! FOR             [ reduce using rule 57 (factor -> range_incl .) ]
  ! LPAREN          [ reduce using rule 57 (factor -> range_incl .) ]
  ! INTEGER         [ reduce using rule 57 (factor -> range_incl .) ]
  ! DEF             [ reduce using rule 57 (factor -> range_incl .) ]
  ! CLASS           [ reduce using rule 57 (factor -> range_incl .) ]
  ! RETURN          [ reduce using rule 57 (factor -> range_incl .) ]
  ! BREAK           [ reduce using rule 57 (factor -> range_incl .) ]
  ! FLOAT           [ reduce using rule 57 (factor -> range_incl .) ]
  ! STRING          [ reduce using rule 57 (factor -> range_incl .) ]
  ! BOOLEAN         [ reduce using rule 57 (factor -> range_incl .) ]
  ! TRUE            [ reduce using rule 57 (factor -> range_incl .) ]
  ! FALSE           [ reduce using rule 57 (factor -> range_incl .) ]
  ! NIL             [ reduce using rule 57 (factor -> range_incl .) ]
  ! $end            [ reduce using rule 57 (factor -> range_incl .) ]
  ! END             [ reduce using rule 57 (factor -> range_incl .) ]
  ! ELSE            [ reduce using rule 57 (factor -> range_incl .) ]


state 13

    (22) sentence -> range_excl .
    (58) factor -> range_excl .

  ! reduce/reduce conflict for ID resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for VAR_INST resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for PUTS resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for IF resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for WHILE resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for FOR resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for LPAREN resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for INTEGER resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for DEF resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for CLASS resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for RETURN resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for BREAK resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for FLOAT resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for STRING resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for TRUE resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for FALSE resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for NIL resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for $end resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for END resolved using rule 22 (sentence -> range_excl .)
  ! reduce/reduce conflict for ELSE resolved using rule 22 (sentence -> range_excl .)
    ID              reduce using rule 22 (sentence -> range_excl .)
    VAR_INST        reduce using rule 22 (sentence -> range_excl .)
    PUTS            reduce using rule 22 (sentence -> range_excl .)
    IF              reduce using rule 22 (sentence -> range_excl .)
    WHILE           reduce using rule 22 (sentence -> range_excl .)
    FOR             reduce using rule 22 (sentence -> range_excl .)
    LPAREN          reduce using rule 22 (sentence -> range_excl .)
    INTEGER         reduce using rule 22 (sentence -> range_excl .)
    DEF             reduce using rule 22 (sentence -> range_excl .)
    CLASS           reduce using rule 22 (sentence -> range_excl .)
    RETURN          reduce using rule 22 (sentence -> range_excl .)
    BREAK           reduce using rule 22 (sentence -> range_excl .)
    FLOAT           reduce using rule 22 (sentence -> range_excl .)
    STRING          reduce using rule 22 (sentence -> range_excl .)
    BOOLEAN         reduce using rule 22 (sentence -> range_excl .)
    TRUE            reduce using rule 22 (sentence -> range_excl .)
    FALSE           reduce using rule 22 (sentence -> range_excl .)
    NIL             reduce using rule 22 (sentence -> range_excl .)
    $end            reduce using rule 22 (sentence -> range_excl .)
    END             reduce using rule 22 (sentence -> range_excl .)
    ELSE            reduce using rule 22 (sentence -> range_excl .)
    EQUALS          reduce using rule 58 (factor -> range_excl .)
    NEQUALS         reduce using rule 58 (factor -> range_excl .)
    GREATEREQ       reduce using rule 58 (factor -> range_excl .)
    LESSEQ          reduce using rule 58 (factor -> range_excl .)
    GREATERT        reduce using rule 58 (factor -> range_excl .)
    LESST           reduce using rule 58 (factor -> range_excl .)
    TIMES           reduce using rule 58 (factor -> range_excl .)
    DIVIDE          reduce using rule 58 (factor -> range_excl .)
    EXPONENT        reduce using rule 58 (factor -> range_excl .)
    MODULE          reduce using rule 58 (factor -> range_excl .)
    PLUS            reduce using rule 58 (factor -> range_excl .)
    MINUS           reduce using rule 58 (factor -> range_excl .)

  ! ID              [ reduce using rule 58 (factor -> range_excl .) ]
  ! VAR_INST        [ reduce using rule 58 (factor -> range_excl .) ]
  ! PUTS            [ reduce using rule 58 (factor -> range_excl .) ]
  ! IF              [ reduce using rule 58 (factor -> range_excl .) ]
  ! WHILE           [ reduce using rule 58 (factor -> range_excl .) ]
  ! FOR             [ reduce using rule 58 (factor -> range_excl .) ]
  ! LPAREN          [ reduce using rule 58 (factor -> range_excl .) ]
  ! INTEGER         [ reduce using rule 58 (factor -> range_excl .) ]
  ! DEF             [ reduce using rule 58 (factor -> range_excl .) ]
  ! CLASS           [ reduce using rule 58 (factor -> range_excl .) ]
  ! RETURN          [ reduce using rule 58 (factor -> range_excl .) ]
  ! BREAK           [ reduce using rule 58 (factor -> range_excl .) ]
  ! FLOAT           [ reduce using rule 58 (factor -> range_excl .) ]
  ! STRING          [ reduce using rule 58 (factor -> range_excl .) ]
  ! BOOLEAN         [ reduce using rule 58 (factor -> range_excl .) ]
  ! TRUE            [ reduce using rule 58 (factor -> range_excl .) ]
  ! FALSE           [ reduce using rule 58 (factor -> range_excl .) ]
  ! NIL             [ reduce using rule 58 (factor -> range_excl .) ]
  ! $end            [ reduce using rule 58 (factor -> range_excl .) ]
  ! END             [ reduce using rule 58 (factor -> range_excl .) ]
  ! ELSE            [ reduce using rule 58 (factor -> range_excl .) ]


state 14

    (23) sentence -> hash .

    ID              reduce using rule 23 (sentence -> hash .)
    VAR_INST        reduce using rule 23 (sentence -> hash .)
    PUTS            reduce using rule 23 (sentence -> hash .)
    IF              reduce using rule 23 (sentence -> hash .)
    WHILE           reduce using rule 23 (sentence -> hash .)
    FOR             reduce using rule 23 (sentence -> hash .)
    LPAREN          reduce using rule 23 (sentence -> hash .)
    INTEGER         reduce using rule 23 (sentence -> hash .)
    DEF             reduce using rule 23 (sentence -> hash .)
    CLASS           reduce using rule 23 (sentence -> hash .)
    RETURN          reduce using rule 23 (sentence -> hash .)
    BREAK           reduce using rule 23 (sentence -> hash .)
    FLOAT           reduce using rule 23 (sentence -> hash .)
    STRING          reduce using rule 23 (sentence -> hash .)
    BOOLEAN         reduce using rule 23 (sentence -> hash .)
    TRUE            reduce using rule 23 (sentence -> hash .)
    FALSE           reduce using rule 23 (sentence -> hash .)
    NIL             reduce using rule 23 (sentence -> hash .)
    $end            reduce using rule 23 (sentence -> hash .)
    END             reduce using rule 23 (sentence -> hash .)
    ELSE            reduce using rule 23 (sentence -> hash .)


state 15

    (24) sentence -> function .

    ID              reduce using rule 24 (sentence -> function .)
    VAR_INST        reduce using rule 24 (sentence -> function .)
    PUTS            reduce using rule 24 (sentence -> function .)
    IF              reduce using rule 24 (sentence -> function .)
    WHILE           reduce using rule 24 (sentence -> function .)
    FOR             reduce using rule 24 (sentence -> function .)
    LPAREN          reduce using rule 24 (sentence -> function .)
    INTEGER         reduce using rule 24 (sentence -> function .)
    DEF             reduce using rule 24 (sentence -> function .)
    CLASS           reduce using rule 24 (sentence -> function .)
    RETURN          reduce using rule 24 (sentence -> function .)
    BREAK           reduce using rule 24 (sentence -> function .)
    FLOAT           reduce using rule 24 (sentence -> function .)
    STRING          reduce using rule 24 (sentence -> function .)
    BOOLEAN         reduce using rule 24 (sentence -> function .)
    TRUE            reduce using rule 24 (sentence -> function .)
    FALSE           reduce using rule 24 (sentence -> function .)
    NIL             reduce using rule 24 (sentence -> function .)
    $end            reduce using rule 24 (sentence -> function .)
    END             reduce using rule 24 (sentence -> function .)
    ELSE            reduce using rule 24 (sentence -> function .)


state 16

    (25) sentence -> class_def .

    ID              reduce using rule 25 (sentence -> class_def .)
    VAR_INST        reduce using rule 25 (sentence -> class_def .)
    PUTS            reduce using rule 25 (sentence -> class_def .)
    IF              reduce using rule 25 (sentence -> class_def .)
    WHILE           reduce using rule 25 (sentence -> class_def .)
    FOR             reduce using rule 25 (sentence -> class_def .)
    LPAREN          reduce using rule 25 (sentence -> class_def .)
    INTEGER         reduce using rule 25 (sentence -> class_def .)
    DEF             reduce using rule 25 (sentence -> class_def .)
    CLASS           reduce using rule 25 (sentence -> class_def .)
    RETURN          reduce using rule 25 (sentence -> class_def .)
    BREAK           reduce using rule 25 (sentence -> class_def .)
    FLOAT           reduce using rule 25 (sentence -> class_def .)
    STRING          reduce using rule 25 (sentence -> class_def .)
    BOOLEAN         reduce using rule 25 (sentence -> class_def .)
    TRUE            reduce using rule 25 (sentence -> class_def .)
    FALSE           reduce using rule 25 (sentence -> class_def .)
    NIL             reduce using rule 25 (sentence -> class_def .)
    $end            reduce using rule 25 (sentence -> class_def .)
    END             reduce using rule 25 (sentence -> class_def .)
    ELSE            reduce using rule 25 (sentence -> class_def .)


state 17

    (26) sentence -> return_stmt .

    ID              reduce using rule 26 (sentence -> return_stmt .)
    VAR_INST        reduce using rule 26 (sentence -> return_stmt .)
    PUTS            reduce using rule 26 (sentence -> return_stmt .)
    IF              reduce using rule 26 (sentence -> return_stmt .)
    WHILE           reduce using rule 26 (sentence -> return_stmt .)
    FOR             reduce using rule 26 (sentence -> return_stmt .)
    LPAREN          reduce using rule 26 (sentence -> return_stmt .)
    INTEGER         reduce using rule 26 (sentence -> return_stmt .)
    DEF             reduce using rule 26 (sentence -> return_stmt .)
    CLASS           reduce using rule 26 (sentence -> return_stmt .)
    RETURN          reduce using rule 26 (sentence -> return_stmt .)
    BREAK           reduce using rule 26 (sentence -> return_stmt .)
    FLOAT           reduce using rule 26 (sentence -> return_stmt .)
    STRING          reduce using rule 26 (sentence -> return_stmt .)
    BOOLEAN         reduce using rule 26 (sentence -> return_stmt .)
    TRUE            reduce using rule 26 (sentence -> return_stmt .)
    FALSE           reduce using rule 26 (sentence -> return_stmt .)
    NIL             reduce using rule 26 (sentence -> return_stmt .)
    $end            reduce using rule 26 (sentence -> return_stmt .)
    END             reduce using rule 26 (sentence -> return_stmt .)
    ELSE            reduce using rule 26 (sentence -> return_stmt .)


state 18

    (27) sentence -> break_stmt .

    ID              reduce using rule 27 (sentence -> break_stmt .)
    VAR_INST        reduce using rule 27 (sentence -> break_stmt .)
    PUTS            reduce using rule 27 (sentence -> break_stmt .)
    IF              reduce using rule 27 (sentence -> break_stmt .)
    WHILE           reduce using rule 27 (sentence -> break_stmt .)
    FOR             reduce using rule 27 (sentence -> break_stmt .)
    LPAREN          reduce using rule 27 (sentence -> break_stmt .)
    INTEGER         reduce using rule 27 (sentence -> break_stmt .)
    DEF             reduce using rule 27 (sentence -> break_stmt .)
    CLASS           reduce using rule 27 (sentence -> break_stmt .)
    RETURN          reduce using rule 27 (sentence -> break_stmt .)
    BREAK           reduce using rule 27 (sentence -> break_stmt .)
    FLOAT           reduce using rule 27 (sentence -> break_stmt .)
    STRING          reduce using rule 27 (sentence -> break_stmt .)
    BOOLEAN         reduce using rule 27 (sentence -> break_stmt .)
    TRUE            reduce using rule 27 (sentence -> break_stmt .)
    FALSE           reduce using rule 27 (sentence -> break_stmt .)
    NIL             reduce using rule 27 (sentence -> break_stmt .)
    $end            reduce using rule 27 (sentence -> break_stmt .)
    END             reduce using rule 27 (sentence -> break_stmt .)
    ELSE            reduce using rule 27 (sentence -> break_stmt .)


state 19

    (28) sentence -> function_call_empty .

    ID              reduce using rule 28 (sentence -> function_call_empty .)
    VAR_INST        reduce using rule 28 (sentence -> function_call_empty .)
    PUTS            reduce using rule 28 (sentence -> function_call_empty .)
    IF              reduce using rule 28 (sentence -> function_call_empty .)
    WHILE           reduce using rule 28 (sentence -> function_call_empty .)
    FOR             reduce using rule 28 (sentence -> function_call_empty .)
    LPAREN          reduce using rule 28 (sentence -> function_call_empty .)
    INTEGER         reduce using rule 28 (sentence -> function_call_empty .)
    DEF             reduce using rule 28 (sentence -> function_call_empty .)
    CLASS           reduce using rule 28 (sentence -> function_call_empty .)
    RETURN          reduce using rule 28 (sentence -> function_call_empty .)
    BREAK           reduce using rule 28 (sentence -> function_call_empty .)
    FLOAT           reduce using rule 28 (sentence -> function_call_empty .)
    STRING          reduce using rule 28 (sentence -> function_call_empty .)
    BOOLEAN         reduce using rule 28 (sentence -> function_call_empty .)
    TRUE            reduce using rule 28 (sentence -> function_call_empty .)
    FALSE           reduce using rule 28 (sentence -> function_call_empty .)
    NIL             reduce using rule 28 (sentence -> function_call_empty .)
    $end            reduce using rule 28 (sentence -> function_call_empty .)
    END             reduce using rule 28 (sentence -> function_call_empty .)
    ELSE            reduce using rule 28 (sentence -> function_call_empty .)


state 20

    (29) sentence -> function_call_args .

    ID              reduce using rule 29 (sentence -> function_call_args .)
    VAR_INST        reduce using rule 29 (sentence -> function_call_args .)
    PUTS            reduce using rule 29 (sentence -> function_call_args .)
    IF              reduce using rule 29 (sentence -> function_call_args .)
    WHILE           reduce using rule 29 (sentence -> function_call_args .)
    FOR             reduce using rule 29 (sentence -> function_call_args .)
    LPAREN          reduce using rule 29 (sentence -> function_call_args .)
    INTEGER         reduce using rule 29 (sentence -> function_call_args .)
    DEF             reduce using rule 29 (sentence -> function_call_args .)
    CLASS           reduce using rule 29 (sentence -> function_call_args .)
    RETURN          reduce using rule 29 (sentence -> function_call_args .)
    BREAK           reduce using rule 29 (sentence -> function_call_args .)
    FLOAT           reduce using rule 29 (sentence -> function_call_args .)
    STRING          reduce using rule 29 (sentence -> function_call_args .)
    BOOLEAN         reduce using rule 29 (sentence -> function_call_args .)
    TRUE            reduce using rule 29 (sentence -> function_call_args .)
    FALSE           reduce using rule 29 (sentence -> function_call_args .)
    NIL             reduce using rule 29 (sentence -> function_call_args .)
    $end            reduce using rule 29 (sentence -> function_call_args .)
    END             reduce using rule 29 (sentence -> function_call_args .)
    ELSE            reduce using rule 29 (sentence -> function_call_args .)


state 21

    (32) assignment -> ID . ASSIGN expression
    (35) input -> ID . ASSIGN GETS method_chain
    (61) array -> ID . ASSIGN LCORCH elements RCORCH
    (65) hash -> ID . ASSIGN LBRACE hash_pairs RBRACE
    (59) function_call_empty -> ID . LPAREN RPAREN
    (60) function_call_args -> ID . LPAREN args RPAREN
    (50) factor -> ID .

  ! shift/reduce conflict for LPAREN resolved as shift
    ASSIGN          shift and go to state 52
    LPAREN          shift and go to state 53
    EQUALS          reduce using rule 50 (factor -> ID .)
    NEQUALS         reduce using rule 50 (factor -> ID .)
    GREATEREQ       reduce using rule 50 (factor -> ID .)
    LESSEQ          reduce using rule 50 (factor -> ID .)
    GREATERT        reduce using rule 50 (factor -> ID .)
    LESST           reduce using rule 50 (factor -> ID .)
    TIMES           reduce using rule 50 (factor -> ID .)
    DIVIDE          reduce using rule 50 (factor -> ID .)
    EXPONENT        reduce using rule 50 (factor -> ID .)
    MODULE          reduce using rule 50 (factor -> ID .)
    PLUS            reduce using rule 50 (factor -> ID .)
    MINUS           reduce using rule 50 (factor -> ID .)
    ID              reduce using rule 50 (factor -> ID .)
    VAR_INST        reduce using rule 50 (factor -> ID .)
    PUTS            reduce using rule 50 (factor -> ID .)
    IF              reduce using rule 50 (factor -> ID .)
    WHILE           reduce using rule 50 (factor -> ID .)
    FOR             reduce using rule 50 (factor -> ID .)
    INTEGER         reduce using rule 50 (factor -> ID .)
    DEF             reduce using rule 50 (factor -> ID .)
    CLASS           reduce using rule 50 (factor -> ID .)
    RETURN          reduce using rule 50 (factor -> ID .)
    BREAK           reduce using rule 50 (factor -> ID .)
    FLOAT           reduce using rule 50 (factor -> ID .)
    STRING          reduce using rule 50 (factor -> ID .)
    BOOLEAN         reduce using rule 50 (factor -> ID .)
    TRUE            reduce using rule 50 (factor -> ID .)
    FALSE           reduce using rule 50 (factor -> ID .)
    NIL             reduce using rule 50 (factor -> ID .)
    $end            reduce using rule 50 (factor -> ID .)
    END             reduce using rule 50 (factor -> ID .)
    ELSE            reduce using rule 50 (factor -> ID .)

  ! LPAREN          [ reduce using rule 50 (factor -> ID .) ]


state 22

    (33) assignment -> VAR_INST . ASSIGN expression
    (51) factor -> VAR_INST .

    ASSIGN          shift and go to state 54
    EQUALS          reduce using rule 51 (factor -> VAR_INST .)
    NEQUALS         reduce using rule 51 (factor -> VAR_INST .)
    GREATEREQ       reduce using rule 51 (factor -> VAR_INST .)
    LESSEQ          reduce using rule 51 (factor -> VAR_INST .)
    GREATERT        reduce using rule 51 (factor -> VAR_INST .)
    LESST           reduce using rule 51 (factor -> VAR_INST .)
    TIMES           reduce using rule 51 (factor -> VAR_INST .)
    DIVIDE          reduce using rule 51 (factor -> VAR_INST .)
    EXPONENT        reduce using rule 51 (factor -> VAR_INST .)
    MODULE          reduce using rule 51 (factor -> VAR_INST .)
    PLUS            reduce using rule 51 (factor -> VAR_INST .)
    MINUS           reduce using rule 51 (factor -> VAR_INST .)
    ID              reduce using rule 51 (factor -> VAR_INST .)
    VAR_INST        reduce using rule 51 (factor -> VAR_INST .)
    PUTS            reduce using rule 51 (factor -> VAR_INST .)
    IF              reduce using rule 51 (factor -> VAR_INST .)
    WHILE           reduce using rule 51 (factor -> VAR_INST .)
    FOR             reduce using rule 51 (factor -> VAR_INST .)
    LPAREN          reduce using rule 51 (factor -> VAR_INST .)
    INTEGER         reduce using rule 51 (factor -> VAR_INST .)
    DEF             reduce using rule 51 (factor -> VAR_INST .)
    CLASS           reduce using rule 51 (factor -> VAR_INST .)
    RETURN          reduce using rule 51 (factor -> VAR_INST .)
    BREAK           reduce using rule 51 (factor -> VAR_INST .)
    FLOAT           reduce using rule 51 (factor -> VAR_INST .)
    STRING          reduce using rule 51 (factor -> VAR_INST .)
    BOOLEAN         reduce using rule 51 (factor -> VAR_INST .)
    TRUE            reduce using rule 51 (factor -> VAR_INST .)
    FALSE           reduce using rule 51 (factor -> VAR_INST .)
    NIL             reduce using rule 51 (factor -> VAR_INST .)
    $end            reduce using rule 51 (factor -> VAR_INST .)
    END             reduce using rule 51 (factor -> VAR_INST .)
    ELSE            reduce using rule 51 (factor -> VAR_INST .)


state 23

    (40) expression -> term .
    (41) term -> term . TIMES factor
    (42) term -> term . DIVIDE factor
    (43) term -> term . EXPONENT factor
    (44) term -> term . MODULE factor

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EXPONENT resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
    PLUS            reduce using rule 40 (expression -> term .)
    MINUS           reduce using rule 40 (expression -> term .)
    EQUALS          reduce using rule 40 (expression -> term .)
    NEQUALS         reduce using rule 40 (expression -> term .)
    GREATEREQ       reduce using rule 40 (expression -> term .)
    LESSEQ          reduce using rule 40 (expression -> term .)
    GREATERT        reduce using rule 40 (expression -> term .)
    LESST           reduce using rule 40 (expression -> term .)
    ID              reduce using rule 40 (expression -> term .)
    VAR_INST        reduce using rule 40 (expression -> term .)
    PUTS            reduce using rule 40 (expression -> term .)
    IF              reduce using rule 40 (expression -> term .)
    WHILE           reduce using rule 40 (expression -> term .)
    FOR             reduce using rule 40 (expression -> term .)
    LPAREN          reduce using rule 40 (expression -> term .)
    INTEGER         reduce using rule 40 (expression -> term .)
    DEF             reduce using rule 40 (expression -> term .)
    CLASS           reduce using rule 40 (expression -> term .)
    RETURN          reduce using rule 40 (expression -> term .)
    BREAK           reduce using rule 40 (expression -> term .)
    FLOAT           reduce using rule 40 (expression -> term .)
    STRING          reduce using rule 40 (expression -> term .)
    BOOLEAN         reduce using rule 40 (expression -> term .)
    TRUE            reduce using rule 40 (expression -> term .)
    FALSE           reduce using rule 40 (expression -> term .)
    NIL             reduce using rule 40 (expression -> term .)
    $end            reduce using rule 40 (expression -> term .)
    RPAREN          reduce using rule 40 (expression -> term .)
    END             reduce using rule 40 (expression -> term .)
    ELSE            reduce using rule 40 (expression -> term .)
    AND             reduce using rule 40 (expression -> term .)
    OR              reduce using rule 40 (expression -> term .)
    COMMA           reduce using rule 40 (expression -> term .)
    RCORCH          reduce using rule 40 (expression -> term .)
    RBRACE          reduce using rule 40 (expression -> term .)
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 56
    EXPONENT        shift and go to state 57
    MODULE          shift and go to state 58

  ! TIMES           [ reduce using rule 40 (expression -> term .) ]
  ! DIVIDE          [ reduce using rule 40 (expression -> term .) ]
  ! EXPONENT        [ reduce using rule 40 (expression -> term .) ]
  ! MODULE          [ reduce using rule 40 (expression -> term .) ]


state 24

    (10) print -> PUTS . factor
    (11) print -> PUTS . STRING
    (34) input -> PUTS . STRING
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    STRING          shift and go to state 60
    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    factor                         shift and go to state 59
    expression                     shift and go to state 65
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67
    term                           shift and go to state 23

state 25

    (45) term -> factor .
    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    TIMES           reduce using rule 45 (term -> factor .)
    DIVIDE          reduce using rule 45 (term -> factor .)
    EXPONENT        reduce using rule 45 (term -> factor .)
    MODULE          reduce using rule 45 (term -> factor .)
    PLUS            reduce using rule 45 (term -> factor .)
    MINUS           reduce using rule 45 (term -> factor .)
    ID              reduce using rule 45 (term -> factor .)
    VAR_INST        reduce using rule 45 (term -> factor .)
    PUTS            reduce using rule 45 (term -> factor .)
    IF              reduce using rule 45 (term -> factor .)
    WHILE           reduce using rule 45 (term -> factor .)
    FOR             reduce using rule 45 (term -> factor .)
    LPAREN          reduce using rule 45 (term -> factor .)
    INTEGER         reduce using rule 45 (term -> factor .)
    DEF             reduce using rule 45 (term -> factor .)
    CLASS           reduce using rule 45 (term -> factor .)
    RETURN          reduce using rule 45 (term -> factor .)
    BREAK           reduce using rule 45 (term -> factor .)
    FLOAT           reduce using rule 45 (term -> factor .)
    STRING          reduce using rule 45 (term -> factor .)
    BOOLEAN         reduce using rule 45 (term -> factor .)
    TRUE            reduce using rule 45 (term -> factor .)
    FALSE           reduce using rule 45 (term -> factor .)
    NIL             reduce using rule 45 (term -> factor .)
    $end            reduce using rule 45 (term -> factor .)
    RPAREN          reduce using rule 45 (term -> factor .)
    END             reduce using rule 45 (term -> factor .)
    ELSE            reduce using rule 45 (term -> factor .)
    AND             reduce using rule 45 (term -> factor .)
    OR              reduce using rule 45 (term -> factor .)
    COMMA           reduce using rule 45 (term -> factor .)
    RCORCH          reduce using rule 45 (term -> factor .)
    RBRACE          reduce using rule 45 (term -> factor .)
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68

state 26

    (48) factor -> STRING .

    EQUALS          reduce using rule 48 (factor -> STRING .)
    NEQUALS         reduce using rule 48 (factor -> STRING .)
    GREATEREQ       reduce using rule 48 (factor -> STRING .)
    LESSEQ          reduce using rule 48 (factor -> STRING .)
    GREATERT        reduce using rule 48 (factor -> STRING .)
    LESST           reduce using rule 48 (factor -> STRING .)
    TIMES           reduce using rule 48 (factor -> STRING .)
    DIVIDE          reduce using rule 48 (factor -> STRING .)
    EXPONENT        reduce using rule 48 (factor -> STRING .)
    MODULE          reduce using rule 48 (factor -> STRING .)
    PLUS            reduce using rule 48 (factor -> STRING .)
    MINUS           reduce using rule 48 (factor -> STRING .)
    ID              reduce using rule 48 (factor -> STRING .)
    VAR_INST        reduce using rule 48 (factor -> STRING .)
    PUTS            reduce using rule 48 (factor -> STRING .)
    IF              reduce using rule 48 (factor -> STRING .)
    WHILE           reduce using rule 48 (factor -> STRING .)
    FOR             reduce using rule 48 (factor -> STRING .)
    LPAREN          reduce using rule 48 (factor -> STRING .)
    INTEGER         reduce using rule 48 (factor -> STRING .)
    DEF             reduce using rule 48 (factor -> STRING .)
    CLASS           reduce using rule 48 (factor -> STRING .)
    RETURN          reduce using rule 48 (factor -> STRING .)
    BREAK           reduce using rule 48 (factor -> STRING .)
    FLOAT           reduce using rule 48 (factor -> STRING .)
    STRING          reduce using rule 48 (factor -> STRING .)
    BOOLEAN         reduce using rule 48 (factor -> STRING .)
    TRUE            reduce using rule 48 (factor -> STRING .)
    FALSE           reduce using rule 48 (factor -> STRING .)
    NIL             reduce using rule 48 (factor -> STRING .)
    $end            reduce using rule 48 (factor -> STRING .)
    RPAREN          reduce using rule 48 (factor -> STRING .)
    END             reduce using rule 48 (factor -> STRING .)
    ELSE            reduce using rule 48 (factor -> STRING .)
    AND             reduce using rule 48 (factor -> STRING .)
    OR              reduce using rule 48 (factor -> STRING .)
    COMMA           reduce using rule 48 (factor -> STRING .)
    RCORCH          reduce using rule 48 (factor -> STRING .)
    RBRACE          reduce using rule 48 (factor -> STRING .)


state 27

    (73) condition -> IF . logic_expression body END
    (74) condition -> IF . logic_expression body ELSE body END
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    logic_expression               shift and go to state 69
    factor                         shift and go to state 70
    expression                     shift and go to state 65
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67
    term                           shift and go to state 23

state 28

    (56) factor -> logic_expression .

    EQUALS          reduce using rule 56 (factor -> logic_expression .)
    NEQUALS         reduce using rule 56 (factor -> logic_expression .)
    GREATEREQ       reduce using rule 56 (factor -> logic_expression .)
    LESSEQ          reduce using rule 56 (factor -> logic_expression .)
    GREATERT        reduce using rule 56 (factor -> logic_expression .)
    LESST           reduce using rule 56 (factor -> logic_expression .)
    TIMES           reduce using rule 56 (factor -> logic_expression .)
    DIVIDE          reduce using rule 56 (factor -> logic_expression .)
    EXPONENT        reduce using rule 56 (factor -> logic_expression .)
    MODULE          reduce using rule 56 (factor -> logic_expression .)
    PLUS            reduce using rule 56 (factor -> logic_expression .)
    MINUS           reduce using rule 56 (factor -> logic_expression .)
    ID              reduce using rule 56 (factor -> logic_expression .)
    VAR_INST        reduce using rule 56 (factor -> logic_expression .)
    PUTS            reduce using rule 56 (factor -> logic_expression .)
    IF              reduce using rule 56 (factor -> logic_expression .)
    WHILE           reduce using rule 56 (factor -> logic_expression .)
    FOR             reduce using rule 56 (factor -> logic_expression .)
    LPAREN          reduce using rule 56 (factor -> logic_expression .)
    INTEGER         reduce using rule 56 (factor -> logic_expression .)
    DEF             reduce using rule 56 (factor -> logic_expression .)
    CLASS           reduce using rule 56 (factor -> logic_expression .)
    RETURN          reduce using rule 56 (factor -> logic_expression .)
    BREAK           reduce using rule 56 (factor -> logic_expression .)
    FLOAT           reduce using rule 56 (factor -> logic_expression .)
    STRING          reduce using rule 56 (factor -> logic_expression .)
    BOOLEAN         reduce using rule 56 (factor -> logic_expression .)
    TRUE            reduce using rule 56 (factor -> logic_expression .)
    FALSE           reduce using rule 56 (factor -> logic_expression .)
    NIL             reduce using rule 56 (factor -> logic_expression .)
    $end            reduce using rule 56 (factor -> logic_expression .)
    END             reduce using rule 56 (factor -> logic_expression .)
    ELSE            reduce using rule 56 (factor -> logic_expression .)
    RPAREN          reduce using rule 56 (factor -> logic_expression .)
    AND             reduce using rule 56 (factor -> logic_expression .)
    OR              reduce using rule 56 (factor -> logic_expression .)
    COMMA           reduce using rule 56 (factor -> logic_expression .)
    RCORCH          reduce using rule 56 (factor -> logic_expression .)
    RBRACE          reduce using rule 56 (factor -> logic_expression .)


state 29

    (68) while_loop -> WHILE . logic_expression body END
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    logic_expression               shift and go to state 71
    factor                         shift and go to state 70
    expression                     shift and go to state 65
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67
    term                           shift and go to state 23

state 30

    (64) for_loop -> FOR . ID IN range_incl body END

    ID              shift and go to state 72


state 31

    (69) range_incl -> LPAREN . INTEGER RANGE_INCL INTEGER RPAREN
    (71) range_excl -> LPAREN . INTEGER RANGE_EXCL INTEGER RPAREN
    (55) factor -> LPAREN . expression RPAREN
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER

    INTEGER         shift and go to state 73
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    expression                     shift and go to state 74
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 32

    (70) range_incl -> INTEGER . RANGE_INCL INTEGER
    (72) range_excl -> INTEGER . RANGE_EXCL INTEGER
    (46) factor -> INTEGER .

    RANGE_INCL      shift and go to state 75
    RANGE_EXCL      shift and go to state 76
    EQUALS          reduce using rule 46 (factor -> INTEGER .)
    NEQUALS         reduce using rule 46 (factor -> INTEGER .)
    GREATEREQ       reduce using rule 46 (factor -> INTEGER .)
    LESSEQ          reduce using rule 46 (factor -> INTEGER .)
    GREATERT        reduce using rule 46 (factor -> INTEGER .)
    LESST           reduce using rule 46 (factor -> INTEGER .)
    TIMES           reduce using rule 46 (factor -> INTEGER .)
    DIVIDE          reduce using rule 46 (factor -> INTEGER .)
    EXPONENT        reduce using rule 46 (factor -> INTEGER .)
    MODULE          reduce using rule 46 (factor -> INTEGER .)
    PLUS            reduce using rule 46 (factor -> INTEGER .)
    MINUS           reduce using rule 46 (factor -> INTEGER .)
    ID              reduce using rule 46 (factor -> INTEGER .)
    VAR_INST        reduce using rule 46 (factor -> INTEGER .)
    PUTS            reduce using rule 46 (factor -> INTEGER .)
    IF              reduce using rule 46 (factor -> INTEGER .)
    WHILE           reduce using rule 46 (factor -> INTEGER .)
    FOR             reduce using rule 46 (factor -> INTEGER .)
    LPAREN          reduce using rule 46 (factor -> INTEGER .)
    INTEGER         reduce using rule 46 (factor -> INTEGER .)
    DEF             reduce using rule 46 (factor -> INTEGER .)
    CLASS           reduce using rule 46 (factor -> INTEGER .)
    RETURN          reduce using rule 46 (factor -> INTEGER .)
    BREAK           reduce using rule 46 (factor -> INTEGER .)
    FLOAT           reduce using rule 46 (factor -> INTEGER .)
    STRING          reduce using rule 46 (factor -> INTEGER .)
    BOOLEAN         reduce using rule 46 (factor -> INTEGER .)
    TRUE            reduce using rule 46 (factor -> INTEGER .)
    FALSE           reduce using rule 46 (factor -> INTEGER .)
    NIL             reduce using rule 46 (factor -> INTEGER .)
    $end            reduce using rule 46 (factor -> INTEGER .)
    END             reduce using rule 46 (factor -> INTEGER .)
    ELSE            reduce using rule 46 (factor -> INTEGER .)


state 33

    (4) function -> DEF . ID body END
    (5) function -> DEF . ID LPAREN args RPAREN body END

    ID              shift and go to state 77


state 34

    (12) class_def -> CLASS . ID body END

    ID              shift and go to state 78


state 35

    (30) return_stmt -> RETURN . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    factor                         shift and go to state 79
    expression                     shift and go to state 65
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67
    term                           shift and go to state 23

state 36

    (31) break_stmt -> BREAK .

    ID              reduce using rule 31 (break_stmt -> BREAK .)
    VAR_INST        reduce using rule 31 (break_stmt -> BREAK .)
    PUTS            reduce using rule 31 (break_stmt -> BREAK .)
    IF              reduce using rule 31 (break_stmt -> BREAK .)
    WHILE           reduce using rule 31 (break_stmt -> BREAK .)
    FOR             reduce using rule 31 (break_stmt -> BREAK .)
    LPAREN          reduce using rule 31 (break_stmt -> BREAK .)
    INTEGER         reduce using rule 31 (break_stmt -> BREAK .)
    DEF             reduce using rule 31 (break_stmt -> BREAK .)
    CLASS           reduce using rule 31 (break_stmt -> BREAK .)
    RETURN          reduce using rule 31 (break_stmt -> BREAK .)
    BREAK           reduce using rule 31 (break_stmt -> BREAK .)
    FLOAT           reduce using rule 31 (break_stmt -> BREAK .)
    STRING          reduce using rule 31 (break_stmt -> BREAK .)
    BOOLEAN         reduce using rule 31 (break_stmt -> BREAK .)
    TRUE            reduce using rule 31 (break_stmt -> BREAK .)
    FALSE           reduce using rule 31 (break_stmt -> BREAK .)
    NIL             reduce using rule 31 (break_stmt -> BREAK .)
    $end            reduce using rule 31 (break_stmt -> BREAK .)
    END             reduce using rule 31 (break_stmt -> BREAK .)
    ELSE            reduce using rule 31 (break_stmt -> BREAK .)


state 37

    (47) factor -> FLOAT .

    EQUALS          reduce using rule 47 (factor -> FLOAT .)
    NEQUALS         reduce using rule 47 (factor -> FLOAT .)
    GREATEREQ       reduce using rule 47 (factor -> FLOAT .)
    LESSEQ          reduce using rule 47 (factor -> FLOAT .)
    GREATERT        reduce using rule 47 (factor -> FLOAT .)
    LESST           reduce using rule 47 (factor -> FLOAT .)
    TIMES           reduce using rule 47 (factor -> FLOAT .)
    DIVIDE          reduce using rule 47 (factor -> FLOAT .)
    EXPONENT        reduce using rule 47 (factor -> FLOAT .)
    MODULE          reduce using rule 47 (factor -> FLOAT .)
    PLUS            reduce using rule 47 (factor -> FLOAT .)
    MINUS           reduce using rule 47 (factor -> FLOAT .)
    ID              reduce using rule 47 (factor -> FLOAT .)
    VAR_INST        reduce using rule 47 (factor -> FLOAT .)
    PUTS            reduce using rule 47 (factor -> FLOAT .)
    IF              reduce using rule 47 (factor -> FLOAT .)
    WHILE           reduce using rule 47 (factor -> FLOAT .)
    FOR             reduce using rule 47 (factor -> FLOAT .)
    LPAREN          reduce using rule 47 (factor -> FLOAT .)
    INTEGER         reduce using rule 47 (factor -> FLOAT .)
    DEF             reduce using rule 47 (factor -> FLOAT .)
    CLASS           reduce using rule 47 (factor -> FLOAT .)
    RETURN          reduce using rule 47 (factor -> FLOAT .)
    BREAK           reduce using rule 47 (factor -> FLOAT .)
    FLOAT           reduce using rule 47 (factor -> FLOAT .)
    STRING          reduce using rule 47 (factor -> FLOAT .)
    BOOLEAN         reduce using rule 47 (factor -> FLOAT .)
    TRUE            reduce using rule 47 (factor -> FLOAT .)
    FALSE           reduce using rule 47 (factor -> FLOAT .)
    NIL             reduce using rule 47 (factor -> FLOAT .)
    $end            reduce using rule 47 (factor -> FLOAT .)
    END             reduce using rule 47 (factor -> FLOAT .)
    ELSE            reduce using rule 47 (factor -> FLOAT .)
    RPAREN          reduce using rule 47 (factor -> FLOAT .)
    AND             reduce using rule 47 (factor -> FLOAT .)
    OR              reduce using rule 47 (factor -> FLOAT .)
    COMMA           reduce using rule 47 (factor -> FLOAT .)
    RCORCH          reduce using rule 47 (factor -> FLOAT .)
    RBRACE          reduce using rule 47 (factor -> FLOAT .)


state 38

    (49) factor -> BOOLEAN .

    EQUALS          reduce using rule 49 (factor -> BOOLEAN .)
    NEQUALS         reduce using rule 49 (factor -> BOOLEAN .)
    GREATEREQ       reduce using rule 49 (factor -> BOOLEAN .)
    LESSEQ          reduce using rule 49 (factor -> BOOLEAN .)
    GREATERT        reduce using rule 49 (factor -> BOOLEAN .)
    LESST           reduce using rule 49 (factor -> BOOLEAN .)
    TIMES           reduce using rule 49 (factor -> BOOLEAN .)
    DIVIDE          reduce using rule 49 (factor -> BOOLEAN .)
    EXPONENT        reduce using rule 49 (factor -> BOOLEAN .)
    MODULE          reduce using rule 49 (factor -> BOOLEAN .)
    PLUS            reduce using rule 49 (factor -> BOOLEAN .)
    MINUS           reduce using rule 49 (factor -> BOOLEAN .)
    ID              reduce using rule 49 (factor -> BOOLEAN .)
    VAR_INST        reduce using rule 49 (factor -> BOOLEAN .)
    PUTS            reduce using rule 49 (factor -> BOOLEAN .)
    IF              reduce using rule 49 (factor -> BOOLEAN .)
    WHILE           reduce using rule 49 (factor -> BOOLEAN .)
    FOR             reduce using rule 49 (factor -> BOOLEAN .)
    LPAREN          reduce using rule 49 (factor -> BOOLEAN .)
    INTEGER         reduce using rule 49 (factor -> BOOLEAN .)
    DEF             reduce using rule 49 (factor -> BOOLEAN .)
    CLASS           reduce using rule 49 (factor -> BOOLEAN .)
    RETURN          reduce using rule 49 (factor -> BOOLEAN .)
    BREAK           reduce using rule 49 (factor -> BOOLEAN .)
    FLOAT           reduce using rule 49 (factor -> BOOLEAN .)
    STRING          reduce using rule 49 (factor -> BOOLEAN .)
    BOOLEAN         reduce using rule 49 (factor -> BOOLEAN .)
    TRUE            reduce using rule 49 (factor -> BOOLEAN .)
    FALSE           reduce using rule 49 (factor -> BOOLEAN .)
    NIL             reduce using rule 49 (factor -> BOOLEAN .)
    $end            reduce using rule 49 (factor -> BOOLEAN .)
    END             reduce using rule 49 (factor -> BOOLEAN .)
    ELSE            reduce using rule 49 (factor -> BOOLEAN .)
    RPAREN          reduce using rule 49 (factor -> BOOLEAN .)
    AND             reduce using rule 49 (factor -> BOOLEAN .)
    OR              reduce using rule 49 (factor -> BOOLEAN .)
    COMMA           reduce using rule 49 (factor -> BOOLEAN .)
    RCORCH          reduce using rule 49 (factor -> BOOLEAN .)
    RBRACE          reduce using rule 49 (factor -> BOOLEAN .)


state 39

    (52) factor -> TRUE .

    EQUALS          reduce using rule 52 (factor -> TRUE .)
    NEQUALS         reduce using rule 52 (factor -> TRUE .)
    GREATEREQ       reduce using rule 52 (factor -> TRUE .)
    LESSEQ          reduce using rule 52 (factor -> TRUE .)
    GREATERT        reduce using rule 52 (factor -> TRUE .)
    LESST           reduce using rule 52 (factor -> TRUE .)
    TIMES           reduce using rule 52 (factor -> TRUE .)
    DIVIDE          reduce using rule 52 (factor -> TRUE .)
    EXPONENT        reduce using rule 52 (factor -> TRUE .)
    MODULE          reduce using rule 52 (factor -> TRUE .)
    PLUS            reduce using rule 52 (factor -> TRUE .)
    MINUS           reduce using rule 52 (factor -> TRUE .)
    ID              reduce using rule 52 (factor -> TRUE .)
    VAR_INST        reduce using rule 52 (factor -> TRUE .)
    PUTS            reduce using rule 52 (factor -> TRUE .)
    IF              reduce using rule 52 (factor -> TRUE .)
    WHILE           reduce using rule 52 (factor -> TRUE .)
    FOR             reduce using rule 52 (factor -> TRUE .)
    LPAREN          reduce using rule 52 (factor -> TRUE .)
    INTEGER         reduce using rule 52 (factor -> TRUE .)
    DEF             reduce using rule 52 (factor -> TRUE .)
    CLASS           reduce using rule 52 (factor -> TRUE .)
    RETURN          reduce using rule 52 (factor -> TRUE .)
    BREAK           reduce using rule 52 (factor -> TRUE .)
    FLOAT           reduce using rule 52 (factor -> TRUE .)
    STRING          reduce using rule 52 (factor -> TRUE .)
    BOOLEAN         reduce using rule 52 (factor -> TRUE .)
    TRUE            reduce using rule 52 (factor -> TRUE .)
    FALSE           reduce using rule 52 (factor -> TRUE .)
    NIL             reduce using rule 52 (factor -> TRUE .)
    $end            reduce using rule 52 (factor -> TRUE .)
    END             reduce using rule 52 (factor -> TRUE .)
    ELSE            reduce using rule 52 (factor -> TRUE .)
    RPAREN          reduce using rule 52 (factor -> TRUE .)
    AND             reduce using rule 52 (factor -> TRUE .)
    OR              reduce using rule 52 (factor -> TRUE .)
    COMMA           reduce using rule 52 (factor -> TRUE .)
    RCORCH          reduce using rule 52 (factor -> TRUE .)
    RBRACE          reduce using rule 52 (factor -> TRUE .)


state 40

    (53) factor -> FALSE .

    EQUALS          reduce using rule 53 (factor -> FALSE .)
    NEQUALS         reduce using rule 53 (factor -> FALSE .)
    GREATEREQ       reduce using rule 53 (factor -> FALSE .)
    LESSEQ          reduce using rule 53 (factor -> FALSE .)
    GREATERT        reduce using rule 53 (factor -> FALSE .)
    LESST           reduce using rule 53 (factor -> FALSE .)
    TIMES           reduce using rule 53 (factor -> FALSE .)
    DIVIDE          reduce using rule 53 (factor -> FALSE .)
    EXPONENT        reduce using rule 53 (factor -> FALSE .)
    MODULE          reduce using rule 53 (factor -> FALSE .)
    PLUS            reduce using rule 53 (factor -> FALSE .)
    MINUS           reduce using rule 53 (factor -> FALSE .)
    ID              reduce using rule 53 (factor -> FALSE .)
    VAR_INST        reduce using rule 53 (factor -> FALSE .)
    PUTS            reduce using rule 53 (factor -> FALSE .)
    IF              reduce using rule 53 (factor -> FALSE .)
    WHILE           reduce using rule 53 (factor -> FALSE .)
    FOR             reduce using rule 53 (factor -> FALSE .)
    LPAREN          reduce using rule 53 (factor -> FALSE .)
    INTEGER         reduce using rule 53 (factor -> FALSE .)
    DEF             reduce using rule 53 (factor -> FALSE .)
    CLASS           reduce using rule 53 (factor -> FALSE .)
    RETURN          reduce using rule 53 (factor -> FALSE .)
    BREAK           reduce using rule 53 (factor -> FALSE .)
    FLOAT           reduce using rule 53 (factor -> FALSE .)
    STRING          reduce using rule 53 (factor -> FALSE .)
    BOOLEAN         reduce using rule 53 (factor -> FALSE .)
    TRUE            reduce using rule 53 (factor -> FALSE .)
    FALSE           reduce using rule 53 (factor -> FALSE .)
    NIL             reduce using rule 53 (factor -> FALSE .)
    $end            reduce using rule 53 (factor -> FALSE .)
    END             reduce using rule 53 (factor -> FALSE .)
    ELSE            reduce using rule 53 (factor -> FALSE .)
    RPAREN          reduce using rule 53 (factor -> FALSE .)
    AND             reduce using rule 53 (factor -> FALSE .)
    OR              reduce using rule 53 (factor -> FALSE .)
    COMMA           reduce using rule 53 (factor -> FALSE .)
    RCORCH          reduce using rule 53 (factor -> FALSE .)
    RBRACE          reduce using rule 53 (factor -> FALSE .)


state 41

    (54) factor -> NIL .

    EQUALS          reduce using rule 54 (factor -> NIL .)
    NEQUALS         reduce using rule 54 (factor -> NIL .)
    GREATEREQ       reduce using rule 54 (factor -> NIL .)
    LESSEQ          reduce using rule 54 (factor -> NIL .)
    GREATERT        reduce using rule 54 (factor -> NIL .)
    LESST           reduce using rule 54 (factor -> NIL .)
    TIMES           reduce using rule 54 (factor -> NIL .)
    DIVIDE          reduce using rule 54 (factor -> NIL .)
    EXPONENT        reduce using rule 54 (factor -> NIL .)
    MODULE          reduce using rule 54 (factor -> NIL .)
    PLUS            reduce using rule 54 (factor -> NIL .)
    MINUS           reduce using rule 54 (factor -> NIL .)
    ID              reduce using rule 54 (factor -> NIL .)
    VAR_INST        reduce using rule 54 (factor -> NIL .)
    PUTS            reduce using rule 54 (factor -> NIL .)
    IF              reduce using rule 54 (factor -> NIL .)
    WHILE           reduce using rule 54 (factor -> NIL .)
    FOR             reduce using rule 54 (factor -> NIL .)
    LPAREN          reduce using rule 54 (factor -> NIL .)
    INTEGER         reduce using rule 54 (factor -> NIL .)
    DEF             reduce using rule 54 (factor -> NIL .)
    CLASS           reduce using rule 54 (factor -> NIL .)
    RETURN          reduce using rule 54 (factor -> NIL .)
    BREAK           reduce using rule 54 (factor -> NIL .)
    FLOAT           reduce using rule 54 (factor -> NIL .)
    STRING          reduce using rule 54 (factor -> NIL .)
    BOOLEAN         reduce using rule 54 (factor -> NIL .)
    TRUE            reduce using rule 54 (factor -> NIL .)
    FALSE           reduce using rule 54 (factor -> NIL .)
    NIL             reduce using rule 54 (factor -> NIL .)
    $end            reduce using rule 54 (factor -> NIL .)
    END             reduce using rule 54 (factor -> NIL .)
    ELSE            reduce using rule 54 (factor -> NIL .)
    RPAREN          reduce using rule 54 (factor -> NIL .)
    AND             reduce using rule 54 (factor -> NIL .)
    OR              reduce using rule 54 (factor -> NIL .)
    COMMA           reduce using rule 54 (factor -> NIL .)
    RCORCH          reduce using rule 54 (factor -> NIL .)
    RBRACE          reduce using rule 54 (factor -> NIL .)


state 42

    (3) sentences -> sentence sentences .

    $end            reduce using rule 3 (sentences -> sentence sentences .)


state 43

    (38) expression -> expression PLUS . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    expression                     shift and go to state 65
    term                           shift and go to state 80
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 44

    (39) expression -> expression MINUS . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    expression                     shift and go to state 65
    term                           shift and go to state 81
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 45

    (77) logic_expression -> expression logic_op . expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    expression                     shift and go to state 82
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 46

    (78) logic_op -> EQUALS .

    INTEGER         reduce using rule 78 (logic_op -> EQUALS .)
    FLOAT           reduce using rule 78 (logic_op -> EQUALS .)
    STRING          reduce using rule 78 (logic_op -> EQUALS .)
    BOOLEAN         reduce using rule 78 (logic_op -> EQUALS .)
    ID              reduce using rule 78 (logic_op -> EQUALS .)
    VAR_INST        reduce using rule 78 (logic_op -> EQUALS .)
    TRUE            reduce using rule 78 (logic_op -> EQUALS .)
    FALSE           reduce using rule 78 (logic_op -> EQUALS .)
    NIL             reduce using rule 78 (logic_op -> EQUALS .)
    LPAREN          reduce using rule 78 (logic_op -> EQUALS .)


state 47

    (79) logic_op -> NEQUALS .

    INTEGER         reduce using rule 79 (logic_op -> NEQUALS .)
    FLOAT           reduce using rule 79 (logic_op -> NEQUALS .)
    STRING          reduce using rule 79 (logic_op -> NEQUALS .)
    BOOLEAN         reduce using rule 79 (logic_op -> NEQUALS .)
    ID              reduce using rule 79 (logic_op -> NEQUALS .)
    VAR_INST        reduce using rule 79 (logic_op -> NEQUALS .)
    TRUE            reduce using rule 79 (logic_op -> NEQUALS .)
    FALSE           reduce using rule 79 (logic_op -> NEQUALS .)
    NIL             reduce using rule 79 (logic_op -> NEQUALS .)
    LPAREN          reduce using rule 79 (logic_op -> NEQUALS .)


state 48

    (80) logic_op -> GREATEREQ .

    INTEGER         reduce using rule 80 (logic_op -> GREATEREQ .)
    FLOAT           reduce using rule 80 (logic_op -> GREATEREQ .)
    STRING          reduce using rule 80 (logic_op -> GREATEREQ .)
    BOOLEAN         reduce using rule 80 (logic_op -> GREATEREQ .)
    ID              reduce using rule 80 (logic_op -> GREATEREQ .)
    VAR_INST        reduce using rule 80 (logic_op -> GREATEREQ .)
    TRUE            reduce using rule 80 (logic_op -> GREATEREQ .)
    FALSE           reduce using rule 80 (logic_op -> GREATEREQ .)
    NIL             reduce using rule 80 (logic_op -> GREATEREQ .)
    LPAREN          reduce using rule 80 (logic_op -> GREATEREQ .)


state 49

    (81) logic_op -> LESSEQ .

    INTEGER         reduce using rule 81 (logic_op -> LESSEQ .)
    FLOAT           reduce using rule 81 (logic_op -> LESSEQ .)
    STRING          reduce using rule 81 (logic_op -> LESSEQ .)
    BOOLEAN         reduce using rule 81 (logic_op -> LESSEQ .)
    ID              reduce using rule 81 (logic_op -> LESSEQ .)
    VAR_INST        reduce using rule 81 (logic_op -> LESSEQ .)
    TRUE            reduce using rule 81 (logic_op -> LESSEQ .)
    FALSE           reduce using rule 81 (logic_op -> LESSEQ .)
    NIL             reduce using rule 81 (logic_op -> LESSEQ .)
    LPAREN          reduce using rule 81 (logic_op -> LESSEQ .)


state 50

    (82) logic_op -> GREATERT .

    INTEGER         reduce using rule 82 (logic_op -> GREATERT .)
    FLOAT           reduce using rule 82 (logic_op -> GREATERT .)
    STRING          reduce using rule 82 (logic_op -> GREATERT .)
    BOOLEAN         reduce using rule 82 (logic_op -> GREATERT .)
    ID              reduce using rule 82 (logic_op -> GREATERT .)
    VAR_INST        reduce using rule 82 (logic_op -> GREATERT .)
    TRUE            reduce using rule 82 (logic_op -> GREATERT .)
    FALSE           reduce using rule 82 (logic_op -> GREATERT .)
    NIL             reduce using rule 82 (logic_op -> GREATERT .)
    LPAREN          reduce using rule 82 (logic_op -> GREATERT .)


state 51

    (83) logic_op -> LESST .

    INTEGER         reduce using rule 83 (logic_op -> LESST .)
    FLOAT           reduce using rule 83 (logic_op -> LESST .)
    STRING          reduce using rule 83 (logic_op -> LESST .)
    BOOLEAN         reduce using rule 83 (logic_op -> LESST .)
    ID              reduce using rule 83 (logic_op -> LESST .)
    VAR_INST        reduce using rule 83 (logic_op -> LESST .)
    TRUE            reduce using rule 83 (logic_op -> LESST .)
    FALSE           reduce using rule 83 (logic_op -> LESST .)
    NIL             reduce using rule 83 (logic_op -> LESST .)
    LPAREN          reduce using rule 83 (logic_op -> LESST .)


state 52

    (32) assignment -> ID ASSIGN . expression
    (35) input -> ID ASSIGN . GETS method_chain
    (61) array -> ID ASSIGN . LCORCH elements RCORCH
    (65) hash -> ID ASSIGN . LBRACE hash_pairs RBRACE
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER

    GETS            shift and go to state 84
    LCORCH          shift and go to state 85
    LBRACE          shift and go to state 86
    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    expression                     shift and go to state 83
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 53

    (59) function_call_empty -> ID LPAREN . RPAREN
    (60) function_call_args -> ID LPAREN . args RPAREN
    (6) args -> . ID
    (7) args -> . ID COMMA args

    RPAREN          shift and go to state 88
    ID              shift and go to state 87

    args                           shift and go to state 89

state 54

    (33) assignment -> VAR_INST ASSIGN . expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    expression                     shift and go to state 90
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 55

    (41) term -> term TIMES . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    term                           shift and go to state 23
    factor                         shift and go to state 91
    expression                     shift and go to state 65
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 56

    (42) term -> term DIVIDE . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    term                           shift and go to state 23
    factor                         shift and go to state 92
    expression                     shift and go to state 65
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 57

    (43) term -> term EXPONENT . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    term                           shift and go to state 23
    factor                         shift and go to state 93
    expression                     shift and go to state 65
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 58

    (44) term -> term MODULE . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    term                           shift and go to state 23
    factor                         shift and go to state 94
    expression                     shift and go to state 65
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 59

    (10) print -> PUTS factor .
    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (45) term -> factor .
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    ID              reduce using rule 10 (print -> PUTS factor .)
    VAR_INST        reduce using rule 10 (print -> PUTS factor .)
    PUTS            reduce using rule 10 (print -> PUTS factor .)
    IF              reduce using rule 10 (print -> PUTS factor .)
    WHILE           reduce using rule 10 (print -> PUTS factor .)
    FOR             reduce using rule 10 (print -> PUTS factor .)
    LPAREN          reduce using rule 10 (print -> PUTS factor .)
    INTEGER         reduce using rule 10 (print -> PUTS factor .)
    DEF             reduce using rule 10 (print -> PUTS factor .)
    CLASS           reduce using rule 10 (print -> PUTS factor .)
    RETURN          reduce using rule 10 (print -> PUTS factor .)
    BREAK           reduce using rule 10 (print -> PUTS factor .)
    FLOAT           reduce using rule 10 (print -> PUTS factor .)
    STRING          reduce using rule 10 (print -> PUTS factor .)
    BOOLEAN         reduce using rule 10 (print -> PUTS factor .)
    TRUE            reduce using rule 10 (print -> PUTS factor .)
    FALSE           reduce using rule 10 (print -> PUTS factor .)
    NIL             reduce using rule 10 (print -> PUTS factor .)
    $end            reduce using rule 10 (print -> PUTS factor .)
    END             reduce using rule 10 (print -> PUTS factor .)
    ELSE            reduce using rule 10 (print -> PUTS factor .)
    TIMES           reduce using rule 45 (term -> factor .)
    DIVIDE          reduce using rule 45 (term -> factor .)
    EXPONENT        reduce using rule 45 (term -> factor .)
    MODULE          reduce using rule 45 (term -> factor .)
    PLUS            reduce using rule 45 (term -> factor .)
    MINUS           reduce using rule 45 (term -> factor .)
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68

state 60

    (11) print -> PUTS STRING .
    (34) input -> PUTS STRING .
    (48) factor -> STRING .

  ! reduce/reduce conflict for ID resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for VAR_INST resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for PUTS resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for IF resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for WHILE resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for FOR resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for LPAREN resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for INTEGER resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for DEF resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for CLASS resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for RETURN resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for BREAK resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for FLOAT resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for STRING resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for TRUE resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for FALSE resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for NIL resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for $end resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for END resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for ELSE resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for ID resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for VAR_INST resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for PUTS resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for IF resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for WHILE resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for FOR resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for LPAREN resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for INTEGER resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for DEF resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for CLASS resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for RETURN resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for BREAK resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for FLOAT resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for STRING resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for TRUE resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for FALSE resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for NIL resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for $end resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for END resolved using rule 11 (print -> PUTS STRING .)
  ! reduce/reduce conflict for ELSE resolved using rule 11 (print -> PUTS STRING .)
    ID              reduce using rule 11 (print -> PUTS STRING .)
    VAR_INST        reduce using rule 11 (print -> PUTS STRING .)
    PUTS            reduce using rule 11 (print -> PUTS STRING .)
    IF              reduce using rule 11 (print -> PUTS STRING .)
    WHILE           reduce using rule 11 (print -> PUTS STRING .)
    FOR             reduce using rule 11 (print -> PUTS STRING .)
    LPAREN          reduce using rule 11 (print -> PUTS STRING .)
    INTEGER         reduce using rule 11 (print -> PUTS STRING .)
    DEF             reduce using rule 11 (print -> PUTS STRING .)
    CLASS           reduce using rule 11 (print -> PUTS STRING .)
    RETURN          reduce using rule 11 (print -> PUTS STRING .)
    BREAK           reduce using rule 11 (print -> PUTS STRING .)
    FLOAT           reduce using rule 11 (print -> PUTS STRING .)
    STRING          reduce using rule 11 (print -> PUTS STRING .)
    BOOLEAN         reduce using rule 11 (print -> PUTS STRING .)
    TRUE            reduce using rule 11 (print -> PUTS STRING .)
    FALSE           reduce using rule 11 (print -> PUTS STRING .)
    NIL             reduce using rule 11 (print -> PUTS STRING .)
    $end            reduce using rule 11 (print -> PUTS STRING .)
    END             reduce using rule 11 (print -> PUTS STRING .)
    ELSE            reduce using rule 11 (print -> PUTS STRING .)
    EQUALS          reduce using rule 48 (factor -> STRING .)
    NEQUALS         reduce using rule 48 (factor -> STRING .)
    GREATEREQ       reduce using rule 48 (factor -> STRING .)
    LESSEQ          reduce using rule 48 (factor -> STRING .)
    GREATERT        reduce using rule 48 (factor -> STRING .)
    LESST           reduce using rule 48 (factor -> STRING .)
    TIMES           reduce using rule 48 (factor -> STRING .)
    DIVIDE          reduce using rule 48 (factor -> STRING .)
    EXPONENT        reduce using rule 48 (factor -> STRING .)
    MODULE          reduce using rule 48 (factor -> STRING .)
    PLUS            reduce using rule 48 (factor -> STRING .)
    MINUS           reduce using rule 48 (factor -> STRING .)

  ! ID              [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! VAR_INST        [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! PUTS            [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! IF              [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! WHILE           [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! FOR             [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! LPAREN          [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! INTEGER         [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! DEF             [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! CLASS           [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! RETURN          [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! BREAK           [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! FLOAT           [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! STRING          [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! BOOLEAN         [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! TRUE            [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! FALSE           [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! NIL             [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! $end            [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! END             [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! ELSE            [ reduce using rule 34 (input -> PUTS STRING .) ]
  ! ID              [ reduce using rule 48 (factor -> STRING .) ]
  ! VAR_INST        [ reduce using rule 48 (factor -> STRING .) ]
  ! PUTS            [ reduce using rule 48 (factor -> STRING .) ]
  ! IF              [ reduce using rule 48 (factor -> STRING .) ]
  ! WHILE           [ reduce using rule 48 (factor -> STRING .) ]
  ! FOR             [ reduce using rule 48 (factor -> STRING .) ]
  ! LPAREN          [ reduce using rule 48 (factor -> STRING .) ]
  ! INTEGER         [ reduce using rule 48 (factor -> STRING .) ]
  ! DEF             [ reduce using rule 48 (factor -> STRING .) ]
  ! CLASS           [ reduce using rule 48 (factor -> STRING .) ]
  ! RETURN          [ reduce using rule 48 (factor -> STRING .) ]
  ! BREAK           [ reduce using rule 48 (factor -> STRING .) ]
  ! FLOAT           [ reduce using rule 48 (factor -> STRING .) ]
  ! STRING          [ reduce using rule 48 (factor -> STRING .) ]
  ! BOOLEAN         [ reduce using rule 48 (factor -> STRING .) ]
  ! TRUE            [ reduce using rule 48 (factor -> STRING .) ]
  ! FALSE           [ reduce using rule 48 (factor -> STRING .) ]
  ! NIL             [ reduce using rule 48 (factor -> STRING .) ]
  ! $end            [ reduce using rule 48 (factor -> STRING .) ]
  ! END             [ reduce using rule 48 (factor -> STRING .) ]
  ! ELSE            [ reduce using rule 48 (factor -> STRING .) ]


state 61

    (46) factor -> INTEGER .
    (70) range_incl -> INTEGER . RANGE_INCL INTEGER
    (72) range_excl -> INTEGER . RANGE_EXCL INTEGER

    EQUALS          reduce using rule 46 (factor -> INTEGER .)
    NEQUALS         reduce using rule 46 (factor -> INTEGER .)
    GREATEREQ       reduce using rule 46 (factor -> INTEGER .)
    LESSEQ          reduce using rule 46 (factor -> INTEGER .)
    GREATERT        reduce using rule 46 (factor -> INTEGER .)
    LESST           reduce using rule 46 (factor -> INTEGER .)
    ID              reduce using rule 46 (factor -> INTEGER .)
    VAR_INST        reduce using rule 46 (factor -> INTEGER .)
    PUTS            reduce using rule 46 (factor -> INTEGER .)
    IF              reduce using rule 46 (factor -> INTEGER .)
    WHILE           reduce using rule 46 (factor -> INTEGER .)
    FOR             reduce using rule 46 (factor -> INTEGER .)
    LPAREN          reduce using rule 46 (factor -> INTEGER .)
    INTEGER         reduce using rule 46 (factor -> INTEGER .)
    DEF             reduce using rule 46 (factor -> INTEGER .)
    CLASS           reduce using rule 46 (factor -> INTEGER .)
    RETURN          reduce using rule 46 (factor -> INTEGER .)
    BREAK           reduce using rule 46 (factor -> INTEGER .)
    FLOAT           reduce using rule 46 (factor -> INTEGER .)
    STRING          reduce using rule 46 (factor -> INTEGER .)
    BOOLEAN         reduce using rule 46 (factor -> INTEGER .)
    TRUE            reduce using rule 46 (factor -> INTEGER .)
    FALSE           reduce using rule 46 (factor -> INTEGER .)
    NIL             reduce using rule 46 (factor -> INTEGER .)
    $end            reduce using rule 46 (factor -> INTEGER .)
    TIMES           reduce using rule 46 (factor -> INTEGER .)
    DIVIDE          reduce using rule 46 (factor -> INTEGER .)
    EXPONENT        reduce using rule 46 (factor -> INTEGER .)
    MODULE          reduce using rule 46 (factor -> INTEGER .)
    PLUS            reduce using rule 46 (factor -> INTEGER .)
    MINUS           reduce using rule 46 (factor -> INTEGER .)
    END             reduce using rule 46 (factor -> INTEGER .)
    ELSE            reduce using rule 46 (factor -> INTEGER .)
    RPAREN          reduce using rule 46 (factor -> INTEGER .)
    AND             reduce using rule 46 (factor -> INTEGER .)
    OR              reduce using rule 46 (factor -> INTEGER .)
    COMMA           reduce using rule 46 (factor -> INTEGER .)
    RCORCH          reduce using rule 46 (factor -> INTEGER .)
    RBRACE          reduce using rule 46 (factor -> INTEGER .)
    RANGE_INCL      shift and go to state 75
    RANGE_EXCL      shift and go to state 76


state 62

    (50) factor -> ID .

    EQUALS          reduce using rule 50 (factor -> ID .)
    NEQUALS         reduce using rule 50 (factor -> ID .)
    GREATEREQ       reduce using rule 50 (factor -> ID .)
    LESSEQ          reduce using rule 50 (factor -> ID .)
    GREATERT        reduce using rule 50 (factor -> ID .)
    LESST           reduce using rule 50 (factor -> ID .)
    ID              reduce using rule 50 (factor -> ID .)
    VAR_INST        reduce using rule 50 (factor -> ID .)
    PUTS            reduce using rule 50 (factor -> ID .)
    IF              reduce using rule 50 (factor -> ID .)
    WHILE           reduce using rule 50 (factor -> ID .)
    FOR             reduce using rule 50 (factor -> ID .)
    LPAREN          reduce using rule 50 (factor -> ID .)
    INTEGER         reduce using rule 50 (factor -> ID .)
    DEF             reduce using rule 50 (factor -> ID .)
    CLASS           reduce using rule 50 (factor -> ID .)
    RETURN          reduce using rule 50 (factor -> ID .)
    BREAK           reduce using rule 50 (factor -> ID .)
    FLOAT           reduce using rule 50 (factor -> ID .)
    STRING          reduce using rule 50 (factor -> ID .)
    BOOLEAN         reduce using rule 50 (factor -> ID .)
    TRUE            reduce using rule 50 (factor -> ID .)
    FALSE           reduce using rule 50 (factor -> ID .)
    NIL             reduce using rule 50 (factor -> ID .)
    $end            reduce using rule 50 (factor -> ID .)
    TIMES           reduce using rule 50 (factor -> ID .)
    DIVIDE          reduce using rule 50 (factor -> ID .)
    EXPONENT        reduce using rule 50 (factor -> ID .)
    MODULE          reduce using rule 50 (factor -> ID .)
    PLUS            reduce using rule 50 (factor -> ID .)
    MINUS           reduce using rule 50 (factor -> ID .)
    END             reduce using rule 50 (factor -> ID .)
    ELSE            reduce using rule 50 (factor -> ID .)
    RPAREN          reduce using rule 50 (factor -> ID .)
    AND             reduce using rule 50 (factor -> ID .)
    OR              reduce using rule 50 (factor -> ID .)
    COMMA           reduce using rule 50 (factor -> ID .)
    RCORCH          reduce using rule 50 (factor -> ID .)
    RBRACE          reduce using rule 50 (factor -> ID .)


state 63

    (51) factor -> VAR_INST .

    EQUALS          reduce using rule 51 (factor -> VAR_INST .)
    NEQUALS         reduce using rule 51 (factor -> VAR_INST .)
    GREATEREQ       reduce using rule 51 (factor -> VAR_INST .)
    LESSEQ          reduce using rule 51 (factor -> VAR_INST .)
    GREATERT        reduce using rule 51 (factor -> VAR_INST .)
    LESST           reduce using rule 51 (factor -> VAR_INST .)
    ID              reduce using rule 51 (factor -> VAR_INST .)
    VAR_INST        reduce using rule 51 (factor -> VAR_INST .)
    PUTS            reduce using rule 51 (factor -> VAR_INST .)
    IF              reduce using rule 51 (factor -> VAR_INST .)
    WHILE           reduce using rule 51 (factor -> VAR_INST .)
    FOR             reduce using rule 51 (factor -> VAR_INST .)
    LPAREN          reduce using rule 51 (factor -> VAR_INST .)
    INTEGER         reduce using rule 51 (factor -> VAR_INST .)
    DEF             reduce using rule 51 (factor -> VAR_INST .)
    CLASS           reduce using rule 51 (factor -> VAR_INST .)
    RETURN          reduce using rule 51 (factor -> VAR_INST .)
    BREAK           reduce using rule 51 (factor -> VAR_INST .)
    FLOAT           reduce using rule 51 (factor -> VAR_INST .)
    STRING          reduce using rule 51 (factor -> VAR_INST .)
    BOOLEAN         reduce using rule 51 (factor -> VAR_INST .)
    TRUE            reduce using rule 51 (factor -> VAR_INST .)
    FALSE           reduce using rule 51 (factor -> VAR_INST .)
    NIL             reduce using rule 51 (factor -> VAR_INST .)
    $end            reduce using rule 51 (factor -> VAR_INST .)
    TIMES           reduce using rule 51 (factor -> VAR_INST .)
    DIVIDE          reduce using rule 51 (factor -> VAR_INST .)
    EXPONENT        reduce using rule 51 (factor -> VAR_INST .)
    MODULE          reduce using rule 51 (factor -> VAR_INST .)
    PLUS            reduce using rule 51 (factor -> VAR_INST .)
    MINUS           reduce using rule 51 (factor -> VAR_INST .)
    END             reduce using rule 51 (factor -> VAR_INST .)
    ELSE            reduce using rule 51 (factor -> VAR_INST .)
    RPAREN          reduce using rule 51 (factor -> VAR_INST .)
    AND             reduce using rule 51 (factor -> VAR_INST .)
    OR              reduce using rule 51 (factor -> VAR_INST .)
    COMMA           reduce using rule 51 (factor -> VAR_INST .)
    RCORCH          reduce using rule 51 (factor -> VAR_INST .)
    RBRACE          reduce using rule 51 (factor -> VAR_INST .)


state 64

    (55) factor -> LPAREN . expression RPAREN
    (69) range_incl -> LPAREN . INTEGER RANGE_INCL INTEGER RPAREN
    (71) range_excl -> LPAREN . INTEGER RANGE_EXCL INTEGER RPAREN
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER

    INTEGER         shift and go to state 73
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    expression                     shift and go to state 74
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 65

    (77) logic_expression -> expression . logic_op expression
    (38) expression -> expression . PLUS term
    (39) expression -> expression . MINUS term
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

    logic_op                       shift and go to state 45

state 66

    (57) factor -> range_incl .

    EQUALS          reduce using rule 57 (factor -> range_incl .)
    NEQUALS         reduce using rule 57 (factor -> range_incl .)
    GREATEREQ       reduce using rule 57 (factor -> range_incl .)
    LESSEQ          reduce using rule 57 (factor -> range_incl .)
    GREATERT        reduce using rule 57 (factor -> range_incl .)
    LESST           reduce using rule 57 (factor -> range_incl .)
    ID              reduce using rule 57 (factor -> range_incl .)
    VAR_INST        reduce using rule 57 (factor -> range_incl .)
    PUTS            reduce using rule 57 (factor -> range_incl .)
    IF              reduce using rule 57 (factor -> range_incl .)
    WHILE           reduce using rule 57 (factor -> range_incl .)
    FOR             reduce using rule 57 (factor -> range_incl .)
    LPAREN          reduce using rule 57 (factor -> range_incl .)
    INTEGER         reduce using rule 57 (factor -> range_incl .)
    DEF             reduce using rule 57 (factor -> range_incl .)
    CLASS           reduce using rule 57 (factor -> range_incl .)
    RETURN          reduce using rule 57 (factor -> range_incl .)
    BREAK           reduce using rule 57 (factor -> range_incl .)
    FLOAT           reduce using rule 57 (factor -> range_incl .)
    STRING          reduce using rule 57 (factor -> range_incl .)
    BOOLEAN         reduce using rule 57 (factor -> range_incl .)
    TRUE            reduce using rule 57 (factor -> range_incl .)
    FALSE           reduce using rule 57 (factor -> range_incl .)
    NIL             reduce using rule 57 (factor -> range_incl .)
    $end            reduce using rule 57 (factor -> range_incl .)
    TIMES           reduce using rule 57 (factor -> range_incl .)
    DIVIDE          reduce using rule 57 (factor -> range_incl .)
    EXPONENT        reduce using rule 57 (factor -> range_incl .)
    MODULE          reduce using rule 57 (factor -> range_incl .)
    PLUS            reduce using rule 57 (factor -> range_incl .)
    MINUS           reduce using rule 57 (factor -> range_incl .)
    END             reduce using rule 57 (factor -> range_incl .)
    ELSE            reduce using rule 57 (factor -> range_incl .)
    RPAREN          reduce using rule 57 (factor -> range_incl .)
    AND             reduce using rule 57 (factor -> range_incl .)
    OR              reduce using rule 57 (factor -> range_incl .)
    COMMA           reduce using rule 57 (factor -> range_incl .)
    RCORCH          reduce using rule 57 (factor -> range_incl .)
    RBRACE          reduce using rule 57 (factor -> range_incl .)


state 67

    (58) factor -> range_excl .

    EQUALS          reduce using rule 58 (factor -> range_excl .)
    NEQUALS         reduce using rule 58 (factor -> range_excl .)
    GREATEREQ       reduce using rule 58 (factor -> range_excl .)
    LESSEQ          reduce using rule 58 (factor -> range_excl .)
    GREATERT        reduce using rule 58 (factor -> range_excl .)
    LESST           reduce using rule 58 (factor -> range_excl .)
    ID              reduce using rule 58 (factor -> range_excl .)
    VAR_INST        reduce using rule 58 (factor -> range_excl .)
    PUTS            reduce using rule 58 (factor -> range_excl .)
    IF              reduce using rule 58 (factor -> range_excl .)
    WHILE           reduce using rule 58 (factor -> range_excl .)
    FOR             reduce using rule 58 (factor -> range_excl .)
    LPAREN          reduce using rule 58 (factor -> range_excl .)
    INTEGER         reduce using rule 58 (factor -> range_excl .)
    DEF             reduce using rule 58 (factor -> range_excl .)
    CLASS           reduce using rule 58 (factor -> range_excl .)
    RETURN          reduce using rule 58 (factor -> range_excl .)
    BREAK           reduce using rule 58 (factor -> range_excl .)
    FLOAT           reduce using rule 58 (factor -> range_excl .)
    STRING          reduce using rule 58 (factor -> range_excl .)
    BOOLEAN         reduce using rule 58 (factor -> range_excl .)
    TRUE            reduce using rule 58 (factor -> range_excl .)
    FALSE           reduce using rule 58 (factor -> range_excl .)
    NIL             reduce using rule 58 (factor -> range_excl .)
    $end            reduce using rule 58 (factor -> range_excl .)
    TIMES           reduce using rule 58 (factor -> range_excl .)
    DIVIDE          reduce using rule 58 (factor -> range_excl .)
    EXPONENT        reduce using rule 58 (factor -> range_excl .)
    MODULE          reduce using rule 58 (factor -> range_excl .)
    PLUS            reduce using rule 58 (factor -> range_excl .)
    MINUS           reduce using rule 58 (factor -> range_excl .)
    END             reduce using rule 58 (factor -> range_excl .)
    ELSE            reduce using rule 58 (factor -> range_excl .)
    RPAREN          reduce using rule 58 (factor -> range_excl .)
    AND             reduce using rule 58 (factor -> range_excl .)
    OR              reduce using rule 58 (factor -> range_excl .)
    COMMA           reduce using rule 58 (factor -> range_excl .)
    RCORCH          reduce using rule 58 (factor -> range_excl .)
    RBRACE          reduce using rule 58 (factor -> range_excl .)


state 68

    (75) logic_expression -> factor logic_op . factor
    (76) logic_expression -> factor logic_op . factor logic_connector logic_expression
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    factor                         shift and go to state 95
    logic_expression               shift and go to state 28
    expression                     shift and go to state 65
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67
    term                           shift and go to state 23

state 69

    (73) condition -> IF logic_expression . body END
    (74) condition -> IF logic_expression . body ELSE body END
    (56) factor -> logic_expression .
    (8) body -> . body sentence
    (9) body -> . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    EQUALS          reduce using rule 56 (factor -> logic_expression .)
    NEQUALS         reduce using rule 56 (factor -> logic_expression .)
    GREATEREQ       reduce using rule 56 (factor -> logic_expression .)
    LESSEQ          reduce using rule 56 (factor -> logic_expression .)
    GREATERT        reduce using rule 56 (factor -> logic_expression .)
    LESST           reduce using rule 56 (factor -> logic_expression .)
    TIMES           reduce using rule 56 (factor -> logic_expression .)
    DIVIDE          reduce using rule 56 (factor -> logic_expression .)
    EXPONENT        reduce using rule 56 (factor -> logic_expression .)
    MODULE          reduce using rule 56 (factor -> logic_expression .)
    PLUS            reduce using rule 56 (factor -> logic_expression .)
    MINUS           reduce using rule 56 (factor -> logic_expression .)
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    logic_expression               shift and go to state 28
    body                           shift and go to state 96
    sentence                       shift and go to state 97
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25

state 70

    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (45) term -> factor .
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    TIMES           reduce using rule 45 (term -> factor .)
    DIVIDE          reduce using rule 45 (term -> factor .)
    EXPONENT        reduce using rule 45 (term -> factor .)
    MODULE          reduce using rule 45 (term -> factor .)
    PLUS            reduce using rule 45 (term -> factor .)
    MINUS           reduce using rule 45 (term -> factor .)
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68

state 71

    (68) while_loop -> WHILE logic_expression . body END
    (56) factor -> logic_expression .
    (8) body -> . body sentence
    (9) body -> . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    EQUALS          reduce using rule 56 (factor -> logic_expression .)
    NEQUALS         reduce using rule 56 (factor -> logic_expression .)
    GREATEREQ       reduce using rule 56 (factor -> logic_expression .)
    LESSEQ          reduce using rule 56 (factor -> logic_expression .)
    GREATERT        reduce using rule 56 (factor -> logic_expression .)
    LESST           reduce using rule 56 (factor -> logic_expression .)
    TIMES           reduce using rule 56 (factor -> logic_expression .)
    DIVIDE          reduce using rule 56 (factor -> logic_expression .)
    EXPONENT        reduce using rule 56 (factor -> logic_expression .)
    MODULE          reduce using rule 56 (factor -> logic_expression .)
    PLUS            reduce using rule 56 (factor -> logic_expression .)
    MINUS           reduce using rule 56 (factor -> logic_expression .)
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    logic_expression               shift and go to state 28
    body                           shift and go to state 98
    sentence                       shift and go to state 97
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25

state 72

    (64) for_loop -> FOR ID . IN range_incl body END

    IN              shift and go to state 99


state 73

    (69) range_incl -> LPAREN INTEGER . RANGE_INCL INTEGER RPAREN
    (71) range_excl -> LPAREN INTEGER . RANGE_EXCL INTEGER RPAREN
    (46) factor -> INTEGER .
    (70) range_incl -> INTEGER . RANGE_INCL INTEGER
    (72) range_excl -> INTEGER . RANGE_EXCL INTEGER

    RANGE_INCL      shift and go to state 100
    RANGE_EXCL      shift and go to state 101
    EQUALS          reduce using rule 46 (factor -> INTEGER .)
    NEQUALS         reduce using rule 46 (factor -> INTEGER .)
    GREATEREQ       reduce using rule 46 (factor -> INTEGER .)
    LESSEQ          reduce using rule 46 (factor -> INTEGER .)
    GREATERT        reduce using rule 46 (factor -> INTEGER .)
    LESST           reduce using rule 46 (factor -> INTEGER .)
    TIMES           reduce using rule 46 (factor -> INTEGER .)
    DIVIDE          reduce using rule 46 (factor -> INTEGER .)
    EXPONENT        reduce using rule 46 (factor -> INTEGER .)
    MODULE          reduce using rule 46 (factor -> INTEGER .)
    RPAREN          reduce using rule 46 (factor -> INTEGER .)
    PLUS            reduce using rule 46 (factor -> INTEGER .)
    MINUS           reduce using rule 46 (factor -> INTEGER .)


state 74

    (55) factor -> LPAREN expression . RPAREN
    (38) expression -> expression . PLUS term
    (39) expression -> expression . MINUS term
    (77) logic_expression -> expression . logic_op expression
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

    RPAREN          shift and go to state 102
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

    logic_op                       shift and go to state 45

state 75

    (70) range_incl -> INTEGER RANGE_INCL . INTEGER

    INTEGER         shift and go to state 103


state 76

    (72) range_excl -> INTEGER RANGE_EXCL . INTEGER

    INTEGER         shift and go to state 104


state 77

    (4) function -> DEF ID . body END
    (5) function -> DEF ID . LPAREN args RPAREN body END
    (8) body -> . body sentence
    (9) body -> . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    LPAREN          shift and go to state 106
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    body                           shift and go to state 105
    sentence                       shift and go to state 97
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 78

    (12) class_def -> CLASS ID . body END
    (8) body -> . body sentence
    (9) body -> . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    body                           shift and go to state 107
    sentence                       shift and go to state 97
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 79

    (30) return_stmt -> RETURN factor .
    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (45) term -> factor .
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    ID              reduce using rule 30 (return_stmt -> RETURN factor .)
    VAR_INST        reduce using rule 30 (return_stmt -> RETURN factor .)
    PUTS            reduce using rule 30 (return_stmt -> RETURN factor .)
    IF              reduce using rule 30 (return_stmt -> RETURN factor .)
    WHILE           reduce using rule 30 (return_stmt -> RETURN factor .)
    FOR             reduce using rule 30 (return_stmt -> RETURN factor .)
    LPAREN          reduce using rule 30 (return_stmt -> RETURN factor .)
    INTEGER         reduce using rule 30 (return_stmt -> RETURN factor .)
    DEF             reduce using rule 30 (return_stmt -> RETURN factor .)
    CLASS           reduce using rule 30 (return_stmt -> RETURN factor .)
    RETURN          reduce using rule 30 (return_stmt -> RETURN factor .)
    BREAK           reduce using rule 30 (return_stmt -> RETURN factor .)
    FLOAT           reduce using rule 30 (return_stmt -> RETURN factor .)
    STRING          reduce using rule 30 (return_stmt -> RETURN factor .)
    BOOLEAN         reduce using rule 30 (return_stmt -> RETURN factor .)
    TRUE            reduce using rule 30 (return_stmt -> RETURN factor .)
    FALSE           reduce using rule 30 (return_stmt -> RETURN factor .)
    NIL             reduce using rule 30 (return_stmt -> RETURN factor .)
    $end            reduce using rule 30 (return_stmt -> RETURN factor .)
    END             reduce using rule 30 (return_stmt -> RETURN factor .)
    ELSE            reduce using rule 30 (return_stmt -> RETURN factor .)
    TIMES           reduce using rule 45 (term -> factor .)
    DIVIDE          reduce using rule 45 (term -> factor .)
    EXPONENT        reduce using rule 45 (term -> factor .)
    MODULE          reduce using rule 45 (term -> factor .)
    PLUS            reduce using rule 45 (term -> factor .)
    MINUS           reduce using rule 45 (term -> factor .)
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68

state 80

    (38) expression -> expression PLUS term .
    (41) term -> term . TIMES factor
    (42) term -> term . DIVIDE factor
    (43) term -> term . EXPONENT factor
    (44) term -> term . MODULE factor
    (40) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EXPONENT resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 38 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 38 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for EQUALS resolved using rule 38 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for NEQUALS resolved using rule 38 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 38 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 38 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for GREATERT resolved using rule 38 (expression -> expression PLUS term .)
  ! reduce/reduce conflict for LESST resolved using rule 38 (expression -> expression PLUS term .)
    PLUS            reduce using rule 38 (expression -> expression PLUS term .)
    MINUS           reduce using rule 38 (expression -> expression PLUS term .)
    EQUALS          reduce using rule 38 (expression -> expression PLUS term .)
    NEQUALS         reduce using rule 38 (expression -> expression PLUS term .)
    GREATEREQ       reduce using rule 38 (expression -> expression PLUS term .)
    LESSEQ          reduce using rule 38 (expression -> expression PLUS term .)
    GREATERT        reduce using rule 38 (expression -> expression PLUS term .)
    LESST           reduce using rule 38 (expression -> expression PLUS term .)
    ID              reduce using rule 38 (expression -> expression PLUS term .)
    VAR_INST        reduce using rule 38 (expression -> expression PLUS term .)
    PUTS            reduce using rule 38 (expression -> expression PLUS term .)
    IF              reduce using rule 38 (expression -> expression PLUS term .)
    WHILE           reduce using rule 38 (expression -> expression PLUS term .)
    FOR             reduce using rule 38 (expression -> expression PLUS term .)
    LPAREN          reduce using rule 38 (expression -> expression PLUS term .)
    INTEGER         reduce using rule 38 (expression -> expression PLUS term .)
    DEF             reduce using rule 38 (expression -> expression PLUS term .)
    CLASS           reduce using rule 38 (expression -> expression PLUS term .)
    RETURN          reduce using rule 38 (expression -> expression PLUS term .)
    BREAK           reduce using rule 38 (expression -> expression PLUS term .)
    FLOAT           reduce using rule 38 (expression -> expression PLUS term .)
    STRING          reduce using rule 38 (expression -> expression PLUS term .)
    BOOLEAN         reduce using rule 38 (expression -> expression PLUS term .)
    TRUE            reduce using rule 38 (expression -> expression PLUS term .)
    FALSE           reduce using rule 38 (expression -> expression PLUS term .)
    NIL             reduce using rule 38 (expression -> expression PLUS term .)
    $end            reduce using rule 38 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 38 (expression -> expression PLUS term .)
    END             reduce using rule 38 (expression -> expression PLUS term .)
    ELSE            reduce using rule 38 (expression -> expression PLUS term .)
    AND             reduce using rule 38 (expression -> expression PLUS term .)
    OR              reduce using rule 38 (expression -> expression PLUS term .)
    COMMA           reduce using rule 38 (expression -> expression PLUS term .)
    RCORCH          reduce using rule 38 (expression -> expression PLUS term .)
    RBRACE          reduce using rule 38 (expression -> expression PLUS term .)
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 56
    EXPONENT        shift and go to state 57
    MODULE          shift and go to state 58

  ! TIMES           [ reduce using rule 38 (expression -> expression PLUS term .) ]
  ! DIVIDE          [ reduce using rule 38 (expression -> expression PLUS term .) ]
  ! EXPONENT        [ reduce using rule 38 (expression -> expression PLUS term .) ]
  ! MODULE          [ reduce using rule 38 (expression -> expression PLUS term .) ]
  ! PLUS            [ reduce using rule 40 (expression -> term .) ]
  ! MINUS           [ reduce using rule 40 (expression -> term .) ]
  ! EQUALS          [ reduce using rule 40 (expression -> term .) ]
  ! NEQUALS         [ reduce using rule 40 (expression -> term .) ]
  ! GREATEREQ       [ reduce using rule 40 (expression -> term .) ]
  ! LESSEQ          [ reduce using rule 40 (expression -> term .) ]
  ! GREATERT        [ reduce using rule 40 (expression -> term .) ]
  ! LESST           [ reduce using rule 40 (expression -> term .) ]


state 81

    (39) expression -> expression MINUS term .
    (41) term -> term . TIMES factor
    (42) term -> term . DIVIDE factor
    (43) term -> term . EXPONENT factor
    (44) term -> term . MODULE factor
    (40) expression -> term .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EXPONENT resolved as shift
  ! shift/reduce conflict for MODULE resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 39 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for MINUS resolved using rule 39 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for EQUALS resolved using rule 39 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for NEQUALS resolved using rule 39 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 39 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 39 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for GREATERT resolved using rule 39 (expression -> expression MINUS term .)
  ! reduce/reduce conflict for LESST resolved using rule 39 (expression -> expression MINUS term .)
    PLUS            reduce using rule 39 (expression -> expression MINUS term .)
    MINUS           reduce using rule 39 (expression -> expression MINUS term .)
    EQUALS          reduce using rule 39 (expression -> expression MINUS term .)
    NEQUALS         reduce using rule 39 (expression -> expression MINUS term .)
    GREATEREQ       reduce using rule 39 (expression -> expression MINUS term .)
    LESSEQ          reduce using rule 39 (expression -> expression MINUS term .)
    GREATERT        reduce using rule 39 (expression -> expression MINUS term .)
    LESST           reduce using rule 39 (expression -> expression MINUS term .)
    ID              reduce using rule 39 (expression -> expression MINUS term .)
    VAR_INST        reduce using rule 39 (expression -> expression MINUS term .)
    PUTS            reduce using rule 39 (expression -> expression MINUS term .)
    IF              reduce using rule 39 (expression -> expression MINUS term .)
    WHILE           reduce using rule 39 (expression -> expression MINUS term .)
    FOR             reduce using rule 39 (expression -> expression MINUS term .)
    LPAREN          reduce using rule 39 (expression -> expression MINUS term .)
    INTEGER         reduce using rule 39 (expression -> expression MINUS term .)
    DEF             reduce using rule 39 (expression -> expression MINUS term .)
    CLASS           reduce using rule 39 (expression -> expression MINUS term .)
    RETURN          reduce using rule 39 (expression -> expression MINUS term .)
    BREAK           reduce using rule 39 (expression -> expression MINUS term .)
    FLOAT           reduce using rule 39 (expression -> expression MINUS term .)
    STRING          reduce using rule 39 (expression -> expression MINUS term .)
    BOOLEAN         reduce using rule 39 (expression -> expression MINUS term .)
    TRUE            reduce using rule 39 (expression -> expression MINUS term .)
    FALSE           reduce using rule 39 (expression -> expression MINUS term .)
    NIL             reduce using rule 39 (expression -> expression MINUS term .)
    $end            reduce using rule 39 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 39 (expression -> expression MINUS term .)
    END             reduce using rule 39 (expression -> expression MINUS term .)
    ELSE            reduce using rule 39 (expression -> expression MINUS term .)
    AND             reduce using rule 39 (expression -> expression MINUS term .)
    OR              reduce using rule 39 (expression -> expression MINUS term .)
    COMMA           reduce using rule 39 (expression -> expression MINUS term .)
    RCORCH          reduce using rule 39 (expression -> expression MINUS term .)
    RBRACE          reduce using rule 39 (expression -> expression MINUS term .)
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 56
    EXPONENT        shift and go to state 57
    MODULE          shift and go to state 58

  ! TIMES           [ reduce using rule 39 (expression -> expression MINUS term .) ]
  ! DIVIDE          [ reduce using rule 39 (expression -> expression MINUS term .) ]
  ! EXPONENT        [ reduce using rule 39 (expression -> expression MINUS term .) ]
  ! MODULE          [ reduce using rule 39 (expression -> expression MINUS term .) ]
  ! PLUS            [ reduce using rule 40 (expression -> term .) ]
  ! MINUS           [ reduce using rule 40 (expression -> term .) ]
  ! EQUALS          [ reduce using rule 40 (expression -> term .) ]
  ! NEQUALS         [ reduce using rule 40 (expression -> term .) ]
  ! GREATEREQ       [ reduce using rule 40 (expression -> term .) ]
  ! LESSEQ          [ reduce using rule 40 (expression -> term .) ]
  ! GREATERT        [ reduce using rule 40 (expression -> term .) ]
  ! LESST           [ reduce using rule 40 (expression -> term .) ]


state 82

    (77) logic_expression -> expression logic_op expression .
    (38) expression -> expression . PLUS term
    (39) expression -> expression . MINUS term
    (77) logic_expression -> expression . logic_op expression
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    TIMES           reduce using rule 77 (logic_expression -> expression logic_op expression .)
    DIVIDE          reduce using rule 77 (logic_expression -> expression logic_op expression .)
    EXPONENT        reduce using rule 77 (logic_expression -> expression logic_op expression .)
    MODULE          reduce using rule 77 (logic_expression -> expression logic_op expression .)
    ID              reduce using rule 77 (logic_expression -> expression logic_op expression .)
    VAR_INST        reduce using rule 77 (logic_expression -> expression logic_op expression .)
    PUTS            reduce using rule 77 (logic_expression -> expression logic_op expression .)
    IF              reduce using rule 77 (logic_expression -> expression logic_op expression .)
    WHILE           reduce using rule 77 (logic_expression -> expression logic_op expression .)
    FOR             reduce using rule 77 (logic_expression -> expression logic_op expression .)
    LPAREN          reduce using rule 77 (logic_expression -> expression logic_op expression .)
    INTEGER         reduce using rule 77 (logic_expression -> expression logic_op expression .)
    DEF             reduce using rule 77 (logic_expression -> expression logic_op expression .)
    CLASS           reduce using rule 77 (logic_expression -> expression logic_op expression .)
    RETURN          reduce using rule 77 (logic_expression -> expression logic_op expression .)
    BREAK           reduce using rule 77 (logic_expression -> expression logic_op expression .)
    FLOAT           reduce using rule 77 (logic_expression -> expression logic_op expression .)
    STRING          reduce using rule 77 (logic_expression -> expression logic_op expression .)
    BOOLEAN         reduce using rule 77 (logic_expression -> expression logic_op expression .)
    TRUE            reduce using rule 77 (logic_expression -> expression logic_op expression .)
    FALSE           reduce using rule 77 (logic_expression -> expression logic_op expression .)
    NIL             reduce using rule 77 (logic_expression -> expression logic_op expression .)
    $end            reduce using rule 77 (logic_expression -> expression logic_op expression .)
    END             reduce using rule 77 (logic_expression -> expression logic_op expression .)
    ELSE            reduce using rule 77 (logic_expression -> expression logic_op expression .)
    RPAREN          reduce using rule 77 (logic_expression -> expression logic_op expression .)
    AND             reduce using rule 77 (logic_expression -> expression logic_op expression .)
    OR              reduce using rule 77 (logic_expression -> expression logic_op expression .)
    COMMA           reduce using rule 77 (logic_expression -> expression logic_op expression .)
    RCORCH          reduce using rule 77 (logic_expression -> expression logic_op expression .)
    RBRACE          reduce using rule 77 (logic_expression -> expression logic_op expression .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 77 (logic_expression -> expression logic_op expression .) ]
  ! NEQUALS         [ reduce using rule 77 (logic_expression -> expression logic_op expression .) ]
  ! GREATEREQ       [ reduce using rule 77 (logic_expression -> expression logic_op expression .) ]
  ! LESSEQ          [ reduce using rule 77 (logic_expression -> expression logic_op expression .) ]
  ! GREATERT        [ reduce using rule 77 (logic_expression -> expression logic_op expression .) ]
  ! LESST           [ reduce using rule 77 (logic_expression -> expression logic_op expression .) ]
  ! PLUS            [ reduce using rule 77 (logic_expression -> expression logic_op expression .) ]
  ! MINUS           [ reduce using rule 77 (logic_expression -> expression logic_op expression .) ]

    logic_op                       shift and go to state 45

state 83

    (32) assignment -> ID ASSIGN expression .
    (38) expression -> expression . PLUS term
    (39) expression -> expression . MINUS term
    (77) logic_expression -> expression . logic_op expression
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

    ID              reduce using rule 32 (assignment -> ID ASSIGN expression .)
    VAR_INST        reduce using rule 32 (assignment -> ID ASSIGN expression .)
    PUTS            reduce using rule 32 (assignment -> ID ASSIGN expression .)
    IF              reduce using rule 32 (assignment -> ID ASSIGN expression .)
    WHILE           reduce using rule 32 (assignment -> ID ASSIGN expression .)
    FOR             reduce using rule 32 (assignment -> ID ASSIGN expression .)
    LPAREN          reduce using rule 32 (assignment -> ID ASSIGN expression .)
    INTEGER         reduce using rule 32 (assignment -> ID ASSIGN expression .)
    DEF             reduce using rule 32 (assignment -> ID ASSIGN expression .)
    CLASS           reduce using rule 32 (assignment -> ID ASSIGN expression .)
    RETURN          reduce using rule 32 (assignment -> ID ASSIGN expression .)
    BREAK           reduce using rule 32 (assignment -> ID ASSIGN expression .)
    FLOAT           reduce using rule 32 (assignment -> ID ASSIGN expression .)
    STRING          reduce using rule 32 (assignment -> ID ASSIGN expression .)
    BOOLEAN         reduce using rule 32 (assignment -> ID ASSIGN expression .)
    TRUE            reduce using rule 32 (assignment -> ID ASSIGN expression .)
    FALSE           reduce using rule 32 (assignment -> ID ASSIGN expression .)
    NIL             reduce using rule 32 (assignment -> ID ASSIGN expression .)
    $end            reduce using rule 32 (assignment -> ID ASSIGN expression .)
    END             reduce using rule 32 (assignment -> ID ASSIGN expression .)
    ELSE            reduce using rule 32 (assignment -> ID ASSIGN expression .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

    logic_op                       shift and go to state 45

state 84

    (35) input -> ID ASSIGN GETS . method_chain
    (36) method_chain -> . DOT ID
    (37) method_chain -> . method_chain DOT ID

    DOT             shift and go to state 109

    method_chain                   shift and go to state 108

state 85

    (61) array -> ID ASSIGN LCORCH . elements RCORCH
    (62) elements -> . factor
    (63) elements -> . factor COMMA elements
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    elements                       shift and go to state 110
    factor                         shift and go to state 111
    expression                     shift and go to state 65
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67
    term                           shift and go to state 23

state 86

    (65) hash -> ID ASSIGN LBRACE . hash_pairs RBRACE
    (66) hash_pairs -> . STRING COLON factor
    (67) hash_pairs -> . STRING COLON factor COMMA hash_pairs

    STRING          shift and go to state 113

    hash_pairs                     shift and go to state 112

state 87

    (6) args -> ID .
    (7) args -> ID . COMMA args

    RPAREN          reduce using rule 6 (args -> ID .)
    COMMA           shift and go to state 114


state 88

    (59) function_call_empty -> ID LPAREN RPAREN .

    ID              reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    VAR_INST        reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    PUTS            reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    IF              reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    FOR             reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    LPAREN          reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    INTEGER         reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    DEF             reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    CLASS           reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    BREAK           reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    FLOAT           reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    STRING          reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    BOOLEAN         reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    TRUE            reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    FALSE           reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    NIL             reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    $end            reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    END             reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 59 (function_call_empty -> ID LPAREN RPAREN .)


state 89

    (60) function_call_args -> ID LPAREN args . RPAREN

    RPAREN          shift and go to state 115


state 90

    (33) assignment -> VAR_INST ASSIGN expression .
    (38) expression -> expression . PLUS term
    (39) expression -> expression . MINUS term
    (77) logic_expression -> expression . logic_op expression
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

    ID              reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    VAR_INST        reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    PUTS            reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    IF              reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    WHILE           reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    FOR             reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    LPAREN          reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    INTEGER         reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    DEF             reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    CLASS           reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    RETURN          reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    BREAK           reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    FLOAT           reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    STRING          reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    BOOLEAN         reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    TRUE            reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    FALSE           reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    NIL             reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    $end            reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    END             reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    ELSE            reduce using rule 33 (assignment -> VAR_INST ASSIGN expression .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

    logic_op                       shift and go to state 45

state 91

    (41) term -> term TIMES factor .
    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (45) term -> factor .
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! reduce/reduce conflict for TIMES resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for EXPONENT resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MODULE resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for NEQUALS resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for GREATERT resolved using rule 41 (term -> term TIMES factor .)
  ! reduce/reduce conflict for LESST resolved using rule 41 (term -> term TIMES factor .)
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    TIMES           reduce using rule 41 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 41 (term -> term TIMES factor .)
    EXPONENT        reduce using rule 41 (term -> term TIMES factor .)
    MODULE          reduce using rule 41 (term -> term TIMES factor .)
    PLUS            reduce using rule 41 (term -> term TIMES factor .)
    MINUS           reduce using rule 41 (term -> term TIMES factor .)
    ID              reduce using rule 41 (term -> term TIMES factor .)
    VAR_INST        reduce using rule 41 (term -> term TIMES factor .)
    PUTS            reduce using rule 41 (term -> term TIMES factor .)
    IF              reduce using rule 41 (term -> term TIMES factor .)
    WHILE           reduce using rule 41 (term -> term TIMES factor .)
    FOR             reduce using rule 41 (term -> term TIMES factor .)
    LPAREN          reduce using rule 41 (term -> term TIMES factor .)
    INTEGER         reduce using rule 41 (term -> term TIMES factor .)
    DEF             reduce using rule 41 (term -> term TIMES factor .)
    CLASS           reduce using rule 41 (term -> term TIMES factor .)
    RETURN          reduce using rule 41 (term -> term TIMES factor .)
    BREAK           reduce using rule 41 (term -> term TIMES factor .)
    FLOAT           reduce using rule 41 (term -> term TIMES factor .)
    STRING          reduce using rule 41 (term -> term TIMES factor .)
    BOOLEAN         reduce using rule 41 (term -> term TIMES factor .)
    TRUE            reduce using rule 41 (term -> term TIMES factor .)
    FALSE           reduce using rule 41 (term -> term TIMES factor .)
    NIL             reduce using rule 41 (term -> term TIMES factor .)
    $end            reduce using rule 41 (term -> term TIMES factor .)
    RPAREN          reduce using rule 41 (term -> term TIMES factor .)
    END             reduce using rule 41 (term -> term TIMES factor .)
    ELSE            reduce using rule 41 (term -> term TIMES factor .)
    AND             reduce using rule 41 (term -> term TIMES factor .)
    OR              reduce using rule 41 (term -> term TIMES factor .)
    COMMA           reduce using rule 41 (term -> term TIMES factor .)
    RCORCH          reduce using rule 41 (term -> term TIMES factor .)
    RBRACE          reduce using rule 41 (term -> term TIMES factor .)
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 41 (term -> term TIMES factor .) ]
  ! NEQUALS         [ reduce using rule 41 (term -> term TIMES factor .) ]
  ! GREATEREQ       [ reduce using rule 41 (term -> term TIMES factor .) ]
  ! LESSEQ          [ reduce using rule 41 (term -> term TIMES factor .) ]
  ! GREATERT        [ reduce using rule 41 (term -> term TIMES factor .) ]
  ! LESST           [ reduce using rule 41 (term -> term TIMES factor .) ]
  ! TIMES           [ reduce using rule 45 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 45 (term -> factor .) ]
  ! EXPONENT        [ reduce using rule 45 (term -> factor .) ]
  ! MODULE          [ reduce using rule 45 (term -> factor .) ]
  ! PLUS            [ reduce using rule 45 (term -> factor .) ]
  ! MINUS           [ reduce using rule 45 (term -> factor .) ]
  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68

state 92

    (42) term -> term DIVIDE factor .
    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (45) term -> factor .
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! reduce/reduce conflict for TIMES resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for EXPONENT resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MODULE resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for NEQUALS resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for GREATERT resolved using rule 42 (term -> term DIVIDE factor .)
  ! reduce/reduce conflict for LESST resolved using rule 42 (term -> term DIVIDE factor .)
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    TIMES           reduce using rule 42 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 42 (term -> term DIVIDE factor .)
    EXPONENT        reduce using rule 42 (term -> term DIVIDE factor .)
    MODULE          reduce using rule 42 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 42 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 42 (term -> term DIVIDE factor .)
    ID              reduce using rule 42 (term -> term DIVIDE factor .)
    VAR_INST        reduce using rule 42 (term -> term DIVIDE factor .)
    PUTS            reduce using rule 42 (term -> term DIVIDE factor .)
    IF              reduce using rule 42 (term -> term DIVIDE factor .)
    WHILE           reduce using rule 42 (term -> term DIVIDE factor .)
    FOR             reduce using rule 42 (term -> term DIVIDE factor .)
    LPAREN          reduce using rule 42 (term -> term DIVIDE factor .)
    INTEGER         reduce using rule 42 (term -> term DIVIDE factor .)
    DEF             reduce using rule 42 (term -> term DIVIDE factor .)
    CLASS           reduce using rule 42 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 42 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 42 (term -> term DIVIDE factor .)
    FLOAT           reduce using rule 42 (term -> term DIVIDE factor .)
    STRING          reduce using rule 42 (term -> term DIVIDE factor .)
    BOOLEAN         reduce using rule 42 (term -> term DIVIDE factor .)
    TRUE            reduce using rule 42 (term -> term DIVIDE factor .)
    FALSE           reduce using rule 42 (term -> term DIVIDE factor .)
    NIL             reduce using rule 42 (term -> term DIVIDE factor .)
    $end            reduce using rule 42 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 42 (term -> term DIVIDE factor .)
    END             reduce using rule 42 (term -> term DIVIDE factor .)
    ELSE            reduce using rule 42 (term -> term DIVIDE factor .)
    AND             reduce using rule 42 (term -> term DIVIDE factor .)
    OR              reduce using rule 42 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 42 (term -> term DIVIDE factor .)
    RCORCH          reduce using rule 42 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 42 (term -> term DIVIDE factor .)
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 42 (term -> term DIVIDE factor .) ]
  ! NEQUALS         [ reduce using rule 42 (term -> term DIVIDE factor .) ]
  ! GREATEREQ       [ reduce using rule 42 (term -> term DIVIDE factor .) ]
  ! LESSEQ          [ reduce using rule 42 (term -> term DIVIDE factor .) ]
  ! GREATERT        [ reduce using rule 42 (term -> term DIVIDE factor .) ]
  ! LESST           [ reduce using rule 42 (term -> term DIVIDE factor .) ]
  ! TIMES           [ reduce using rule 45 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 45 (term -> factor .) ]
  ! EXPONENT        [ reduce using rule 45 (term -> factor .) ]
  ! MODULE          [ reduce using rule 45 (term -> factor .) ]
  ! PLUS            [ reduce using rule 45 (term -> factor .) ]
  ! MINUS           [ reduce using rule 45 (term -> factor .) ]
  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68

state 93

    (43) term -> term EXPONENT factor .
    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (45) term -> factor .
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! reduce/reduce conflict for TIMES resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for EXPONENT resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for MODULE resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for NEQUALS resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for GREATERT resolved using rule 43 (term -> term EXPONENT factor .)
  ! reduce/reduce conflict for LESST resolved using rule 43 (term -> term EXPONENT factor .)
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    TIMES           reduce using rule 43 (term -> term EXPONENT factor .)
    DIVIDE          reduce using rule 43 (term -> term EXPONENT factor .)
    EXPONENT        reduce using rule 43 (term -> term EXPONENT factor .)
    MODULE          reduce using rule 43 (term -> term EXPONENT factor .)
    PLUS            reduce using rule 43 (term -> term EXPONENT factor .)
    MINUS           reduce using rule 43 (term -> term EXPONENT factor .)
    ID              reduce using rule 43 (term -> term EXPONENT factor .)
    VAR_INST        reduce using rule 43 (term -> term EXPONENT factor .)
    PUTS            reduce using rule 43 (term -> term EXPONENT factor .)
    IF              reduce using rule 43 (term -> term EXPONENT factor .)
    WHILE           reduce using rule 43 (term -> term EXPONENT factor .)
    FOR             reduce using rule 43 (term -> term EXPONENT factor .)
    LPAREN          reduce using rule 43 (term -> term EXPONENT factor .)
    INTEGER         reduce using rule 43 (term -> term EXPONENT factor .)
    DEF             reduce using rule 43 (term -> term EXPONENT factor .)
    CLASS           reduce using rule 43 (term -> term EXPONENT factor .)
    RETURN          reduce using rule 43 (term -> term EXPONENT factor .)
    BREAK           reduce using rule 43 (term -> term EXPONENT factor .)
    FLOAT           reduce using rule 43 (term -> term EXPONENT factor .)
    STRING          reduce using rule 43 (term -> term EXPONENT factor .)
    BOOLEAN         reduce using rule 43 (term -> term EXPONENT factor .)
    TRUE            reduce using rule 43 (term -> term EXPONENT factor .)
    FALSE           reduce using rule 43 (term -> term EXPONENT factor .)
    NIL             reduce using rule 43 (term -> term EXPONENT factor .)
    $end            reduce using rule 43 (term -> term EXPONENT factor .)
    RPAREN          reduce using rule 43 (term -> term EXPONENT factor .)
    END             reduce using rule 43 (term -> term EXPONENT factor .)
    ELSE            reduce using rule 43 (term -> term EXPONENT factor .)
    AND             reduce using rule 43 (term -> term EXPONENT factor .)
    OR              reduce using rule 43 (term -> term EXPONENT factor .)
    COMMA           reduce using rule 43 (term -> term EXPONENT factor .)
    RCORCH          reduce using rule 43 (term -> term EXPONENT factor .)
    RBRACE          reduce using rule 43 (term -> term EXPONENT factor .)
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 43 (term -> term EXPONENT factor .) ]
  ! NEQUALS         [ reduce using rule 43 (term -> term EXPONENT factor .) ]
  ! GREATEREQ       [ reduce using rule 43 (term -> term EXPONENT factor .) ]
  ! LESSEQ          [ reduce using rule 43 (term -> term EXPONENT factor .) ]
  ! GREATERT        [ reduce using rule 43 (term -> term EXPONENT factor .) ]
  ! LESST           [ reduce using rule 43 (term -> term EXPONENT factor .) ]
  ! TIMES           [ reduce using rule 45 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 45 (term -> factor .) ]
  ! EXPONENT        [ reduce using rule 45 (term -> factor .) ]
  ! MODULE          [ reduce using rule 45 (term -> factor .) ]
  ! PLUS            [ reduce using rule 45 (term -> factor .) ]
  ! MINUS           [ reduce using rule 45 (term -> factor .) ]
  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68

state 94

    (44) term -> term MODULE factor .
    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (45) term -> factor .
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! reduce/reduce conflict for TIMES resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for EXPONENT resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for MODULE resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for NEQUALS resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for GREATERT resolved using rule 44 (term -> term MODULE factor .)
  ! reduce/reduce conflict for LESST resolved using rule 44 (term -> term MODULE factor .)
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    TIMES           reduce using rule 44 (term -> term MODULE factor .)
    DIVIDE          reduce using rule 44 (term -> term MODULE factor .)
    EXPONENT        reduce using rule 44 (term -> term MODULE factor .)
    MODULE          reduce using rule 44 (term -> term MODULE factor .)
    PLUS            reduce using rule 44 (term -> term MODULE factor .)
    MINUS           reduce using rule 44 (term -> term MODULE factor .)
    ID              reduce using rule 44 (term -> term MODULE factor .)
    VAR_INST        reduce using rule 44 (term -> term MODULE factor .)
    PUTS            reduce using rule 44 (term -> term MODULE factor .)
    IF              reduce using rule 44 (term -> term MODULE factor .)
    WHILE           reduce using rule 44 (term -> term MODULE factor .)
    FOR             reduce using rule 44 (term -> term MODULE factor .)
    LPAREN          reduce using rule 44 (term -> term MODULE factor .)
    INTEGER         reduce using rule 44 (term -> term MODULE factor .)
    DEF             reduce using rule 44 (term -> term MODULE factor .)
    CLASS           reduce using rule 44 (term -> term MODULE factor .)
    RETURN          reduce using rule 44 (term -> term MODULE factor .)
    BREAK           reduce using rule 44 (term -> term MODULE factor .)
    FLOAT           reduce using rule 44 (term -> term MODULE factor .)
    STRING          reduce using rule 44 (term -> term MODULE factor .)
    BOOLEAN         reduce using rule 44 (term -> term MODULE factor .)
    TRUE            reduce using rule 44 (term -> term MODULE factor .)
    FALSE           reduce using rule 44 (term -> term MODULE factor .)
    NIL             reduce using rule 44 (term -> term MODULE factor .)
    $end            reduce using rule 44 (term -> term MODULE factor .)
    RPAREN          reduce using rule 44 (term -> term MODULE factor .)
    END             reduce using rule 44 (term -> term MODULE factor .)
    ELSE            reduce using rule 44 (term -> term MODULE factor .)
    AND             reduce using rule 44 (term -> term MODULE factor .)
    OR              reduce using rule 44 (term -> term MODULE factor .)
    COMMA           reduce using rule 44 (term -> term MODULE factor .)
    RCORCH          reduce using rule 44 (term -> term MODULE factor .)
    RBRACE          reduce using rule 44 (term -> term MODULE factor .)
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 44 (term -> term MODULE factor .) ]
  ! NEQUALS         [ reduce using rule 44 (term -> term MODULE factor .) ]
  ! GREATEREQ       [ reduce using rule 44 (term -> term MODULE factor .) ]
  ! LESSEQ          [ reduce using rule 44 (term -> term MODULE factor .) ]
  ! GREATERT        [ reduce using rule 44 (term -> term MODULE factor .) ]
  ! LESST           [ reduce using rule 44 (term -> term MODULE factor .) ]
  ! TIMES           [ reduce using rule 45 (term -> factor .) ]
  ! DIVIDE          [ reduce using rule 45 (term -> factor .) ]
  ! EXPONENT        [ reduce using rule 45 (term -> factor .) ]
  ! MODULE          [ reduce using rule 45 (term -> factor .) ]
  ! PLUS            [ reduce using rule 45 (term -> factor .) ]
  ! MINUS           [ reduce using rule 45 (term -> factor .) ]
  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68

state 95

    (75) logic_expression -> factor logic_op factor .
    (76) logic_expression -> factor logic_op factor . logic_connector logic_expression
    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (45) term -> factor .
    (84) logic_connector -> . AND
    (85) logic_connector -> . OR
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! reduce/reduce conflict for TIMES resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for EXPONENT resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for MODULE resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for PLUS resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for MINUS resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for NEQUALS resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for GREATERT resolved using rule 45 (term -> factor .)
  ! reduce/reduce conflict for LESST resolved using rule 45 (term -> factor .)
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    ID              reduce using rule 75 (logic_expression -> factor logic_op factor .)
    VAR_INST        reduce using rule 75 (logic_expression -> factor logic_op factor .)
    PUTS            reduce using rule 75 (logic_expression -> factor logic_op factor .)
    IF              reduce using rule 75 (logic_expression -> factor logic_op factor .)
    WHILE           reduce using rule 75 (logic_expression -> factor logic_op factor .)
    FOR             reduce using rule 75 (logic_expression -> factor logic_op factor .)
    LPAREN          reduce using rule 75 (logic_expression -> factor logic_op factor .)
    INTEGER         reduce using rule 75 (logic_expression -> factor logic_op factor .)
    DEF             reduce using rule 75 (logic_expression -> factor logic_op factor .)
    CLASS           reduce using rule 75 (logic_expression -> factor logic_op factor .)
    RETURN          reduce using rule 75 (logic_expression -> factor logic_op factor .)
    BREAK           reduce using rule 75 (logic_expression -> factor logic_op factor .)
    FLOAT           reduce using rule 75 (logic_expression -> factor logic_op factor .)
    STRING          reduce using rule 75 (logic_expression -> factor logic_op factor .)
    BOOLEAN         reduce using rule 75 (logic_expression -> factor logic_op factor .)
    TRUE            reduce using rule 75 (logic_expression -> factor logic_op factor .)
    FALSE           reduce using rule 75 (logic_expression -> factor logic_op factor .)
    NIL             reduce using rule 75 (logic_expression -> factor logic_op factor .)
    $end            reduce using rule 75 (logic_expression -> factor logic_op factor .)
    END             reduce using rule 75 (logic_expression -> factor logic_op factor .)
    ELSE            reduce using rule 75 (logic_expression -> factor logic_op factor .)
    RPAREN          reduce using rule 75 (logic_expression -> factor logic_op factor .)
    COMMA           reduce using rule 75 (logic_expression -> factor logic_op factor .)
    RCORCH          reduce using rule 75 (logic_expression -> factor logic_op factor .)
    RBRACE          reduce using rule 75 (logic_expression -> factor logic_op factor .)
    TIMES           reduce using rule 45 (term -> factor .)
    DIVIDE          reduce using rule 45 (term -> factor .)
    EXPONENT        reduce using rule 45 (term -> factor .)
    MODULE          reduce using rule 45 (term -> factor .)
    PLUS            reduce using rule 45 (term -> factor .)
    MINUS           reduce using rule 45 (term -> factor .)
    AND             shift and go to state 117
    OR              shift and go to state 118
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! NEQUALS         [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! GREATEREQ       [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! LESSEQ          [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! GREATERT        [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! LESST           [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! TIMES           [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! DIVIDE          [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! EXPONENT        [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! MODULE          [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! PLUS            [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! MINUS           [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! AND             [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! OR              [ reduce using rule 75 (logic_expression -> factor logic_op factor .) ]
  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68
    logic_connector                shift and go to state 116

state 96

    (73) condition -> IF logic_expression body . END
    (74) condition -> IF logic_expression body . ELSE body END
    (8) body -> body . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    END             shift and go to state 119
    ELSE            shift and go to state 120
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    logic_expression               shift and go to state 28
    sentence                       shift and go to state 121
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25

state 97

    (9) body -> sentence .

    END             reduce using rule 9 (body -> sentence .)
    ELSE            reduce using rule 9 (body -> sentence .)
    ID              reduce using rule 9 (body -> sentence .)
    VAR_INST        reduce using rule 9 (body -> sentence .)
    PUTS            reduce using rule 9 (body -> sentence .)
    IF              reduce using rule 9 (body -> sentence .)
    WHILE           reduce using rule 9 (body -> sentence .)
    FOR             reduce using rule 9 (body -> sentence .)
    LPAREN          reduce using rule 9 (body -> sentence .)
    INTEGER         reduce using rule 9 (body -> sentence .)
    DEF             reduce using rule 9 (body -> sentence .)
    CLASS           reduce using rule 9 (body -> sentence .)
    RETURN          reduce using rule 9 (body -> sentence .)
    BREAK           reduce using rule 9 (body -> sentence .)
    FLOAT           reduce using rule 9 (body -> sentence .)
    STRING          reduce using rule 9 (body -> sentence .)
    BOOLEAN         reduce using rule 9 (body -> sentence .)
    TRUE            reduce using rule 9 (body -> sentence .)
    FALSE           reduce using rule 9 (body -> sentence .)
    NIL             reduce using rule 9 (body -> sentence .)


state 98

    (68) while_loop -> WHILE logic_expression body . END
    (8) body -> body . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    END             shift and go to state 122
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    logic_expression               shift and go to state 28
    sentence                       shift and go to state 121
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25

state 99

    (64) for_loop -> FOR ID IN . range_incl body END
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER

    LPAREN          shift and go to state 124
    INTEGER         shift and go to state 125

    range_incl                     shift and go to state 123

state 100

    (69) range_incl -> LPAREN INTEGER RANGE_INCL . INTEGER RPAREN
    (70) range_incl -> INTEGER RANGE_INCL . INTEGER

    INTEGER         shift and go to state 126


state 101

    (71) range_excl -> LPAREN INTEGER RANGE_EXCL . INTEGER RPAREN
    (72) range_excl -> INTEGER RANGE_EXCL . INTEGER

    INTEGER         shift and go to state 127


state 102

    (55) factor -> LPAREN expression RPAREN .

    EQUALS          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    NEQUALS         reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    GREATEREQ       reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    LESSEQ          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    GREATERT        reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    LESST           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    MODULE          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    ID              reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    VAR_INST        reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    DEF             reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    CLASS           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    STRING          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    BOOLEAN         reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    NIL             reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    RCORCH          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 55 (factor -> LPAREN expression RPAREN .)


state 103

    (70) range_incl -> INTEGER RANGE_INCL INTEGER .

    ID              reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    VAR_INST        reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    PUTS            reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    IF              reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    WHILE           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    FOR             reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    LPAREN          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    INTEGER         reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    DEF             reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    CLASS           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    RETURN          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    BREAK           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    FLOAT           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    STRING          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    BOOLEAN         reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    TRUE            reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    FALSE           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    NIL             reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    $end            reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    EQUALS          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    NEQUALS         reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    GREATEREQ       reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    LESSEQ          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    GREATERT        reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    LESST           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    TIMES           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    DIVIDE          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    EXPONENT        reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    MODULE          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    PLUS            reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    MINUS           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    END             reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    ELSE            reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    RPAREN          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    AND             reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    OR              reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    COMMA           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    RCORCH          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    RBRACE          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)


state 104

    (72) range_excl -> INTEGER RANGE_EXCL INTEGER .

    ID              reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    VAR_INST        reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    PUTS            reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    IF              reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    WHILE           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    FOR             reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    LPAREN          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    INTEGER         reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    DEF             reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    CLASS           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    RETURN          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    BREAK           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    FLOAT           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    STRING          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    BOOLEAN         reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    TRUE            reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    FALSE           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    NIL             reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    $end            reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    EQUALS          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    NEQUALS         reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    GREATEREQ       reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    LESSEQ          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    GREATERT        reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    LESST           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    TIMES           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    DIVIDE          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    EXPONENT        reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    MODULE          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    PLUS            reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    MINUS           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    END             reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    ELSE            reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    RPAREN          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    AND             reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    OR              reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    COMMA           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    RCORCH          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    RBRACE          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)


state 105

    (4) function -> DEF ID body . END
    (8) body -> body . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    END             shift and go to state 128
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    sentence                       shift and go to state 121
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 106

    (5) function -> DEF ID LPAREN . args RPAREN body END
    (69) range_incl -> LPAREN . INTEGER RANGE_INCL INTEGER RPAREN
    (71) range_excl -> LPAREN . INTEGER RANGE_EXCL INTEGER RPAREN
    (55) factor -> LPAREN . expression RPAREN
    (6) args -> . ID
    (7) args -> . ID COMMA args
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER

    INTEGER         shift and go to state 73
    ID              shift and go to state 129
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    args                           shift and go to state 130
    expression                     shift and go to state 74
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67

state 107

    (12) class_def -> CLASS ID body . END
    (8) body -> body . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    END             shift and go to state 131
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    sentence                       shift and go to state 121
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 108

    (35) input -> ID ASSIGN GETS method_chain .
    (37) method_chain -> method_chain . DOT ID

    ID              reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    VAR_INST        reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    PUTS            reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    IF              reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    WHILE           reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    FOR             reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    LPAREN          reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    INTEGER         reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    DEF             reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    CLASS           reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    RETURN          reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    BREAK           reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    FLOAT           reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    STRING          reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    BOOLEAN         reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    TRUE            reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    FALSE           reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    NIL             reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    $end            reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    END             reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    ELSE            reduce using rule 35 (input -> ID ASSIGN GETS method_chain .)
    DOT             shift and go to state 132


state 109

    (36) method_chain -> DOT . ID

    ID              shift and go to state 133


state 110

    (61) array -> ID ASSIGN LCORCH elements . RCORCH

    RCORCH          shift and go to state 134


state 111

    (62) elements -> factor .
    (63) elements -> factor . COMMA elements
    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (45) term -> factor .
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    RCORCH          reduce using rule 62 (elements -> factor .)
    COMMA           shift and go to state 135
    TIMES           reduce using rule 45 (term -> factor .)
    DIVIDE          reduce using rule 45 (term -> factor .)
    EXPONENT        reduce using rule 45 (term -> factor .)
    MODULE          reduce using rule 45 (term -> factor .)
    PLUS            reduce using rule 45 (term -> factor .)
    MINUS           reduce using rule 45 (term -> factor .)
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68

state 112

    (65) hash -> ID ASSIGN LBRACE hash_pairs . RBRACE

    RBRACE          shift and go to state 136


state 113

    (66) hash_pairs -> STRING . COLON factor
    (67) hash_pairs -> STRING . COLON factor COMMA hash_pairs

    COLON           shift and go to state 137


state 114

    (7) args -> ID COMMA . args
    (6) args -> . ID
    (7) args -> . ID COMMA args

    ID              shift and go to state 87

    args                           shift and go to state 138

state 115

    (60) function_call_args -> ID LPAREN args RPAREN .

    ID              reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    VAR_INST        reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    PUTS            reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    IF              reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    WHILE           reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    FOR             reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    LPAREN          reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    INTEGER         reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    DEF             reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    CLASS           reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    RETURN          reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    BREAK           reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    FLOAT           reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    STRING          reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    BOOLEAN         reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    TRUE            reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    FALSE           reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    NIL             reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    $end            reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    END             reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)
    ELSE            reduce using rule 60 (function_call_args -> ID LPAREN args RPAREN .)


state 116

    (76) logic_expression -> factor logic_op factor logic_connector . logic_expression
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    factor                         shift and go to state 70
    logic_expression               shift and go to state 139
    expression                     shift and go to state 65
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67
    term                           shift and go to state 23

state 117

    (84) logic_connector -> AND .

    INTEGER         reduce using rule 84 (logic_connector -> AND .)
    FLOAT           reduce using rule 84 (logic_connector -> AND .)
    STRING          reduce using rule 84 (logic_connector -> AND .)
    BOOLEAN         reduce using rule 84 (logic_connector -> AND .)
    ID              reduce using rule 84 (logic_connector -> AND .)
    VAR_INST        reduce using rule 84 (logic_connector -> AND .)
    TRUE            reduce using rule 84 (logic_connector -> AND .)
    FALSE           reduce using rule 84 (logic_connector -> AND .)
    NIL             reduce using rule 84 (logic_connector -> AND .)
    LPAREN          reduce using rule 84 (logic_connector -> AND .)


state 118

    (85) logic_connector -> OR .

    INTEGER         reduce using rule 85 (logic_connector -> OR .)
    FLOAT           reduce using rule 85 (logic_connector -> OR .)
    STRING          reduce using rule 85 (logic_connector -> OR .)
    BOOLEAN         reduce using rule 85 (logic_connector -> OR .)
    ID              reduce using rule 85 (logic_connector -> OR .)
    VAR_INST        reduce using rule 85 (logic_connector -> OR .)
    TRUE            reduce using rule 85 (logic_connector -> OR .)
    FALSE           reduce using rule 85 (logic_connector -> OR .)
    NIL             reduce using rule 85 (logic_connector -> OR .)
    LPAREN          reduce using rule 85 (logic_connector -> OR .)


state 119

    (73) condition -> IF logic_expression body END .

    ID              reduce using rule 73 (condition -> IF logic_expression body END .)
    VAR_INST        reduce using rule 73 (condition -> IF logic_expression body END .)
    PUTS            reduce using rule 73 (condition -> IF logic_expression body END .)
    IF              reduce using rule 73 (condition -> IF logic_expression body END .)
    WHILE           reduce using rule 73 (condition -> IF logic_expression body END .)
    FOR             reduce using rule 73 (condition -> IF logic_expression body END .)
    LPAREN          reduce using rule 73 (condition -> IF logic_expression body END .)
    INTEGER         reduce using rule 73 (condition -> IF logic_expression body END .)
    DEF             reduce using rule 73 (condition -> IF logic_expression body END .)
    CLASS           reduce using rule 73 (condition -> IF logic_expression body END .)
    RETURN          reduce using rule 73 (condition -> IF logic_expression body END .)
    BREAK           reduce using rule 73 (condition -> IF logic_expression body END .)
    FLOAT           reduce using rule 73 (condition -> IF logic_expression body END .)
    STRING          reduce using rule 73 (condition -> IF logic_expression body END .)
    BOOLEAN         reduce using rule 73 (condition -> IF logic_expression body END .)
    TRUE            reduce using rule 73 (condition -> IF logic_expression body END .)
    FALSE           reduce using rule 73 (condition -> IF logic_expression body END .)
    NIL             reduce using rule 73 (condition -> IF logic_expression body END .)
    $end            reduce using rule 73 (condition -> IF logic_expression body END .)
    END             reduce using rule 73 (condition -> IF logic_expression body END .)
    ELSE            reduce using rule 73 (condition -> IF logic_expression body END .)


state 120

    (74) condition -> IF logic_expression body ELSE . body END
    (8) body -> . body sentence
    (9) body -> . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    logic_expression               shift and go to state 28
    body                           shift and go to state 140
    sentence                       shift and go to state 97
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25

state 121

    (8) body -> body sentence .

    END             reduce using rule 8 (body -> body sentence .)
    ELSE            reduce using rule 8 (body -> body sentence .)
    ID              reduce using rule 8 (body -> body sentence .)
    VAR_INST        reduce using rule 8 (body -> body sentence .)
    PUTS            reduce using rule 8 (body -> body sentence .)
    IF              reduce using rule 8 (body -> body sentence .)
    WHILE           reduce using rule 8 (body -> body sentence .)
    FOR             reduce using rule 8 (body -> body sentence .)
    LPAREN          reduce using rule 8 (body -> body sentence .)
    INTEGER         reduce using rule 8 (body -> body sentence .)
    DEF             reduce using rule 8 (body -> body sentence .)
    CLASS           reduce using rule 8 (body -> body sentence .)
    RETURN          reduce using rule 8 (body -> body sentence .)
    BREAK           reduce using rule 8 (body -> body sentence .)
    FLOAT           reduce using rule 8 (body -> body sentence .)
    STRING          reduce using rule 8 (body -> body sentence .)
    BOOLEAN         reduce using rule 8 (body -> body sentence .)
    TRUE            reduce using rule 8 (body -> body sentence .)
    FALSE           reduce using rule 8 (body -> body sentence .)
    NIL             reduce using rule 8 (body -> body sentence .)


state 122

    (68) while_loop -> WHILE logic_expression body END .

    ID              reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    VAR_INST        reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    PUTS            reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    IF              reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    WHILE           reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    FOR             reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    LPAREN          reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    INTEGER         reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    DEF             reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    CLASS           reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    RETURN          reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    BREAK           reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    FLOAT           reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    STRING          reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    BOOLEAN         reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    TRUE            reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    FALSE           reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    NIL             reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    $end            reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    END             reduce using rule 68 (while_loop -> WHILE logic_expression body END .)
    ELSE            reduce using rule 68 (while_loop -> WHILE logic_expression body END .)


state 123

    (64) for_loop -> FOR ID IN range_incl . body END
    (8) body -> . body sentence
    (9) body -> . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    range_incl                     shift and go to state 12
    body                           shift and go to state 141
    sentence                       shift and go to state 97
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 124

    (69) range_incl -> LPAREN . INTEGER RANGE_INCL INTEGER RPAREN

    INTEGER         shift and go to state 142


state 125

    (70) range_incl -> INTEGER . RANGE_INCL INTEGER

    RANGE_INCL      shift and go to state 75


state 126

    (69) range_incl -> LPAREN INTEGER RANGE_INCL INTEGER . RPAREN
    (70) range_incl -> INTEGER RANGE_INCL INTEGER .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 143
    EQUALS          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    NEQUALS         reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    GREATEREQ       reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    LESSEQ          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    GREATERT        reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    LESST           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    TIMES           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    DIVIDE          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    EXPONENT        reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    MODULE          reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    PLUS            reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)
    MINUS           reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .)

  ! RPAREN          [ reduce using rule 70 (range_incl -> INTEGER RANGE_INCL INTEGER .) ]


state 127

    (71) range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER . RPAREN
    (72) range_excl -> INTEGER RANGE_EXCL INTEGER .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 144
    EQUALS          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    NEQUALS         reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    GREATEREQ       reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    LESSEQ          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    GREATERT        reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    LESST           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    TIMES           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    DIVIDE          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    EXPONENT        reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    MODULE          reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    PLUS            reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)
    MINUS           reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .)

  ! RPAREN          [ reduce using rule 72 (range_excl -> INTEGER RANGE_EXCL INTEGER .) ]


state 128

    (4) function -> DEF ID body END .

    ID              reduce using rule 4 (function -> DEF ID body END .)
    VAR_INST        reduce using rule 4 (function -> DEF ID body END .)
    PUTS            reduce using rule 4 (function -> DEF ID body END .)
    IF              reduce using rule 4 (function -> DEF ID body END .)
    WHILE           reduce using rule 4 (function -> DEF ID body END .)
    FOR             reduce using rule 4 (function -> DEF ID body END .)
    LPAREN          reduce using rule 4 (function -> DEF ID body END .)
    INTEGER         reduce using rule 4 (function -> DEF ID body END .)
    DEF             reduce using rule 4 (function -> DEF ID body END .)
    CLASS           reduce using rule 4 (function -> DEF ID body END .)
    RETURN          reduce using rule 4 (function -> DEF ID body END .)
    BREAK           reduce using rule 4 (function -> DEF ID body END .)
    FLOAT           reduce using rule 4 (function -> DEF ID body END .)
    STRING          reduce using rule 4 (function -> DEF ID body END .)
    BOOLEAN         reduce using rule 4 (function -> DEF ID body END .)
    TRUE            reduce using rule 4 (function -> DEF ID body END .)
    FALSE           reduce using rule 4 (function -> DEF ID body END .)
    NIL             reduce using rule 4 (function -> DEF ID body END .)
    $end            reduce using rule 4 (function -> DEF ID body END .)
    END             reduce using rule 4 (function -> DEF ID body END .)
    ELSE            reduce using rule 4 (function -> DEF ID body END .)


state 129

    (6) args -> ID .
    (7) args -> ID . COMMA args
    (50) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 6 (args -> ID .)
    RPAREN          reduce using rule 6 (args -> ID .)
    COMMA           shift and go to state 114
    EQUALS          reduce using rule 50 (factor -> ID .)
    NEQUALS         reduce using rule 50 (factor -> ID .)
    GREATEREQ       reduce using rule 50 (factor -> ID .)
    LESSEQ          reduce using rule 50 (factor -> ID .)
    GREATERT        reduce using rule 50 (factor -> ID .)
    LESST           reduce using rule 50 (factor -> ID .)
    TIMES           reduce using rule 50 (factor -> ID .)
    DIVIDE          reduce using rule 50 (factor -> ID .)
    EXPONENT        reduce using rule 50 (factor -> ID .)
    MODULE          reduce using rule 50 (factor -> ID .)
    PLUS            reduce using rule 50 (factor -> ID .)
    MINUS           reduce using rule 50 (factor -> ID .)

  ! RPAREN          [ reduce using rule 50 (factor -> ID .) ]


state 130

    (5) function -> DEF ID LPAREN args . RPAREN body END

    RPAREN          shift and go to state 145


state 131

    (12) class_def -> CLASS ID body END .

    ID              reduce using rule 12 (class_def -> CLASS ID body END .)
    VAR_INST        reduce using rule 12 (class_def -> CLASS ID body END .)
    PUTS            reduce using rule 12 (class_def -> CLASS ID body END .)
    IF              reduce using rule 12 (class_def -> CLASS ID body END .)
    WHILE           reduce using rule 12 (class_def -> CLASS ID body END .)
    FOR             reduce using rule 12 (class_def -> CLASS ID body END .)
    LPAREN          reduce using rule 12 (class_def -> CLASS ID body END .)
    INTEGER         reduce using rule 12 (class_def -> CLASS ID body END .)
    DEF             reduce using rule 12 (class_def -> CLASS ID body END .)
    CLASS           reduce using rule 12 (class_def -> CLASS ID body END .)
    RETURN          reduce using rule 12 (class_def -> CLASS ID body END .)
    BREAK           reduce using rule 12 (class_def -> CLASS ID body END .)
    FLOAT           reduce using rule 12 (class_def -> CLASS ID body END .)
    STRING          reduce using rule 12 (class_def -> CLASS ID body END .)
    BOOLEAN         reduce using rule 12 (class_def -> CLASS ID body END .)
    TRUE            reduce using rule 12 (class_def -> CLASS ID body END .)
    FALSE           reduce using rule 12 (class_def -> CLASS ID body END .)
    NIL             reduce using rule 12 (class_def -> CLASS ID body END .)
    $end            reduce using rule 12 (class_def -> CLASS ID body END .)
    END             reduce using rule 12 (class_def -> CLASS ID body END .)
    ELSE            reduce using rule 12 (class_def -> CLASS ID body END .)


state 132

    (37) method_chain -> method_chain DOT . ID

    ID              shift and go to state 146


state 133

    (36) method_chain -> DOT ID .

    DOT             reduce using rule 36 (method_chain -> DOT ID .)
    ID              reduce using rule 36 (method_chain -> DOT ID .)
    VAR_INST        reduce using rule 36 (method_chain -> DOT ID .)
    PUTS            reduce using rule 36 (method_chain -> DOT ID .)
    IF              reduce using rule 36 (method_chain -> DOT ID .)
    WHILE           reduce using rule 36 (method_chain -> DOT ID .)
    FOR             reduce using rule 36 (method_chain -> DOT ID .)
    LPAREN          reduce using rule 36 (method_chain -> DOT ID .)
    INTEGER         reduce using rule 36 (method_chain -> DOT ID .)
    DEF             reduce using rule 36 (method_chain -> DOT ID .)
    CLASS           reduce using rule 36 (method_chain -> DOT ID .)
    RETURN          reduce using rule 36 (method_chain -> DOT ID .)
    BREAK           reduce using rule 36 (method_chain -> DOT ID .)
    FLOAT           reduce using rule 36 (method_chain -> DOT ID .)
    STRING          reduce using rule 36 (method_chain -> DOT ID .)
    BOOLEAN         reduce using rule 36 (method_chain -> DOT ID .)
    TRUE            reduce using rule 36 (method_chain -> DOT ID .)
    FALSE           reduce using rule 36 (method_chain -> DOT ID .)
    NIL             reduce using rule 36 (method_chain -> DOT ID .)
    $end            reduce using rule 36 (method_chain -> DOT ID .)
    END             reduce using rule 36 (method_chain -> DOT ID .)
    ELSE            reduce using rule 36 (method_chain -> DOT ID .)


state 134

    (61) array -> ID ASSIGN LCORCH elements RCORCH .

    ID              reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    VAR_INST        reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    PUTS            reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    IF              reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    WHILE           reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    FOR             reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    LPAREN          reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    INTEGER         reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    DEF             reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    CLASS           reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    RETURN          reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    BREAK           reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    FLOAT           reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    STRING          reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    BOOLEAN         reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    TRUE            reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    FALSE           reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    NIL             reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    $end            reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    END             reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)
    ELSE            reduce using rule 61 (array -> ID ASSIGN LCORCH elements RCORCH .)


state 135

    (63) elements -> factor COMMA . elements
    (62) elements -> . factor
    (63) elements -> . factor COMMA elements
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    factor                         shift and go to state 111
    elements                       shift and go to state 147
    expression                     shift and go to state 65
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67
    term                           shift and go to state 23

state 136

    (65) hash -> ID ASSIGN LBRACE hash_pairs RBRACE .

    ID              reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    VAR_INST        reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    PUTS            reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    IF              reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    WHILE           reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    FOR             reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    LPAREN          reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    INTEGER         reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    DEF             reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    CLASS           reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    RETURN          reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    BREAK           reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    FLOAT           reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    STRING          reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    BOOLEAN         reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    TRUE            reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    FALSE           reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    NIL             reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    $end            reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    END             reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)
    ELSE            reduce using rule 65 (hash -> ID ASSIGN LBRACE hash_pairs RBRACE .)


state 137

    (66) hash_pairs -> STRING COLON . factor
    (67) hash_pairs -> STRING COLON . factor COMMA hash_pairs
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor

    INTEGER         shift and go to state 61
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    ID              shift and go to state 62
    VAR_INST        shift and go to state 63
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41
    LPAREN          shift and go to state 64

    factor                         shift and go to state 148
    expression                     shift and go to state 65
    logic_expression               shift and go to state 28
    range_incl                     shift and go to state 66
    range_excl                     shift and go to state 67
    term                           shift and go to state 23

state 138

    (7) args -> ID COMMA args .

    RPAREN          reduce using rule 7 (args -> ID COMMA args .)


state 139

    (76) logic_expression -> factor logic_op factor logic_connector logic_expression .
    (56) factor -> logic_expression .

  ! reduce/reduce conflict for EQUALS resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for NEQUALS resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for GREATERT resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for LESST resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for EXPONENT resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for MODULE resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 56 (factor -> logic_expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 56 (factor -> logic_expression .)
    ID              reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    VAR_INST        reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    PUTS            reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    IF              reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    WHILE           reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    FOR             reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    LPAREN          reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    INTEGER         reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    DEF             reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    CLASS           reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    RETURN          reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    BREAK           reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    FLOAT           reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    STRING          reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    BOOLEAN         reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    TRUE            reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    FALSE           reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    NIL             reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    $end            reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    END             reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    ELSE            reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    RPAREN          reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    AND             reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    OR              reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    COMMA           reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    RCORCH          reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    RBRACE          reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .)
    EQUALS          reduce using rule 56 (factor -> logic_expression .)
    NEQUALS         reduce using rule 56 (factor -> logic_expression .)
    GREATEREQ       reduce using rule 56 (factor -> logic_expression .)
    LESSEQ          reduce using rule 56 (factor -> logic_expression .)
    GREATERT        reduce using rule 56 (factor -> logic_expression .)
    LESST           reduce using rule 56 (factor -> logic_expression .)
    TIMES           reduce using rule 56 (factor -> logic_expression .)
    DIVIDE          reduce using rule 56 (factor -> logic_expression .)
    EXPONENT        reduce using rule 56 (factor -> logic_expression .)
    MODULE          reduce using rule 56 (factor -> logic_expression .)
    PLUS            reduce using rule 56 (factor -> logic_expression .)
    MINUS           reduce using rule 56 (factor -> logic_expression .)

  ! EQUALS          [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! NEQUALS         [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! GREATEREQ       [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! LESSEQ          [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! GREATERT        [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! LESST           [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! TIMES           [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! DIVIDE          [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! EXPONENT        [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! MODULE          [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! PLUS            [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]
  ! MINUS           [ reduce using rule 76 (logic_expression -> factor logic_op factor logic_connector logic_expression .) ]


state 140

    (74) condition -> IF logic_expression body ELSE body . END
    (8) body -> body . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    END             shift and go to state 149
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    logic_expression               shift and go to state 28
    sentence                       shift and go to state 121
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25

state 141

    (64) for_loop -> FOR ID IN range_incl body . END
    (8) body -> body . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    END             shift and go to state 150
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    range_incl                     shift and go to state 12
    sentence                       shift and go to state 121
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 142

    (69) range_incl -> LPAREN INTEGER . RANGE_INCL INTEGER RPAREN

    RANGE_INCL      shift and go to state 151


state 143

    (69) range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .

    ID              reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    VAR_INST        reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    PUTS            reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    IF              reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    WHILE           reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    FOR             reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    LPAREN          reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    INTEGER         reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    DEF             reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    CLASS           reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    RETURN          reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    BREAK           reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    FLOAT           reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    STRING          reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    BOOLEAN         reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    TRUE            reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    FALSE           reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    NIL             reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    $end            reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    EQUALS          reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    NEQUALS         reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    GREATEREQ       reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    LESSEQ          reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    GREATERT        reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    LESST           reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    TIMES           reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    DIVIDE          reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    EXPONENT        reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    MODULE          reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    PLUS            reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    MINUS           reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    END             reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    ELSE            reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    RPAREN          reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    AND             reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    OR              reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    COMMA           reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    RCORCH          reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)
    RBRACE          reduce using rule 69 (range_incl -> LPAREN INTEGER RANGE_INCL INTEGER RPAREN .)


state 144

    (71) range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .

    ID              reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    VAR_INST        reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    PUTS            reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    IF              reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    WHILE           reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    FOR             reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    LPAREN          reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    INTEGER         reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    DEF             reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    CLASS           reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    RETURN          reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    BREAK           reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    FLOAT           reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    STRING          reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    BOOLEAN         reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    TRUE            reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    FALSE           reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    NIL             reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    $end            reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    EQUALS          reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    NEQUALS         reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    GREATEREQ       reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    LESSEQ          reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    GREATERT        reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    LESST           reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    TIMES           reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    DIVIDE          reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    EXPONENT        reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    MODULE          reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    PLUS            reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    MINUS           reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    END             reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    ELSE            reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    RPAREN          reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    AND             reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    OR              reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    COMMA           reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    RCORCH          reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)
    RBRACE          reduce using rule 71 (range_excl -> LPAREN INTEGER RANGE_EXCL INTEGER RPAREN .)


state 145

    (5) function -> DEF ID LPAREN args RPAREN . body END
    (8) body -> . body sentence
    (9) body -> . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    body                           shift and go to state 152
    sentence                       shift and go to state 97
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 146

    (37) method_chain -> method_chain DOT ID .

    DOT             reduce using rule 37 (method_chain -> method_chain DOT ID .)
    ID              reduce using rule 37 (method_chain -> method_chain DOT ID .)
    VAR_INST        reduce using rule 37 (method_chain -> method_chain DOT ID .)
    PUTS            reduce using rule 37 (method_chain -> method_chain DOT ID .)
    IF              reduce using rule 37 (method_chain -> method_chain DOT ID .)
    WHILE           reduce using rule 37 (method_chain -> method_chain DOT ID .)
    FOR             reduce using rule 37 (method_chain -> method_chain DOT ID .)
    LPAREN          reduce using rule 37 (method_chain -> method_chain DOT ID .)
    INTEGER         reduce using rule 37 (method_chain -> method_chain DOT ID .)
    DEF             reduce using rule 37 (method_chain -> method_chain DOT ID .)
    CLASS           reduce using rule 37 (method_chain -> method_chain DOT ID .)
    RETURN          reduce using rule 37 (method_chain -> method_chain DOT ID .)
    BREAK           reduce using rule 37 (method_chain -> method_chain DOT ID .)
    FLOAT           reduce using rule 37 (method_chain -> method_chain DOT ID .)
    STRING          reduce using rule 37 (method_chain -> method_chain DOT ID .)
    BOOLEAN         reduce using rule 37 (method_chain -> method_chain DOT ID .)
    TRUE            reduce using rule 37 (method_chain -> method_chain DOT ID .)
    FALSE           reduce using rule 37 (method_chain -> method_chain DOT ID .)
    NIL             reduce using rule 37 (method_chain -> method_chain DOT ID .)
    $end            reduce using rule 37 (method_chain -> method_chain DOT ID .)
    END             reduce using rule 37 (method_chain -> method_chain DOT ID .)
    ELSE            reduce using rule 37 (method_chain -> method_chain DOT ID .)


state 147

    (63) elements -> factor COMMA elements .

    RCORCH          reduce using rule 63 (elements -> factor COMMA elements .)


state 148

    (66) hash_pairs -> STRING COLON factor .
    (67) hash_pairs -> STRING COLON factor . COMMA hash_pairs
    (75) logic_expression -> factor . logic_op factor
    (76) logic_expression -> factor . logic_op factor logic_connector logic_expression
    (45) term -> factor .
    (78) logic_op -> . EQUALS
    (79) logic_op -> . NEQUALS
    (80) logic_op -> . GREATEREQ
    (81) logic_op -> . LESSEQ
    (82) logic_op -> . GREATERT
    (83) logic_op -> . LESST

  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for NEQUALS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for GREATERT resolved as shift
  ! shift/reduce conflict for LESST resolved as shift
    RBRACE          reduce using rule 66 (hash_pairs -> STRING COLON factor .)
    COMMA           shift and go to state 153
    TIMES           reduce using rule 45 (term -> factor .)
    DIVIDE          reduce using rule 45 (term -> factor .)
    EXPONENT        reduce using rule 45 (term -> factor .)
    MODULE          reduce using rule 45 (term -> factor .)
    PLUS            reduce using rule 45 (term -> factor .)
    MINUS           reduce using rule 45 (term -> factor .)
    EQUALS          shift and go to state 46
    NEQUALS         shift and go to state 47
    GREATEREQ       shift and go to state 48
    LESSEQ          shift and go to state 49
    GREATERT        shift and go to state 50
    LESST           shift and go to state 51

  ! EQUALS          [ reduce using rule 45 (term -> factor .) ]
  ! NEQUALS         [ reduce using rule 45 (term -> factor .) ]
  ! GREATEREQ       [ reduce using rule 45 (term -> factor .) ]
  ! LESSEQ          [ reduce using rule 45 (term -> factor .) ]
  ! GREATERT        [ reduce using rule 45 (term -> factor .) ]
  ! LESST           [ reduce using rule 45 (term -> factor .) ]

    logic_op                       shift and go to state 68

state 149

    (74) condition -> IF logic_expression body ELSE body END .

    ID              reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    VAR_INST        reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    PUTS            reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    IF              reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    WHILE           reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    FOR             reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    LPAREN          reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    INTEGER         reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    DEF             reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    CLASS           reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    RETURN          reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    BREAK           reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    FLOAT           reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    STRING          reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    BOOLEAN         reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    TRUE            reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    FALSE           reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    NIL             reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    $end            reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    END             reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)
    ELSE            reduce using rule 74 (condition -> IF logic_expression body ELSE body END .)


state 150

    (64) for_loop -> FOR ID IN range_incl body END .

    ID              reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    VAR_INST        reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    PUTS            reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    IF              reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    WHILE           reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    FOR             reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    LPAREN          reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    INTEGER         reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    DEF             reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    CLASS           reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    RETURN          reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    BREAK           reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    FLOAT           reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    STRING          reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    BOOLEAN         reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    TRUE            reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    FALSE           reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    NIL             reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    $end            reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    END             reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)
    ELSE            reduce using rule 64 (for_loop -> FOR ID IN range_incl body END .)


state 151

    (69) range_incl -> LPAREN INTEGER RANGE_INCL . INTEGER RPAREN

    INTEGER         shift and go to state 154


state 152

    (5) function -> DEF ID LPAREN args RPAREN body . END
    (8) body -> body . sentence
    (13) sentence -> . assignment
    (14) sentence -> . expression
    (15) sentence -> . print
    (16) sentence -> . input
    (17) sentence -> . condition
    (18) sentence -> . while_loop
    (19) sentence -> . for_loop
    (20) sentence -> . array
    (21) sentence -> . range_incl
    (22) sentence -> . range_excl
    (23) sentence -> . hash
    (24) sentence -> . function
    (25) sentence -> . class_def
    (26) sentence -> . return_stmt
    (27) sentence -> . break_stmt
    (28) sentence -> . function_call_empty
    (29) sentence -> . function_call_args
    (32) assignment -> . ID ASSIGN expression
    (33) assignment -> . VAR_INST ASSIGN expression
    (38) expression -> . expression PLUS term
    (39) expression -> . expression MINUS term
    (40) expression -> . term
    (10) print -> . PUTS factor
    (11) print -> . PUTS STRING
    (34) input -> . PUTS STRING
    (35) input -> . ID ASSIGN GETS method_chain
    (73) condition -> . IF logic_expression body END
    (74) condition -> . IF logic_expression body ELSE body END
    (68) while_loop -> . WHILE logic_expression body END
    (64) for_loop -> . FOR ID IN range_incl body END
    (61) array -> . ID ASSIGN LCORCH elements RCORCH
    (69) range_incl -> . LPAREN INTEGER RANGE_INCL INTEGER RPAREN
    (70) range_incl -> . INTEGER RANGE_INCL INTEGER
    (71) range_excl -> . LPAREN INTEGER RANGE_EXCL INTEGER RPAREN
    (72) range_excl -> . INTEGER RANGE_EXCL INTEGER
    (65) hash -> . ID ASSIGN LBRACE hash_pairs RBRACE
    (4) function -> . DEF ID body END
    (5) function -> . DEF ID LPAREN args RPAREN body END
    (12) class_def -> . CLASS ID body END
    (30) return_stmt -> . RETURN factor
    (31) break_stmt -> . BREAK
    (59) function_call_empty -> . ID LPAREN RPAREN
    (60) function_call_args -> . ID LPAREN args RPAREN
    (41) term -> . term TIMES factor
    (42) term -> . term DIVIDE factor
    (43) term -> . term EXPONENT factor
    (44) term -> . term MODULE factor
    (45) term -> . factor
    (46) factor -> . INTEGER
    (47) factor -> . FLOAT
    (48) factor -> . STRING
    (49) factor -> . BOOLEAN
    (50) factor -> . ID
    (51) factor -> . VAR_INST
    (52) factor -> . TRUE
    (53) factor -> . FALSE
    (54) factor -> . NIL
    (55) factor -> . LPAREN expression RPAREN
    (56) factor -> . logic_expression
    (57) factor -> . range_incl
    (58) factor -> . range_excl
    (75) logic_expression -> . factor logic_op factor
    (76) logic_expression -> . factor logic_op factor logic_connector logic_expression
    (77) logic_expression -> . expression logic_op expression

    END             shift and go to state 155
    ID              shift and go to state 21
    VAR_INST        shift and go to state 22
    PUTS            shift and go to state 24
    IF              shift and go to state 27
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    LPAREN          shift and go to state 31
    INTEGER         shift and go to state 32
    DEF             shift and go to state 33
    CLASS           shift and go to state 34
    RETURN          shift and go to state 35
    BREAK           shift and go to state 36
    FLOAT           shift and go to state 37
    STRING          shift and go to state 26
    BOOLEAN         shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    NIL             shift and go to state 41

    sentence                       shift and go to state 121
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    print                          shift and go to state 6
    input                          shift and go to state 7
    condition                      shift and go to state 8
    while_loop                     shift and go to state 9
    for_loop                       shift and go to state 10
    array                          shift and go to state 11
    range_incl                     shift and go to state 12
    range_excl                     shift and go to state 13
    hash                           shift and go to state 14
    function                       shift and go to state 15
    class_def                      shift and go to state 16
    return_stmt                    shift and go to state 17
    break_stmt                     shift and go to state 18
    function_call_empty            shift and go to state 19
    function_call_args             shift and go to state 20
    term                           shift and go to state 23
    factor                         shift and go to state 25
    logic_expression               shift and go to state 28

state 153

    (67) hash_pairs -> STRING COLON factor COMMA . hash_pairs
    (66) hash_pairs -> . STRING COLON factor
    (67) hash_pairs -> . STRING COLON factor COMMA hash_pairs

    STRING          shift and go to state 113

    hash_pairs                     shift and go to state 156

state 154

    (69) range_incl -> LPAREN INTEGER RANGE_INCL INTEGER . RPAREN

    RPAREN          shift and go to state 143


state 155

    (5) function -> DEF ID LPAREN args RPAREN body END .

    ID              reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    VAR_INST        reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    PUTS            reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    IF              reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    WHILE           reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    FOR             reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    LPAREN          reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    INTEGER         reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    DEF             reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    CLASS           reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    RETURN          reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    BREAK           reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    FLOAT           reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    STRING          reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    BOOLEAN         reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    TRUE            reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    FALSE           reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    NIL             reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    $end            reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    END             reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)
    ELSE            reduce using rule 5 (function -> DEF ID LPAREN args RPAREN body END .)


state 156

    (67) hash_pairs -> STRING COLON factor COMMA hash_pairs .

    RBRACE          reduce using rule 67 (hash_pairs -> STRING COLON factor COMMA hash_pairs .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 21 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 23 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 23 resolved as shift
WARNING: shift/reduce conflict for EXPONENT in state 23 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 23 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 25 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 25 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 25 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 25 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 25 resolved as shift
WARNING: shift/reduce conflict for LESST in state 25 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 59 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 59 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 59 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 59 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 59 resolved as shift
WARNING: shift/reduce conflict for LESST in state 59 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 70 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 70 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 70 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 70 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 70 resolved as shift
WARNING: shift/reduce conflict for LESST in state 70 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 79 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 79 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 79 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 79 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 79 resolved as shift
WARNING: shift/reduce conflict for LESST in state 79 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 80 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 80 resolved as shift
WARNING: shift/reduce conflict for EXPONENT in state 80 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 80 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 81 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for EXPONENT in state 81 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 81 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 82 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 82 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 82 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 82 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 82 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 82 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 82 resolved as shift
WARNING: shift/reduce conflict for LESST in state 82 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 91 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 91 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 91 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 91 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 91 resolved as shift
WARNING: shift/reduce conflict for LESST in state 91 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 92 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 92 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 92 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 92 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 92 resolved as shift
WARNING: shift/reduce conflict for LESST in state 92 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 93 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 93 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 93 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 93 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 93 resolved as shift
WARNING: shift/reduce conflict for LESST in state 93 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 94 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 94 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 94 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 94 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 94 resolved as shift
WARNING: shift/reduce conflict for LESST in state 94 resolved as shift
WARNING: shift/reduce conflict for AND in state 95 resolved as shift
WARNING: shift/reduce conflict for OR in state 95 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 95 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 95 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 95 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 95 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 95 resolved as shift
WARNING: shift/reduce conflict for LESST in state 95 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 111 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 111 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 111 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 111 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 111 resolved as shift
WARNING: shift/reduce conflict for LESST in state 111 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 126 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 127 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 148 resolved as shift
WARNING: shift/reduce conflict for NEQUALS in state 148 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 148 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 148 resolved as shift
WARNING: shift/reduce conflict for GREATERT in state 148 resolved as shift
WARNING: shift/reduce conflict for LESST in state 148 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (sentence -> range_incl)
WARNING: rejected rule (factor -> range_incl) in state 12
WARNING: reduce/reduce conflict in state 13 resolved using rule (sentence -> range_excl)
WARNING: rejected rule (factor -> range_excl) in state 13
WARNING: reduce/reduce conflict in state 60 resolved using rule (print -> PUTS STRING)
WARNING: rejected rule (input -> PUTS STRING) in state 60
WARNING: reduce/reduce conflict in state 60 resolved using rule (print -> PUTS STRING)
WARNING: rejected rule (factor -> STRING) in state 60
WARNING: reduce/reduce conflict in state 80 resolved using rule (expression -> expression PLUS term)
WARNING: rejected rule (expression -> term) in state 80
WARNING: reduce/reduce conflict in state 81 resolved using rule (expression -> expression MINUS term)
WARNING: rejected rule (expression -> term) in state 81
WARNING: reduce/reduce conflict in state 91 resolved using rule (term -> term TIMES factor)
WARNING: rejected rule (term -> factor) in state 91
WARNING: reduce/reduce conflict in state 92 resolved using rule (term -> term DIVIDE factor)
WARNING: rejected rule (term -> factor) in state 92
WARNING: reduce/reduce conflict in state 93 resolved using rule (term -> term EXPONENT factor)
WARNING: rejected rule (term -> factor) in state 93
WARNING: reduce/reduce conflict in state 94 resolved using rule (term -> term MODULE factor)
WARNING: rejected rule (term -> factor) in state 94
WARNING: reduce/reduce conflict in state 95 resolved using rule (term -> factor)
WARNING: rejected rule (logic_expression -> factor logic_op factor) in state 95
WARNING: reduce/reduce conflict in state 129 resolved using rule (args -> ID)
WARNING: rejected rule (factor -> ID) in state 129
WARNING: reduce/reduce conflict in state 139 resolved using rule (factor -> logic_expression)
WARNING: rejected rule (logic_expression -> factor logic_op factor logic_connector logic_expression) in state 139
WARNING: Rule (input -> PUTS STRING) is never reduced
